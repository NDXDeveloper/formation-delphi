# 3.7.1 Classes et objets

ğŸ” Retour Ã  la [Table des matiÃ¨res](/SOMMAIRE.md)

AprÃ¨s notre introduction Ã  la programmation orientÃ©e objet, nous allons maintenant explorer plus en dÃ©tail le concept fondamental des classes et des objets en Object Pascal. C'est la base sur laquelle repose toute la programmation orientÃ©e objet dans Delphi.

## Qu'est-ce qu'une classe ?

Une classe est un modÃ¨le, un "plan" qui dÃ©finit :
- Les **donnÃ©es** (ou attributs) que contiendra un objet
- Les **opÃ©rations** (ou mÃ©thodes) que l'objet pourra effectuer

Pensez Ã  une classe comme Ã  la dÃ©finition d'un nouveau type de donnÃ©es personnalisÃ©. De la mÃªme faÃ§on que `Integer` dÃ©finit un type de donnÃ©es numÃ©riques, une classe comme `TPerson` dÃ©finirait un type de donnÃ©es reprÃ©sentant une personne.

## Qu'est-ce qu'un objet ?

Un objet est une instance concrÃ¨te d'une classe. Si la classe est le plan, l'objet est la "maison" construite selon ce plan. Vous pouvez crÃ©er plusieurs objets Ã  partir d'une mÃªme classe, chacun avec ses propres valeurs de donnÃ©es.

## DÃ©claration d'une classe

En Object Pascal, une classe se dÃ©clare avec le mot-clÃ© `class` :

```pascal
type
  TPerson = class
    // DÃ©finition de la classe
  end;
```

Par convention, les noms de classes en Delphi commencent gÃ©nÃ©ralement par la lettre `T` (pour "Type").

## Champs (attributs)

Les champs sont les variables qui stockent les donnÃ©es d'un objet. Ils se dÃ©clarent comme des variables normales, mais Ã  l'intÃ©rieur de la dÃ©finition de la classe :

```pascal
type
  TPerson = class
    FirstName: string;
    LastName: string;
    Age: Integer;
    Height: Double;
  end;
```

## MÃ©thodes

Les mÃ©thodes sont les procÃ©dures et fonctions qui dÃ©finissent le comportement d'un objet. Elles se dÃ©clarent dans la dÃ©finition de la classe, mais leur code est gÃ©nÃ©ralement implÃ©mentÃ© sÃ©parÃ©ment :

```pascal
type
  TPerson = class
    FirstName: string;
    LastName: string;
    Age: Integer;
    Height: Double;

    procedure Introduce;
    function GetFullName: string;
    procedure Birthday;
  end;

// ImplÃ©mentation des mÃ©thodes
procedure TPerson.Introduce;
begin
  ShowMessage('Bonjour, je m''appelle ' + FirstName + ' ' + LastName +
              ' et j''ai ' + IntToStr(Age) + ' ans.');
end;

function TPerson.GetFullName: string;
begin
  Result := FirstName + ' ' + LastName;
end;

procedure TPerson.Birthday;
begin
  Age := Age + 1;
  ShowMessage('Joyeux anniversaire! J''ai maintenant ' + IntToStr(Age) + ' ans.');
end;
```

Notez que dans l'implÃ©mentation des mÃ©thodes, nous prÃ©fixons le nom de la mÃ©thode avec le nom de la classe et un point : `TPerson.Introduce`.

## VisibilitÃ© et encapsulation

Une des forces de la POO est l'encapsulation, qui consiste Ã  protÃ©ger les donnÃ©es internes d'un objet. En Object Pascal, cela se fait avec des sections de visibilitÃ© :

```pascal
type
  TPerson = class
  private
    FFirstName: string;  // PrÃ©fixe F pour les champs privÃ©s
    FLastName: string;
    FAge: Integer;
  public
    procedure SetFirstName(const Value: string);
    function GetFullName: string;
    procedure Birthday;
  end;
```

Les niveaux de visibilitÃ© courants sont :

- `private` : Accessible uniquement Ã  l'intÃ©rieur de la classe
- `protected` : Accessible Ã  l'intÃ©rieur de la classe et de ses descendantes
- `public` : Accessible partout
- `published` : Comme public, mais avec des fonctionnalitÃ©s supplÃ©mentaires pour les composants visuels

Par convention, les champs privÃ©s sont souvent prÃ©fixÃ©s par la lettre `F`.

## CrÃ©ation et utilisation d'objets

Pour utiliser une classe, vous devez d'abord crÃ©er un objet (une instance) de cette classe. Cela se fait avec la mÃ©thode `Create` :

```pascal
var
  Person: TPerson;
begin
  Person := TPerson.Create;
  try
    Person.FirstName := 'Jean';
    Person.LastName := 'Dupont';
    Person.Age := 30;

    Person.Introduce;
    ShowMessage('Nom complet : ' + Person.GetFullName);

    Person.Birthday;
  finally
    Person.Free;  // LibÃ©ration de la mÃ©moire
  end;
end;
```

Notez les points importants :
1. Nous dÃ©clarons une variable `Person` de type `TPerson`
2. Nous crÃ©ons un nouvel objet avec `TPerson.Create`
3. Nous utilisons l'objet en accÃ©dant Ã  ses champs et mÃ©thodes avec la notation pointÃ©e
4. Nous libÃ©rons la mÃ©moire avec `Free` quand nous avons terminÃ©

## Structure try-finally pour la gestion de mÃ©moire

En Delphi, vous Ãªtes responsable de la libÃ©ration de la mÃ©moire utilisÃ©e par vos objets. L'utilisation d'un bloc `try-finally` comme ci-dessus est une bonne pratique qui garantit que la mÃ©moire sera libÃ©rÃ©e mÃªme en cas d'exception.

```pascal
Person := TPerson.Create;
try
  // Utilisation de l'objet
finally
  Person.Free;  // Sera toujours exÃ©cutÃ©
end;
```

## Champs vs. mÃ©thodes vs. propriÃ©tÃ©s

- **Champs** : Variables qui stockent les donnÃ©es (Ã©tat) de l'objet
- **MÃ©thodes** : ProcÃ©dures et fonctions qui dÃ©finissent le comportement de l'objet
- **PropriÃ©tÃ©s** : Interface contrÃ´lÃ©e pour accÃ©der aux champs (nous les verrons en dÃ©tail dans la section suivante)

## Self : rÃ©fÃ©rence Ã  l'objet courant

Dans les mÃ©thodes d'une classe, `Self` est une rÃ©fÃ©rence implicite Ã  l'objet sur lequel la mÃ©thode est appelÃ©e :

```pascal
procedure TPerson.ChangeFirstName(const NewName: string);
begin
  Self.FFirstName := NewName;  // Explicite avec Self
  FLastName := FLastName;      // Implicite (Self est sous-entendu)
end;
```

L'utilisation de `Self` est gÃ©nÃ©ralement facultative, sauf en cas d'ambiguÃ¯tÃ©.

## Classes et mÃ©moire

Les objets en Delphi sont allouÃ©s sur le tas (heap) et non sur la pile (stack). Cela signifie :
- Ils persistent jusqu'Ã  ce que vous les libÃ©riez explicitement
- Ils peuvent Ãªtre plus grands que les types simples
- Vous devez gÃ©rer leur cycle de vie (crÃ©ation et destruction)

C'est pourquoi nous utilisons `Create` et `Free` comme dans l'exemple ci-dessus.

## Exemple complet d'une classe

Voici un exemple complet d'une classe `TProduct` qui pourrait Ãªtre utilisÃ©e dans une application de gestion d'inventaire :

```pascal
type
  TProduct = class
  private
    FCode: string;
    FName: string;
    FPrice: Currency;
    FQuantity: Integer;

  public
    // Constructeur personnalisÃ©
    constructor Create(const ACode, AName: string; APrice: Currency; AQuantity: Integer = 0);

    // MÃ©thodes
    procedure AddStock(Amount: Integer);
    procedure RemoveStock(Amount: Integer);
    function CalculateTotalValue: Currency;
    procedure Display;

    // AccÃ¨s aux champs privÃ©s
    property Code: string read FCode;
    property Name: string read FName write FName;
    property Price: Currency read FPrice write FPrice;
    property Quantity: Integer read FQuantity;
  end;

// ImplÃ©mentation
constructor TProduct.Create(const ACode, AName: string; APrice: Currency; AQuantity: Integer = 0);
begin
  inherited Create;  // Appelle le constructeur de la classe parente
  FCode := ACode;
  FName := AName;
  FPrice := APrice;
  FQuantity := AQuantity;
end;

procedure TProduct.AddStock(Amount: Integer);
begin
  if Amount > 0 then
    FQuantity := FQuantity + Amount;
end;

procedure TProduct.RemoveStock(Amount: Integer);
begin
  if (Amount > 0) and (Amount <= FQuantity) then
    FQuantity := FQuantity - Amount;
end;

function TProduct.CalculateTotalValue: Currency;
begin
  Result := FPrice * FQuantity;
end;

procedure TProduct.Display;
begin
  ShowMessage(Format('Produit: %s - %s'#13#10'Prix: %.2f â‚¬'#13#10'QuantitÃ©: %d'#13#10'Valeur totale: %.2f â‚¬',
                    [FCode, FName, FPrice, FQuantity, CalculateTotalValue]));
end;
```

Utilisation de cette classe :

```pascal
procedure TForm1.ButtonCreateProductClick(Sender: TObject);
var
  Product: TProduct;
begin
  Product := TProduct.Create('A001', 'Clavier sans fil', 49.99, 10);
  try
    // Utilisation du produit
    Product.AddStock(5);
    Product.Display;

    // Modification du prix
    Product.Price := 45.99;

    // Retrait du stock
    Product.RemoveStock(3);

    // Affichage mis Ã  jour
    Product.Display;
  finally
    Product.Free;
  end;
end;
```

## DÃ©claration et implÃ©mentation dans des unitÃ©s

Dans une application rÃ©elle, vous placerez gÃ©nÃ©ralement :

1. La dÃ©claration de classe dans la section `interface` de l'unitÃ© :
```pascal
unit ProductUnit;

interface

type
  TProduct = class
    // DÃ©claration de la classe
  end;

implementation

// ImplÃ©mentation des mÃ©thodes ici
```

2. L'implÃ©mentation des mÃ©thodes dans la section `implementation` :
```pascal
implementation

procedure TProduct.AddStock(Amount: Integer);
begin
  // Code ici
end;

// Autres mÃ©thodes...
```

## Classes dÃ©jÃ  disponibles dans Delphi

Delphi est livrÃ© avec de nombreuses classes prÃ©dÃ©finies :

- `TObject` : Classe de base dont hÃ©ritent toutes les classes
- `TComponent` : Base pour les composants
- `TControl` : Base pour les contrÃ´les visuels
- `TForm` : Formulaires
- `TButton`, `TEdit`, `TLabel`, etc. : ContrÃ´les visuels courants
- `TStringList`, `TList` : Collections
- Et bien d'autres...

## Conseils pratiques

1. **Nommage cohÃ©rent** :
   - PrÃ©fixez les classes par `T`
   - PrÃ©fixez les champs privÃ©s par `F`
   - Utilisez des noms clairs et descriptifs

2. **Encapsulation** :
   - Rendez les champs `private` et accÃ©dez-y via des propriÃ©tÃ©s ou mÃ©thodes
   - Ne rendez `public` que ce qui doit l'Ãªtre

3. **Gestion de la mÃ©moire** :
   - Utilisez toujours `try-finally` pour libÃ©rer vos objets
   - Initialisez vos variables d'objets Ã  `nil`
   - VÃ©rifiez si un objet est `nil` avant de l'utiliser

4. **Conception** :
   - Une classe devrait avoir une responsabilitÃ© claire et unique
   - Gardez vos classes relativement petites et focalisÃ©es

---

Les classes et objets forment le fondement de la programmation orientÃ©e objet. Maintenant que vous comprenez ces concepts de base, nous verrons dans la section suivante comment utiliser les propriÃ©tÃ©s et mÃ©thodes pour crÃ©er des interfaces plus Ã©lÃ©gantes et contrÃ´lÃ©es pour vos classes.

â­ï¸ [PropriÃ©tÃ©s et mÃ©thodes](/03-langage-object-pascal/07.2-proprietes-methodes.md)

