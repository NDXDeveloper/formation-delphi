# 3.7.2 Propri√©t√©s et m√©thodes

üîù Retour √† la [Table des mati√®res](/SOMMAIRE.md)

Apr√®s avoir d√©couvert les classes et objets, nous allons maintenant explorer en d√©tail deux √©l√©ments fondamentaux qui les composent : les propri√©t√©s et les m√©thodes. Ces concepts sont essentiels pour cr√©er des classes bien con√ßues et faciles √† utiliser.

## M√©thodes : le comportement d'une classe

Les m√©thodes sont des proc√©dures et fonctions associ√©es √† une classe. Elles d√©finissent ce que les objets de la classe peuvent faire (leur comportement).

### D√©claration et impl√©mentation des m√©thodes

La d√©claration d'une m√©thode se fait dans la d√©finition de la classe, tandis que son impl√©mentation est g√©n√©ralement plac√©e dans la section `implementation` de l'unit√© :

```pascal
type
  TCalculatrice = class
  public
    function Additionner(A, B: Integer): Integer;
    procedure AfficherResultat(Valeur: Integer);
  end;

implementation

// Impl√©mentation de la premi√®re m√©thode
function TCalculatrice.Additionner(A, B: Integer): Integer;
begin
  Result := A + B;
end;

// Impl√©mentation de la seconde m√©thode
procedure TCalculatrice.AfficherResultat(Valeur: Integer);
begin
  ShowMessage('R√©sultat : ' + IntToStr(Valeur));
end;
```

### Types de m√©thodes

Il existe plusieurs types de m√©thodes en Object Pascal :

#### 1. M√©thodes d'instance

Ce sont les m√©thodes les plus courantes. Elles op√®rent sur un objet sp√©cifique et ont acc√®s √† tous ses champs.

```pascal
procedure TPerson.SetAge(NewAge: Integer);
begin
  if (NewAge >= 0) and (NewAge <= 120) then
    FAge := NewAge;
end;
```

#### 2. M√©thodes de classe (class methods)

Ces m√©thodes sont associ√©es √† la classe plut√¥t qu'√† une instance sp√©cifique. Elles sont d√©clar√©es avec le mot-cl√© `class`.

```pascal
type
  TMaths = class
  public
    class function Max(A, B: Integer): Integer;
  end;

class function TMaths.Max(A, B: Integer): Integer;
begin
  if A > B then
    Result := A
  else
    Result := B;
end;
```

Utilisation :
```pascal
X := TMaths.Max(10, 20);  // Donne 20 - notez qu'on utilise le nom de la classe
```

#### 3. M√©thodes statiques (static methods)

Semblables aux m√©thodes de classe, mais sans acc√®s √† la classe elle-m√™me.

```pascal
type
  TConversion = class
  public
    class var
      TauxChange: Double;
    class function EurosEnDollars(Euros: Double): Double; static;
  end;

class function TConversion.EurosEnDollars(Euros: Double): Double;
begin
  Result := Euros * TauxChange;  // Peut acc√©der aux champs de classe
end;
```

<span style="color: #0066CC">**N√©cessite Delphi 10.4 ou sup√©rieur pour static**</span>

#### 4. M√©thodes virtuelles

Les m√©thodes virtuelles peuvent √™tre red√©finies dans les classes d√©riv√©es. Nous les verrons plus en d√©tail dans la section sur l'h√©ritage.

```pascal
type
  TAnimal = class
  public
    function FaireBruit: string; virtual;
  end;
```

### Surcharge de m√©thodes

La surcharge permet d'avoir plusieurs m√©thodes avec le m√™me nom mais des param√®tres diff√©rents :

```pascal
type
  TCalculatrice = class
  public
    function Calculer(A, B: Integer): Integer; overload;
    function Calculer(A, B: Double): Double; overload;
  end;

implementation

function TCalculatrice.Calculer(A, B: Integer): Integer;
begin
  Result := A + B;
end;

function TCalculatrice.Calculer(A, B: Double): Double;
begin
  Result := A + B;
end;
```

Utilisation :
```pascal
var
  Calc: TCalculatrice;
begin
  Calc := TCalculatrice.Create;
  try
    ShowMessage(IntToStr(Calc.Calculer(5, 3)));      // Appelle la version Integer
    ShowMessage(FloatToStr(Calc.Calculer(5.2, 3.7))); // Appelle la version Double
  finally
    Calc.Free;
  end;
end;
```

## Propri√©t√©s : l'interface contr√¥l√©e aux donn√©es

Les propri√©t√©s sont une caract√©ristique puissante d'Object Pascal. Elles fournissent une interface contr√¥l√©e pour acc√©der aux champs d'une classe, combinant la simplicit√© d'utilisation des champs avec le contr√¥le des m√©thodes.

### D√©finition de base d'une propri√©t√©

Une propri√©t√© est typiquement associ√©e √† un champ priv√© et des m√©thodes d'acc√®s :

```pascal
type
  TPerson = class
  private
    FAge: Integer;           // Champ priv√©
    procedure SetAge(Value: Integer);  // M√©thode d'acc√®s en √©criture
  public
    property Age: Integer read FAge write SetAge;  // Propri√©t√©
  end;

implementation

procedure TPerson.SetAge(Value: Integer);
begin
  if (Value >= 0) and (Value <= 120) then  // Validation
    FAge := Value;
end;
```

Utilisation :
```pascal
var
  Person: TPerson;
begin
  Person := TPerson.Create;
  try
    Person.Age := 30;  // Utilise SetAge en interne
    ShowMessage('√Çge : ' + IntToStr(Person.Age));  // Lit directement FAge
  finally
    Person.Free;
  end;
end;
```

### Pourquoi utiliser des propri√©t√©s ?

Les propri√©t√©s offrent plusieurs avantages par rapport √† l'acc√®s direct aux champs :

1. **Validation** : Vous pouvez valider les valeurs avant de modifier un champ
2. **Encapsulation** : Le champ reste priv√©, mais la propri√©t√© peut √™tre publique
3. **Fonctionnalit√© suppl√©mentaire** : Vous pouvez ex√©cuter du code suppl√©mentaire lors de l'acc√®s
4. **Compatibilit√©** : Vous pouvez modifier l'impl√©mentation interne sans changer l'interface
5. **Support de l'IDE** : Les propri√©t√©s sont visibles dans l'inspecteur d'objets et l'√©diteur de code

### Diff√©rentes fa√ßons de d√©finir des propri√©t√©s

#### 1. Acc√®s direct au champ

```pascal
property Nom: string read FNom write FNom;
```

#### 2. M√©thodes d'acc√®s

```pascal
property Age: Integer read GetAge write SetAge;
```

#### 3. Mixte (lecture directe, √©criture par m√©thode)

```pascal
property Couleur: TColor read FCouleur write SetCouleur;
```

#### 4. Propri√©t√© en lecture seule

```pascal
property DateNaissance: TDateTime read FDateNaissance;
```

#### 5. Propri√©t√© en √©criture seule (rare)

```pascal
property MotDePasse: string write SetMotDePasse;
```

### M√©thodes d'acc√®s (Getters et Setters)

Les m√©thodes d'acc√®s permettent d'ajouter de la logique √† l'acc√®s aux propri√©t√©s :

```pascal
type
  TRectangle = class
  private
    FLargeur, FHauteur: Integer;
    function GetSurface: Integer;
    procedure SetLargeur(Value: Integer);
    procedure SetHauteur(Value: Integer);
  public
    property Largeur: Integer read FLargeur write SetLargeur;
    property Hauteur: Integer read FHauteur write SetHauteur;
    property Surface: Integer read GetSurface;  // Propri√©t√© calcul√©e
  end;

implementation

procedure TRectangle.SetLargeur(Value: Integer);
begin
  if Value > 0 then
    FLargeur := Value;
end;

procedure TRectangle.SetHauteur(Value: Integer);
begin
  if Value > 0 then
    FHauteur := Value;
end;

function TRectangle.GetSurface: Integer;
begin
  Result := FLargeur * FHauteur;
end;
```

### Propri√©t√©s calcul√©es

Une propri√©t√© calcul√©e n'a pas de champ associ√©, sa valeur est calcul√©e √† la demande :

```pascal
type
  TPersonne = class
  private
    FPrenom: string;
    FNom: string;
    function GetNomComplet: string;
  public
    property Prenom: string read FPrenom write FPrenom;
    property Nom: string read FNom write FNom;
    property NomComplet: string read GetNomComplet;  // Propri√©t√© calcul√©e
  end;

implementation

function TPersonne.GetNomComplet: string;
begin
  Result := FPrenom + ' ' + FNom;
end;
```

### Propri√©t√©s index√©es

Les propri√©t√©s peuvent avoir un index, ce qui permet de cr√©er des collections accessibles via des propri√©t√©s :

```pascal
type
  TTableau = class
  private
    FValeurs: array[0..9] of Integer;
    function GetValeur(Index: Integer): Integer;
    procedure SetValeur(Index: Integer; Value: Integer);
  public
    property Valeurs[Index: Integer]: Integer read GetValeur write SetValeur;
    property Count: Integer read 10;  // Nombre fixe d'√©l√©ments
  end;

implementation

function TTableau.GetValeur(Index: Integer): Integer;
begin
  if (Index >= 0) and (Index < 10) then
    Result := FValeurs[Index]
  else
    Result := 0;
end;

procedure TTableau.SetValeur(Index: Integer; Value: Integer);
begin
  if (Index >= 0) and (Index < 10) then
    FValeurs[Index] := Value;
end;
```

Utilisation :
```pascal
var
  Tab: TTableau;
begin
  Tab := TTableau.Create;
  try
    Tab.Valeurs[0] := 42;
    Tab.Valeurs[1] := 123;

    ShowMessage(IntToStr(Tab.Valeurs[0]));  // Affiche 42
  finally
    Tab.Free;
  end;
end;
```

### Propri√©t√© par d√©faut

Une classe peut d√©finir une propri√©t√© par d√©faut avec le mot-cl√© `default`. Cette propri√©t√© peut √™tre utilis√©e sans √™tre nomm√©e explicitement :

```pascal
type
  TTableau = class
  private
    FValeurs: array[0..9] of Integer;
    function GetValeur(Index: Integer): Integer;
    procedure SetValeur(Index: Integer; Value: Integer);
  public
    property Valeurs[Index: Integer]: Integer read GetValeur write SetValeur; default;
  end;
```

Utilisation :
```pascal
Tab[0] := 42;      // √âquivalent √† Tab.Valeurs[0] := 42
X := Tab[0];       // √âquivalent √† X := Tab.Valeurs[0]
```

### Attributs de propri√©t√©

Les propri√©t√©s peuvent avoir des attributs suppl√©mentaires qui indiquent comment elles doivent √™tre trait√©es par l'IDE et les outils :

```pascal
type
  TPersonne = class
  published  // Section sp√©ciale pour les propri√©t√©s visibles dans l'inspecteur d'objets
    property Nom: string read FNom write FNom;
    property Age: Integer read FAge write SetAge default 0;
    property Adresse: string read FAdresse write FAdresse stored IsAdresseStored;
    property Telephone: string read FTelephone write FTelephone stored False;
  end;
```

Attributs courants :
- `default` : Valeur par d√©faut
- `stored` : Indique si la propri√©t√© doit √™tre sauvegard√©e (avec True, False ou une fonction)
- `nodefault` : La propri√©t√© n'a pas de valeur par d√©faut

## Organisation des m√©thodes et propri√©t√©s

Une bonne organisation des m√©thodes et propri√©t√©s rend votre classe plus facile √† comprendre et √† utiliser :

```pascal
type
  TClient = class
  private
    // Champs priv√©s
    FNom: string;
    FAdresse: string;
    FSolde: Currency;

    // M√©thodes d'acc√®s priv√©es
    procedure SetSolde(Value: Currency);

  protected
    // M√©thodes accessibles aux classes d√©riv√©es
    procedure CalculerRemise; virtual;

  public
    // Constructeur et destructeur
    constructor Create(const ANom: string);
    destructor Destroy; override;

    // M√©thodes publiques
    procedure Acheter(Montant: Currency);
    procedure Payer(Montant: Currency);
    function ObtenirEtatCompte: string;

    // Propri√©t√©s publiques
    property Nom: string read FNom write FNom;
    property Adresse: string read FAdresse write FAdresse;
    property Solde: Currency read FSolde write SetSolde;
  end;
```

## Conseils pratiques

### 1. Pr√©fixes courants

- Champs priv√©s : pr√©fixe `F` (ex. `FNom`)
- M√©thodes d'acc√®s : pr√©fixes `Get` et `Set` (ex. `GetAge`, `SetAge`)

### 2. R√©utilisation du code

Divisez les op√©rations complexes en plusieurs m√©thodes plus petites et plus sp√©cifiques :

```pascal
// Au lieu de ceci :
procedure TTraitement.TraiterTout;
begin
  // 100 lignes de code faisant tout
end;

// Pr√©f√©rez ceci :
procedure TTraitement.TraiterTout;
begin
  ChargerDonnees;
  ValiderDonnees;
  TransformerDonnees;
  EnregistrerResultats;
end;
```

### 3. Validation dans les setters

Ajoutez toujours des validations dans les m√©thodes de d√©finition des propri√©t√©s :

```pascal
procedure TPersonne.SetAge(Value: Integer);
begin
  if (Value < 0) then
    raise Exception.Create('L''√¢ge ne peut pas √™tre n√©gatif');

  if (Value > 120) then
    raise Exception.Create('L''√¢ge semble trop √©lev√©');

  FAge := Value;
end;
```

### 4. Documentation des propri√©t√©s et m√©thodes

Ajoutez des commentaires pour expliquer le but et le fonctionnement de vos propri√©t√©s et m√©thodes :

```pascal
type
  TCompte = class
  private
    FSolde: Currency;
  public
    { Effectue un d√©p√¥t sur le compte.
      @param Montant Le montant √† d√©poser (doit √™tre positif)
      @return True si l'op√©ration a r√©ussi, False sinon }
    function Deposer(Montant: Currency): Boolean;

    { Effectue un retrait du compte.
      @param Montant Le montant √† retirer (doit √™tre positif)
      @return True si l'op√©ration a r√©ussi, False sinon }
    function Retirer(Montant: Currency): Boolean;

    { Solde actuel du compte en euros }
    property Solde: Currency read FSolde;
  end;
```

## Exemple complet

Voici un exemple complet illustrant l'utilisation des propri√©t√©s et m√©thodes dans une classe :

```pascal
unit CompteBancaire;

interface

type
  TTypeCompte = (tcCourant, tcEpargne, tcProfessionnel);

  TCompteBancaire = class
  private
    FNumero: string;
    FTitulaire: string;
    FSolde: Currency;
    FTypeCompte: TTypeCompte;
    FDateCreation: TDateTime;
    FDecouvertAutorise: Currency;

    function GetAge: Integer;
    procedure SetSolde(const Value: Currency);
    procedure SetDecouvertAutorise(const Value: Currency);
  public
    constructor Create(const ANumero, ATitulaire: string; ATypeCompte: TTypeCompte);
    destructor Destroy; override;

    function Deposer(Montant: Currency): Boolean;
    function Retirer(Montant: Currency): Boolean;
    function CalculerInterets(TauxAnnuel: Double): Currency;
    function ToString: string; override;

    property Numero: string read FNumero;
    property Titulaire: string read FTitulaire write FTitulaire;
    property Solde: Currency read FSolde write SetSolde;
    property TypeCompte: TTypeCompte read FTypeCompte;
    property DateCreation: TDateTime read FDateCreation;
    property Age: Integer read GetAge;
    property DecouvertAutorise: Currency read FDecouvertAutorise write SetDecouvertAutorise;
  end;

implementation

uses
  System.SysUtils, System.DateUtils;

{ TCompteBancaire }

function TCompteBancaire.CalculerInterets(TauxAnnuel: Double): Currency;
begin
  // Calcul simplifi√© des int√©r√™ts
  if TypeCompte = tcEpargne then
    Result := FSolde * (TauxAnnuel / 100)
  else
    Result := 0;
end;

constructor TCompteBancaire.Create(const ANumero, ATitulaire: string; ATypeCompte: TTypeCompte);
begin
  inherited Create;
  FNumero := ANumero;
  FTitulaire := ATitulaire;
  FTypeCompte := ATypeCompte;
  FSolde := 0;
  FDateCreation := Now;

  // D√©finir le d√©couvert autoris√© selon le type de compte
  case FTypeCompte of
    tcCourant: FDecouvertAutorise := 500;
    tcProfessionnel: FDecouvertAutorise := 2000;
    else FDecouvertAutorise := 0;
  end;
end;

destructor TCompteBancaire.Destroy;
begin
  // Rien de sp√©cial √† faire ici, mais bonne pratique
  // d'avoir un destructeur pour les classes complexes
  inherited;
end;

function TCompteBancaire.Deposer(Montant: Currency): Boolean;
begin
  Result := False;

  if Montant <= 0 then
    Exit;

  FSolde := FSolde + Montant;
  Result := True;
end;

function TCompteBancaire.GetAge: Integer;
begin
  Result := YearsBetween(Now, FDateCreation);
end;

function TCompteBancaire.Retirer(Montant: Currency): Boolean;
begin
  Result := False;

  if Montant <= 0 then
    Exit;

  if (FSolde - Montant) < -FDecouvertAutorise then
    Exit;

  FSolde := FSolde - Montant;
  Result := True;
end;

procedure TCompteBancaire.SetDecouvertAutorise(const Value: Currency);
begin
  if (FTypeCompte = tcEpargne) and (Value > 0) then
    raise Exception.Create('Pas de d√©couvert autoris√© pour les comptes √©pargne');

  if Value < 0 then
    raise Exception.Create('Le d√©couvert autoris√© ne peut pas √™tre n√©gatif');

  FDecouvertAutorise := Value;
end;

procedure TCompteBancaire.SetSolde(const Value: Currency);
begin
  if (Value < -FDecouvertAutorise) then
    raise Exception.Create('Solde insuffisant');

  FSolde := Value;
end;

function TCompteBancaire.ToString: string;
const
  TypeCompteStr: array[TTypeCompte] of string = ('Courant', '√âpargne', 'Professionnel');
begin
  Result := Format('Compte %s n¬∞%s'#13#10'Titulaire: %s'#13#10'Solde: %.2f ‚Ç¨'#13#10'D√©couvert: %.2f ‚Ç¨',
    [TypeCompteStr[FTypeCompte], FNumero, FTitulaire, FSolde, FDecouvertAutorise]);
end;

end.
```

Utilisation :
```pascal
var
  Compte: TCompteBancaire;
begin
  Compte := TCompteBancaire.Create('123456789', 'Jean Dupont', tcCourant);
  try
    Compte.Deposer(1000);

    if Compte.Retirer(200) then
      ShowMessage('Retrait effectu√© avec succ√®s')
    else
      ShowMessage('Retrait impossible');

    ShowMessage(Compte.ToString);

    // Utilisation des propri√©t√©s
    ShowMessage('Age du compte : ' + IntToStr(Compte.Age) + ' ans');

    // Modification d'une propri√©t√© avec validation
    try
      Compte.DecouvertAutorise := 1000;
      ShowMessage('Nouveau d√©couvert autoris√© : ' + CurrToStr(Compte.DecouvertAutorise));
    except
      on E: Exception do
        ShowMessage('Erreur : ' + E.Message);
    end;
  finally
    Compte.Free;
  end;
end;
```

---

Dans cette section, nous avons explor√© en d√©tail les m√©thodes et propri√©t√©s, deux concepts fondamentaux de la programmation orient√©e objet en Delphi. Les m√©thodes d√©finissent le comportement de vos objets, tandis que les propri√©t√©s offrent une interface contr√¥l√©e pour acc√©der √† leurs donn√©es. En combinant ces deux √©l√©ments de mani√®re judicieuse, vous pouvez cr√©er des classes bien encapsul√©es, faciles √† utiliser et maintenables.

Dans la prochaine section, nous explorerons l'h√©ritage et le polymorphisme, qui vous permettront d'exploiter au maximum la r√©utilisation de code et la flexibilit√© offertes par la programmation orient√©e objet.

‚è≠Ô∏è [H√©ritage et polymorphisme](/03-langage-object-pascal/07.3-heritage-polymorphisme.md)

