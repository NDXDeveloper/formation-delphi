üîù Retour au [Sommaire](/SOMMAIRE.md)

# 3.7.2 Propri√©t√©s et m√©thodes en Object Pascal

## Introduction

Dans la partie pr√©c√©dente, nous avons d√©couvert les classes et objets. Maintenant, nous allons approfondir deux concepts essentiels : les **propri√©t√©s** et les **m√©thodes**. Ces √©l√©ments permettent de d√©finir ce que nos objets peuvent faire (m√©thodes) et comment on acc√®de √† leurs donn√©es (propri√©t√©s).

## Les m√©thodes

### Qu'est-ce qu'une m√©thode ?

Une **m√©thode** est une fonction ou une proc√©dure qui appartient √† une classe. C'est une action que l'objet peut effectuer. Les m√©thodes d√©finissent le **comportement** de l'objet.

### Types de m√©thodes

Il existe deux types principaux de m√©thodes :

#### 1. Les proc√©dures (procedures)

Une proc√©dure est une m√©thode qui effectue une action mais ne retourne pas de valeur.

```pascal
type
  TVoiture = class
  private
    FVitesse: Integer;
  public
    procedure Accelerer;
    procedure Freiner;
  end;

procedure TVoiture.Accelerer;
begin
  FVitesse := FVitesse + 10;
  ShowMessage('Acc√©l√©ration ! Vitesse : ' + IntToStr(FVitesse) + ' km/h');
end;

procedure TVoiture.Freiner;
begin
  if FVitesse > 0 then
    FVitesse := FVitesse - 10;
  ShowMessage('Freinage ! Vitesse : ' + IntToStr(FVitesse) + ' km/h');
end;
```

#### 2. Les fonctions (functions)

Une fonction est une m√©thode qui effectue une action et **retourne une valeur**.

```pascal
type
  TVoiture = class
  private
    FVitesse: Integer;
    FMarque: string;
  public
    function ObtenirVitesse: Integer;
    function EstALArret: Boolean;
    function ObtenirDescription: string;
  end;

function TVoiture.ObtenirVitesse: Integer;
begin
  Result := FVitesse;
end;

function TVoiture.EstALArret: Boolean;
begin
  Result := (FVitesse = 0);
end;

function TVoiture.ObtenirDescription: string;
begin
  Result := Format('Voiture %s roulant √† %d km/h', [FMarque, FVitesse]);
end;
```

### M√©thodes avec param√®tres

Les m√©thodes peuvent accepter des param√®tres pour modifier leur comportement :

```pascal
type
  TCalculatrice = class
  public
    function Additionner(A, B: Integer): Integer;
    function Multiplier(A, B: Double): Double;
    procedure AfficherResultat(Valeur: Double; Operation: string);
  end;

function TCalculatrice.Additionner(A, B: Integer): Integer;
begin
  Result := A + B;
end;

function TCalculatrice.Multiplier(A, B: Double): Double;
begin
  Result := A * B;
end;

procedure TCalculatrice.AfficherResultat(Valeur: Double; Operation: string);
begin
  ShowMessage(Format('R√©sultat de %s : %.2f', [Operation, Valeur]));
end;
```

### Utilisation des m√©thodes

```pascal
var
  MaVoiture: TVoiture;
  Calc: TCalculatrice;
begin
  MaVoiture := TVoiture.Create;
  try
    MaVoiture.Accelerer;  // Appel d'une proc√©dure
    MaVoiture.Accelerer;

    if MaVoiture.EstALArret then  // Appel d'une fonction
      ShowMessage('La voiture est arr√™t√©e')
    else
      ShowMessage('Vitesse : ' + IntToStr(MaVoiture.ObtenirVitesse));
  finally
    MaVoiture.Free;
  end;

  Calc := TCalculatrice.Create;
  try
    Calc.AfficherResultat(Calc.Additionner(5, 3), 'addition');
  finally
    Calc.Free;
  end;
end;
```

## Les propri√©t√©s

### Qu'est-ce qu'une propri√©t√© ?

Une **propri√©t√©** est une mani√®re √©l√©gante et contr√¥l√©e d'acc√©der aux champs d'une classe. Les propri√©t√©s agissent comme des champs publics, mais permettent d'ex√©cuter du code lors de la lecture ou de l'√©criture.

### Pourquoi utiliser des propri√©t√©s ?

Au lieu d'exposer directement les champs priv√©s, on utilise des propri√©t√©s pour :
- **Contr√¥ler** les valeurs assign√©es (validation)
- **Calculer** des valeurs dynamiquement
- **D√©clencher** des actions lors de modifications
- **Prot√©ger** l'int√©grit√© des donn√©es

### Syntaxe de base d'une propri√©t√©

```pascal
type
  TPersonne = class
  private
    FNom: string;
    FAge: Integer;
  public
    property Nom: string read FNom write FNom;
    property Age: Integer read FAge write FAge;
  end;
```

Cette syntaxe signifie :
- `property Nom` : d√©clare une propri√©t√© nomm√©e "Nom"
- `read FNom` : quand on lit la propri√©t√©, on retourne le champ FNom
- `write FNom` : quand on √©crit dans la propri√©t√©, on modifie le champ FNom

### Utilisation des propri√©t√©s

```pascal
var
  Personne: TPersonne;
begin
  Personne := TPersonne.Create;
  try
    // √âcriture (write)
    Personne.Nom := 'Marie Dubois';
    Personne.Age := 30;

    // Lecture (read)
    ShowMessage('Nom : ' + Personne.Nom);
    ShowMessage('√Çge : ' + IntToStr(Personne.Age));
  finally
    Personne.Free;
  end;
end;
```

## Propri√©t√©s avec m√©thodes d'acc√®s

Pour avoir plus de contr√¥le, on peut utiliser des m√©thodes sp√©ciales appel√©es **getter** et **setter** :

```pascal
type
  TCompteBancaire = class
  private
    FTitulaire: string;
    FSolde: Double;
    procedure SetSolde(const Value: Double);
    function GetSoldeFormate: string;
  public
    property Titulaire: string read FTitulaire write FTitulaire;
    property Solde: Double read FSolde write SetSolde;
    property SoldeFormate: string read GetSoldeFormate;
  end;

// Setter : contr√¥le lors de l'√©criture
procedure TCompteBancaire.SetSolde(const Value: Double);
begin
  if Value < 0 then
    raise Exception.Create('Le solde ne peut pas √™tre n√©gatif')
  else
    FSolde := Value;
end;

// Getter : calcul lors de la lecture
function TCompteBancaire.GetSoldeFormate: string;
begin
  Result := FormatFloat('#,##0.00 ‚Ç¨', FSolde);
end;
```

### Utilisation

```pascal
var
  Compte: TCompteBancaire;
begin
  Compte := TCompteBancaire.Create;
  try
    Compte.Titulaire := 'Jean Martin';
    Compte.Solde := 1500.50;  // Appelle SetSolde

    ShowMessage('Solde : ' + Compte.SoldeFormate);  // Appelle GetSoldeFormate

    // Ceci g√©n√®rera une exception
    // Compte.Solde := -100;
  finally
    Compte.Free;
  end;
end;
```

## Propri√©t√©s en lecture seule

Une propri√©t√© peut √™tre en **lecture seule** si on omet la partie `write` :

```pascal
type
  TCercle = class
  private
    FRayon: Double;
    function GetSurface: Double;
    function GetPerimetre: Double;
  public
    property Rayon: Double read FRayon write FRayon;
    property Surface: Double read GetSurface;  // Lecture seule
    property Perimetre: Double read GetPerimetre;  // Lecture seule
  end;

function TCercle.GetSurface: Double;
begin
  Result := Pi * FRayon * FRayon;
end;

function TCercle.GetPerimetre: Double;
begin
  Result := 2 * Pi * FRayon;
end;
```

### Utilisation

```pascal
var
  Cercle: TCercle;
begin
  Cercle := TCercle.Create;
  try
    Cercle.Rayon := 5;

    // Ces propri√©t√©s sont calcul√©es automatiquement
    ShowMessage('Surface : ' + FloatToStr(Cercle.Surface));
    ShowMessage('P√©rim√®tre : ' + FloatToStr(Cercle.Perimetre));

    // Ceci g√©n√©rerait une erreur de compilation
    // Cercle.Surface := 100;  // Erreur : propri√©t√© en lecture seule
  finally
    Cercle.Free;
  end;
end;
```

## Propri√©t√©s en √©criture seule

Plus rare, mais parfois utile pour d√©finir des param√®tres sans pouvoir les relire :

```pascal
type
  TSysteme = class
  private
    procedure SetMotDePasse(const Value: string);
  public
    property MotDePasse: string write SetMotDePasse;  // √âcriture seule
  end;

procedure TSysteme.SetMotDePasse(const Value: string);
begin
  // Stocker le hash du mot de passe, pas le mot de passe lui-m√™me
  // (code simplifi√©)
  ShowMessage('Mot de passe d√©fini avec succ√®s');
end;
```

## Exemple complet : Classe Rectangle

Voici un exemple complet combinant m√©thodes et propri√©t√©s :

```pascal
type
  TRectangle = class
  private
    FLargeur: Double;
    FHauteur: Double;
    procedure SetLargeur(const Value: Double);
    procedure SetHauteur(const Value: Double);
    function GetSurface: Double;
    function GetPerimetre: Double;
  public
    constructor Create(ALargeur, AHauteur: Double);
    procedure Agrandir(Facteur: Double);
    procedure AfficherInfos;
    function EstCarre: Boolean;

    property Largeur: Double read FLargeur write SetLargeur;
    property Hauteur: Double read FHauteur write SetHauteur;
    property Surface: Double read GetSurface;
    property Perimetre: Double read GetPerimetre;
  end;

constructor TRectangle.Create(ALargeur, AHauteur: Double);
begin
  inherited Create;
  SetLargeur(ALargeur);
  SetHauteur(AHauteur);
end;

procedure TRectangle.SetLargeur(const Value: Double);
begin
  if Value <= 0 then
    raise Exception.Create('La largeur doit √™tre positive')
  else
    FLargeur := Value;
end;

procedure TRectangle.SetHauteur(const Value: Double);
begin
  if Value <= 0 then
    raise Exception.Create('La hauteur doit √™tre positive')
  else
    FHauteur := Value;
end;

function TRectangle.GetSurface: Double;
begin
  Result := FLargeur * FHauteur;
end;

function TRectangle.GetPerimetre: Double;
begin
  Result := 2 * (FLargeur + FHauteur);
end;

procedure TRectangle.Agrandir(Facteur: Double);
begin
  FLargeur := FLargeur * Facteur;
  FHauteur := FHauteur * Facteur;
end;

function TRectangle.EstCarre: Boolean;
begin
  Result := (FLargeur = FHauteur);
end;

procedure TRectangle.AfficherInfos;
var
  Info: string;
begin
  Info := Format('Rectangle : %.2f x %.2f'#13#10 +
                 'Surface : %.2f'#13#10 +
                 'P√©rim√®tre : %.2f',
                 [FLargeur, FHauteur, Surface, Perimetre]);

  if EstCarre then
    Info := Info + #13#10 + 'C''est un carr√© !';

  ShowMessage(Info);
end;
```

### Utilisation de la classe Rectangle

```pascal
var
  MonRectangle: TRectangle;
begin
  MonRectangle := TRectangle.Create(5, 3);
  try
    MonRectangle.AfficherInfos;

    // Modifier via les propri√©t√©s
    MonRectangle.Largeur := 4;
    MonRectangle.Hauteur := 4;

    MonRectangle.AfficherInfos;

    // Utiliser une m√©thode
    MonRectangle.Agrandir(2);
    MonRectangle.AfficherInfos;

  finally
    MonRectangle.Free;
  end;
end;
```

## Diff√©rence entre champs, propri√©t√©s et m√©thodes

| √âl√©ment | Description | Exemple |
|---------|-------------|---------|
| **Champ** | Variable stockant une donn√©e | `FNom: string;` |
| **Propri√©t√©** | Interface contr√¥l√©e pour acc√©der √† un champ | `property Nom: string read FNom write FNom;` |
| **M√©thode** | Action que l'objet peut effectuer | `procedure SePresenter;` |

### Quand utiliser quoi ?

- **Champs priv√©s** : pour stocker les donn√©es internes
- **Propri√©t√©s** : pour exposer les donn√©es de mani√®re contr√¥l√©e
- **M√©thodes** : pour d√©finir des actions ou des calculs

## Conventions de nommage

### Pour les champs priv√©s
- Pr√©fixe `F` : `FNom`, `FAge`, `FSolde`

### Pour les propri√©t√©s
- Pas de pr√©fixe : `Nom`, `Age`, `Solde`
- M√™me nom que le champ mais sans le `F`

### Pour les m√©thodes d'acc√®s
- Getters : pr√©fixe `Get` : `GetNom`, `GetAge`
- Setters : pr√©fixe `Set` : `SetNom`, `SetAge`

### Pour les m√©thodes publiques
- Verbes d'action : `Calculer`, `Afficher`, `Enregistrer`
- Questions (bool√©ens) : `Est...`, `Peut...`, `A...`

```pascal
type
  TDocument = class
  private
    FTitre: string;
    FModifie: Boolean;
    procedure SetTitre(const Value: string);
  public
    property Titre: string read FTitre write SetTitre;
    property EstModifie: Boolean read FModifie;

    procedure Enregistrer;
    function PeutEtreFerme: Boolean;
    procedure AfficherApercu;
  end;
```

## Bonnes pratiques

1. **Toujours utiliser des propri√©t√©s plut√¥t que des champs publics**
   ```pascal
   // ‚ùå Mauvais
   type
     TPersonne = class
     public
       Nom: string;
       Age: Integer;
     end;

   // ‚úÖ Bon
   type
     TPersonne = class
     private
       FNom: string;
       FAge: Integer;
     public
       property Nom: string read FNom write FNom;
       property Age: Integer read FAge write FAge;
     end;
   ```

2. **Valider les donn√©es dans les setters**
   ```pascal
   procedure TPersonne.SetAge(const Value: Integer);
   begin
     if (Value < 0) or (Value > 150) then
       raise Exception.Create('√Çge invalide')
     else
       FAge := Value;
   end;
   ```

3. **Utiliser des propri√©t√©s en lecture seule pour les valeurs calcul√©es**
   ```pascal
   property Surface: Double read GetSurface;  // Pas de write
   ```

4. **Nommer les m√©thodes avec des verbes d'action**
   ```pascal
   procedure Calculer;
   procedure Afficher;
   function Verifier: Boolean;
   ```

5. **Garder les m√©thodes courtes et focalis√©es**
   - Une m√©thode = une responsabilit√©
   - Si une m√©thode est trop longue, la diviser en plusieurs m√©thodes

## R√©sum√©

- Les **m√©thodes** d√©finissent ce que l'objet peut faire (son comportement)
  - **Proc√©dures** : actions sans valeur de retour
  - **Fonctions** : actions avec valeur de retour

- Les **propri√©t√©s** fournissent un acc√®s contr√¥l√© aux donn√©es de l'objet
  - `read` : d√©finit comment lire la propri√©t√©
  - `write` : d√©finit comment √©crire dans la propri√©t√©
  - Peuvent √™tre en lecture seule, √©criture seule, ou lecture/√©criture

- Les **getters et setters** permettent de contr√¥ler et valider les acc√®s
  - Getter : m√©thode appel√©e lors de la lecture
  - Setter : m√©thode appel√©e lors de l'√©criture

- **Bonnes pratiques** :
  - Champs priv√©s avec pr√©fixe `F`
  - Propri√©t√©s publiques sans pr√©fixe
  - Validation dans les setters
  - M√©thodes avec des noms descriptifs

Ma√Ætriser les propri√©t√©s et m√©thodes est essentiel pour cr√©er des classes robustes et maintenables en Delphi. Ces concepts permettent l'encapsulation, un principe fondamental de la programmation orient√©e objet.

‚è≠Ô∏è [H√©ritage et polymorphisme](/03-langage-object-pascal/07.3-heritage-polymorphisme.md)
