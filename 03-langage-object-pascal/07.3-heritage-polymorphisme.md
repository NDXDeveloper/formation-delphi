üîù Retour au [Sommaire](/SOMMAIRE.md)

# 3.7.3 H√©ritage et polymorphisme en Object Pascal

## Introduction

L'**h√©ritage** et le **polymorphisme** sont deux concepts fondamentaux de la programmation orient√©e objet. Ils permettent de cr√©er des hi√©rarchies de classes, de r√©utiliser du code et de cr√©er des programmes plus flexibles et maintenables.

## L'h√©ritage

### Qu'est-ce que l'h√©ritage ?

L'**h√©ritage** est un m√©canisme qui permet √† une classe (appel√©e **classe d√©riv√©e** ou **classe fille**) de r√©cup√©rer automatiquement les propri√©t√©s et m√©thodes d'une autre classe (appel√©e **classe de base** ou **classe parent**).

### Analogie du monde r√©el

Imaginez la classification des v√©hicules :
- Tous les v√©hicules ont des roues, un moteur, peuvent d√©marrer et s'arr√™ter
- Une voiture est un v√©hicule (elle h√©rite de ces caract√©ristiques)
- Un camion est aussi un v√©hicule (il h√©rite aussi de ces caract√©ristiques)
- Mais une voiture et un camion ont aussi leurs propres sp√©cificit√©s

### Syntaxe de l'h√©ritage

```pascal
type
  // Classe de base
  TVehicule = class
  private
    FMarque: string;
    FVitesse: Integer;
  public
    procedure Demarrer;
    procedure Arreter;
    property Marque: string read FMarque write FMarque;
    property Vitesse: Integer read FVitesse;
  end;

  // Classe d√©riv√©e
  TVoiture = class(TVehicule)  // TVoiture h√©rite de TVehicule
  private
    FNombrePortes: Integer;
  public
    procedure Klaxonner;
    property NombrePortes: Integer read FNombrePortes write FNombrePortes;
  end;
```

La syntaxe `class(TVehicule)` indique que `TVoiture` h√©rite de `TVehicule`.

### Impl√©mentation

```pascal
procedure TVehicule.Demarrer;
begin
  ShowMessage('Le v√©hicule ' + FMarque + ' d√©marre');
  FVitesse := 0;
end;

procedure TVehicule.Arreter;
begin
  FVitesse := 0;
  ShowMessage('Le v√©hicule s''arr√™te');
end;

procedure TVoiture.Klaxonner;
begin
  ShowMessage('Bip bip !');
end;
```

### Utilisation de l'h√©ritage

```pascal
var
  MaVoiture: TVoiture;
begin
  MaVoiture := TVoiture.Create;
  try
    // Propri√©t√©s h√©rit√©es de TVehicule
    MaVoiture.Marque := 'Peugeot';

    // Propri√©t√© propre √† TVoiture
    MaVoiture.NombrePortes := 5;

    // M√©thodes h√©rit√©es de TVehicule
    MaVoiture.Demarrer;
    MaVoiture.Arreter;

    // M√©thode propre √† TVoiture
    MaVoiture.Klaxonner;
  finally
    MaVoiture.Free;
  end;
end;
```

### Avantages de l'h√©ritage

1. **R√©utilisation du code** : pas besoin de r√©√©crire le code commun
2. **Organisation logique** : structure hi√©rarchique claire
3. **Maintenance facilit√©e** : modifications dans la classe de base b√©n√©ficient √† toutes les classes d√©riv√©es
4. **Extensibilit√©** : facile d'ajouter de nouvelles classes d√©riv√©es

## Hi√©rarchie d'h√©ritage

On peut cr√©er plusieurs niveaux d'h√©ritage :

```pascal
type
  // Niveau 1 : Classe de base
  TAnimal = class
  private
    FNom: string;
    FAge: Integer;
  public
    procedure SeNourrir;
    property Nom: string read FNom write FNom;
    property Age: Integer read FAge write FAge;
  end;

  // Niveau 2 : Classe d√©riv√©e de TAnimal
  TMammifere = class(TAnimal)
  private
    FTypePoil: string;
  public
    procedure Allaiter;
    property TypePoil: string read FTypePoil write FTypePoil;
  end;

  // Niveau 3 : Classe d√©riv√©e de TMammifere
  TChien = class(TMammifere)
  private
    FRace: string;
  public
    procedure Aboyer;
    property Race: string read FRace write FRace;
  end;

  // Niveau 3 : Autre classe d√©riv√©e de TMammifere
  TChat = class(TMammifere)
  public
    procedure Miauler;
  end;
```

Dans cet exemple :
- `TChien` h√©rite de `TMammifere` qui h√©rite de `TAnimal`
- `TChien` a acc√®s √† toutes les propri√©t√©s et m√©thodes de `TMammifere` et `TAnimal`
- `TChat` et `TChien` partagent les caract√©ristiques communes de `TMammifere`

## Le mot-cl√© inherited

Le mot-cl√© `inherited` permet d'appeler la m√©thode de la classe parent :

```pascal
type
  TVehicule = class
  public
    constructor Create;
    procedure Demarrer; virtual;
  end;

  TVoiture = class(TVehicule)
  public
    constructor Create;
    procedure Demarrer; override;
  end;

constructor TVehicule.Create;
begin
  inherited Create;  // Appelle le constructeur de TObject
  ShowMessage('Cr√©ation d''un v√©hicule');
end;

constructor TVoiture.Create;
begin
  inherited Create;  // Appelle le constructeur de TVehicule
  ShowMessage('Cr√©ation d''une voiture');
end;

procedure TVehicule.Demarrer;
begin
  ShowMessage('Le v√©hicule d√©marre');
end;

procedure TVoiture.Demarrer;
begin
  inherited Demarrer;  // Appelle d'abord la m√©thode de TVehicule
  ShowMessage('Mise en route du syst√®me de la voiture');
end;
```

## Le polymorphisme

### Qu'est-ce que le polymorphisme ?

Le **polymorphisme** (du grec "plusieurs formes") est la capacit√© d'un objet √† prendre plusieurs formes. En programmation, cela signifie qu'une variable de type classe parent peut contenir un objet de n'importe quelle classe d√©riv√©e.

### M√©thodes virtuelles

Pour activer le polymorphisme, on utilise les mots-cl√©s `virtual` et `override` :

```pascal
type
  TAnimal = class
  public
    procedure EmettreSon; virtual;  // M√©thode virtuelle
  end;

  TChien = class(TAnimal)
  public
    procedure EmettreSon; override;  // Red√©finition
  end;

  TChat = class(TAnimal)
  public
    procedure EmettreSon; override;  // Red√©finition
  end;

  TVache = class(TAnimal)
  public
    procedure EmettreSon; override;  // Red√©finition
  end;

// Impl√©mentation

procedure TAnimal.EmettreSon;
begin
  ShowMessage('L''animal fait un son');
end;

procedure TChien.EmettreSon;
begin
  ShowMessage('Wouf wouf !');
end;

procedure TChat.EmettreSon;
begin
  ShowMessage('Miaou !');
end;

procedure TVache.EmettreSon;
begin
  ShowMessage('Meuh !');
end;
```

### Utilisation du polymorphisme

Voici la magie du polymorphisme :

```pascal
procedure FaireCrier(UnAnimal: TAnimal);
begin
  // La m√©thode appel√©e d√©pend du type r√©el de l'objet
  UnAnimal.EmettreSon;
end;

var
  MonChien: TChien;
  MonChat: TChat;
  MaVache: TVache;
begin
  MonChien := TChien.Create;
  MonChat := TChat.Create;
  MaVache := TVache.Create;
  try
    // M√™me proc√©dure, comportements diff√©rents !
    FaireCrier(MonChien);  // Affiche "Wouf wouf !"
    FaireCrier(MonChat);   // Affiche "Miaou !"
    FaireCrier(MaVache);   // Affiche "Meuh !"
  finally
    MonChien.Free;
    MonChat.Free;
    MaVache.Free;
  end;
end;
```

### Exemple avec une liste d'animaux

Le polymorphisme brille vraiment quand on traite des collections :

```pascal
var
  Animaux: TList<TAnimal>;
  Animal: TAnimal;
begin
  Animaux := TList<TAnimal>.Create;
  try
    // Ajouter diff√©rents types d'animaux
    Animaux.Add(TChien.Create);
    Animaux.Add(TChat.Create);
    Animaux.Add(TVache.Create);
    Animaux.Add(TChien.Create);

    // Faire crier tous les animaux
    for Animal in Animaux do
      Animal.EmettreSon;  // Chaque animal fait son propre son !

  finally
    // Lib√©rer tous les animaux
    for Animal in Animaux do
      Animal.Free;
    Animaux.Free;
  end;
end;
```

## M√©thodes abstraites

Une m√©thode **abstraite** est une m√©thode qui DOIT √™tre red√©finie dans les classes d√©riv√©es. Elle n'a pas d'impl√©mentation dans la classe de base.

```pascal
type
  TForme = class
  protected
    FCouleur: string;
  public
    function CalculerSurface: Double; virtual; abstract;
    function CalculerPerimetre: Double; virtual; abstract;
    procedure Dessiner; virtual; abstract;
    property Couleur: string read FCouleur write FCouleur;
  end;

  TRectangle = class(TForme)
  private
    FLargeur: Double;
    FHauteur: Double;
  public
    constructor Create(ALargeur, AHauteur: Double);
    function CalculerSurface: Double; override;
    function CalculerPerimetre: Double; override;
    procedure Dessiner; override;
    property Largeur: Double read FLargeur write FLargeur;
    property Hauteur: Double read FHauteur write FHauteur;
  end;

  TCercle = class(TForme)
  private
    FRayon: Double;
  public
    constructor Create(ARayon: Double);
    function CalculerSurface: Double; override;
    function CalculerPerimetre: Double; override;
    procedure Dessiner; override;
    property Rayon: Double read FRayon write FRayon;
  end;

// Impl√©mentation TRectangle

constructor TRectangle.Create(ALargeur, AHauteur: Double);
begin
  inherited Create;
  FLargeur := ALargeur;
  FHauteur := AHauteur;
end;

function TRectangle.CalculerSurface: Double;
begin
  Result := FLargeur * FHauteur;
end;

function TRectangle.CalculerPerimetre: Double;
begin
  Result := 2 * (FLargeur + FHauteur);
end;

procedure TRectangle.Dessiner;
begin
  ShowMessage(Format('Rectangle %s : %.2f x %.2f', [FCouleur, FLargeur, FHauteur]));
end;

// Impl√©mentation TCercle

constructor TCercle.Create(ARayon: Double);
begin
  inherited Create;
  FRayon := ARayon;
end;

function TCercle.CalculerSurface: Double;
begin
  Result := Pi * FRayon * FRayon;
end;

function TCercle.CalculerPerimetre: Double;
begin
  Result := 2 * Pi * FRayon;
end;

procedure TCercle.Dessiner;
begin
  ShowMessage(Format('Cercle %s de rayon %.2f', [FCouleur, FRayon]));
end;
```

### Utilisation des classes abstraites

```pascal
procedure AfficherInfosForme(Forme: TForme);
begin
  Forme.Dessiner;
  ShowMessage(Format('Surface : %.2f', [Forme.CalculerSurface]));
  ShowMessage(Format('P√©rim√®tre : %.2f', [Forme.CalculerPerimetre]));
end;

var
  Rectangle: TRectangle;
  Cercle: TCercle;
begin
  Rectangle := TRectangle.Create(5, 3);
  try
    Rectangle.Couleur := 'bleu';
    AfficherInfosForme(Rectangle);
  finally
    Rectangle.Free;
  end;

  Cercle := TCercle.Create(4);
  try
    Cercle.Couleur := 'rouge';
    AfficherInfosForme(Cercle);
  finally
    Cercle.Free;
  end;
end;
```

## Diff√©rence entre virtual, override et reintroduce

### Virtual
D√©clare qu'une m√©thode peut √™tre red√©finie dans les classes d√©riv√©es.

```pascal
type
  TBase = class
    procedure MaMethode; virtual;
  end;
```

### Override
Red√©finit une m√©thode virtuelle de la classe parent.

```pascal
type
  TDerivee = class(TBase)
    procedure MaMethode; override;
  end;
```

### Reintroduce
Masque une m√©thode du parent au lieu de la red√©finir (pas de polymorphisme).

```pascal
type
  TDerivee = class(TBase)
    procedure MaMethode; reintroduce;  // Cache la m√©thode du parent
  end;
```

**Attention** : `reintroduce` brise le polymorphisme. Pr√©f√©rez toujours `override` quand c'est possible.

## Le mot-cl√© sealed

Le mot-cl√© `sealed` emp√™che qu'une m√©thode soit red√©finie dans les classes d√©riv√©es :

```pascal
type
  TBase = class
    procedure MaMethode; virtual;
  end;

  TDerivee = class(TBase)
    procedure MaMethode; override; sealed;  // Ne peut plus √™tre red√©finie
  end;

  TNiveauSuivant = class(TDerivee)
    // Erreur de compilation si on essaie de red√©finir MaMethode
  end;
```

## Exemple complet : Syst√®me de paiement

Voici un exemple complet illustrant h√©ritage et polymorphisme :

```pascal
type
  // Classe de base abstraite
  TMethodePaiement = class
  protected
    FMontant: Double;
  public
    constructor Create(AMontant: Double);
    function Traiter: Boolean; virtual; abstract;
    function ObtenirDescription: string; virtual; abstract;
    property Montant: Double read FMontant;
  end;

  // Classe d√©riv√©e : Carte de cr√©dit
  TCartCredit = class(TMethodePaiement)
  private
    FNumeroCarte: string;
    FNomTitulaire: string;
  public
    constructor Create(AMontant: Double; ANumero, ANom: string);
    function Traiter: Boolean; override;
    function ObtenirDescription: string; override;
  end;

  // Classe d√©riv√©e : PayPal
  TPayPal = class(TMethodePaiement)
  private
    FEmail: string;
  public
    constructor Create(AMontant: Double; AEmail: string);
    function Traiter: Boolean; override;
    function ObtenirDescription: string; override;
  end;

  // Classe d√©riv√©e : Virement bancaire
  TVirement = class(TMethodePaiement)
  private
    FIBAN: string;
  public
    constructor Create(AMontant: Double; AIBAN: string);
    function Traiter: Boolean; override;
    function ObtenirDescription: string; override;
  end;

// Impl√©mentation TMethodePaiement

constructor TMethodePaiement.Create(AMontant: Double);
begin
  inherited Create;
  FMontant := AMontant;
end;

// Impl√©mentation TCartCredit

constructor TCartCredit.Create(AMontant: Double; ANumero, ANom: string);
begin
  inherited Create(AMontant);
  FNumeroCarte := ANumero;
  FNomTitulaire := ANom;
end;

function TCartCredit.Traiter: Boolean;
begin
  // Simulation du traitement
  ShowMessage('Traitement du paiement par carte de cr√©dit...');
  Result := True;
end;

function TCartCredit.ObtenirDescription: string;
begin
  Result := Format('Carte de cr√©dit %s - %.2f ‚Ç¨',
                   [FNomTitulaire, FMontant]);
end;

// Impl√©mentation TPayPal

constructor TPayPal.Create(AMontant: Double; AEmail: string);
begin
  inherited Create(AMontant);
  FEmail := AEmail;
end;

function TPayPal.Traiter: Boolean;
begin
  ShowMessage('Traitement du paiement PayPal...');
  Result := True;
end;

function TPayPal.ObtenirDescription: string;
begin
  Result := Format('PayPal (%s) - %.2f ‚Ç¨', [FEmail, FMontant]);
end;

// Impl√©mentation TVirement

constructor TVirement.Create(AMontant: Double; AIBAN: string);
begin
  inherited Create(AMontant);
  FIBAN := AIBAN;
end;

function TVirement.Traiter: Boolean;
begin
  ShowMessage('Traitement du virement bancaire...');
  Result := True;
end;

function TVirement.ObtenirDescription: string;
begin
  Result := Format('Virement bancaire - %.2f ‚Ç¨', [FMontant]);
end;
```

### Utilisation du syst√®me de paiement

```pascal
procedure EffectuerPaiement(Paiement: TMethodePaiement);
begin
  ShowMessage('Paiement : ' + Paiement.ObtenirDescription);

  if Paiement.Traiter then
    ShowMessage('Paiement r√©ussi !')
  else
    ShowMessage('√âchec du paiement');
end;

var
  Carte: TCartCredit;
  PayPal: TPayPal;
  Virement: TVirement;
  Paiements: TList<TMethodePaiement>;
  Paiement: TMethodePaiement;
begin
  Paiements := TList<TMethodePaiement>.Create;
  try
    // Cr√©er diff√©rents modes de paiement
    Paiements.Add(TCartCredit.Create(150.50, '1234-5678-9012-3456', 'Jean Dupont'));
    Paiements.Add(TPayPal.Create(75.00, 'jean@example.com'));
    Paiements.Add(TVirement.Create(200.00, 'FR76 1234 5678 9012 3456 7890 123'));

    // Traiter tous les paiements (polymorphisme en action)
    for Paiement in Paiements do
      EffectuerPaiement(Paiement);

  finally
    // Lib√©rer les objets
    for Paiement in Paiements do
      Paiement.Free;
    Paiements.Free;
  end;
end;
```

## Type casting et v√©rification de type

### L'op√©rateur is

V√©rifie si un objet est d'un type sp√©cifique :

```pascal
var
  Animal: TAnimal;
  Chien: TChien;
begin
  Chien := TChien.Create;
  try
    Animal := Chien;  // Affectation polymorphe

    if Animal is TChien then
      ShowMessage('C''est un chien !');

    if Animal is TChat then
      ShowMessage('C''est un chat');  // Ne s'affichera pas

  finally
    Chien.Free;
  end;
end;
```

### L'op√©rateur as

Convertit un objet vers un type sp√©cifique (g√©n√®re une exception si impossible) :

```pascal
var
  Animal: TAnimal;
  Chien: TChien;
  MonChien: TChien;
begin
  Chien := TChien.Create;
  try
    Animal := Chien;

    // Conversion s√ªre
    if Animal is TChien then
    begin
      MonChien := Animal as TChien;
      MonChien.Aboyer;
    end;

  finally
    Chien.Free;
  end;
end;
```

## Bonnes pratiques

1. **Utilisez virtual/override pour le polymorphisme**
   ```pascal
   // ‚úÖ Bon - permet le polymorphisme
   procedure MaMethode; virtual;
   procedure MaMethode; override;
   ```

2. **D√©clarez abstract les m√©thodes sans impl√©mentation logique dans la classe de base**
   ```pascal
   function Calculer: Double; virtual; abstract;
   ```

3. **Utilisez inherited pour appeler la m√©thode du parent**
   ```pascal
   procedure MaMethode; override;
   begin
     inherited MaMethode;  // Appelle le parent
     // Code suppl√©mentaire
   end;
   ```

4. **√âvitez les hi√©rarchies trop profondes**
   - Maximum 3-4 niveaux id√©alement
   - Pr√©f√©rez la composition √† l'h√©ritage quand appropri√©

5. **Utilisez des noms de classe explicites**
   ```pascal
   TAnimal ‚Üí TMammifere ‚Üí TChien  // ‚úÖ Clair
   TBase ‚Üí TDerivee ‚Üí TSuite      // ‚ùå Peu clair
   ```

6. **V√©rifiez toujours le type avant le cast**
   ```pascal
   if Animal is TChien then
     (Animal as TChien).Aboyer;
   ```

## H√©ritage vs Composition

Il est important de savoir quand utiliser l'h√©ritage et quand utiliser la composition :

### Utilisez l'h√©ritage quand
- Il y a une vraie relation "est un" (un chien **est un** animal)
- Vous voulez du polymorphisme
- La classe de base fournit du comportement commun

### Utilisez la composition quand
- Il y a une relation "a un" (une voiture **a un** moteur)
- Vous voulez plus de flexibilit√©
- L'h√©ritage cr√©erait une hi√©rarchie trop complexe

## R√©sum√©

- **L'h√©ritage** permet √† une classe de r√©cup√©rer les propri√©t√©s et m√©thodes d'une autre classe
  - Syntaxe : `class(TClasseParent)`
  - Mot-cl√© `inherited` pour appeler la m√©thode parent

- **Le polymorphisme** permet √† un objet de prendre plusieurs formes
  - Utilisez `virtual` dans la classe de base
  - Utilisez `override` dans les classes d√©riv√©es
  - Permet de traiter des objets diff√©rents de mani√®re uniforme

- **M√©thodes abstraites** (`abstract`)
  - N'ont pas d'impl√©mentation dans la classe de base
  - Doivent √™tre impl√©ment√©es dans les classes d√©riv√©es

- **Op√©rateurs de type**
  - `is` : v√©rifie le type
  - `as` : convertit vers un type (cast)

- **Avantages**
  - R√©utilisation du code
  - Organisation logique
  - Flexibilit√© et extensibilit√©
  - Facilite la maintenance

L'h√©ritage et le polymorphisme sont des outils puissants qui, utilis√©s correctement, permettent de cr√©er des architectures logicielles √©l√©gantes et maintenables.

‚è≠Ô∏è [Constructeurs et destructeurs](/03-langage-object-pascal/07.4-constructeurs-destructeurs.md)
