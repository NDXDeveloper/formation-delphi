# 3.7.3 H√©ritage et polymorphisme

üîù Retour √† la [Table des mati√®res](/SOMMAIRE.md)

L'h√©ritage et le polymorphisme sont deux concepts fondamentaux de la programmation orient√©e objet qui permettent de cr√©er des hi√©rarchies de classes flexibles et extensibles. Dans cette section, nous allons explorer ces concepts en Object Pascal et voir comment ils peuvent rendre votre code plus organis√© et r√©utilisable.

## Qu'est-ce que l'h√©ritage ?

L'h√©ritage est un m√©canisme qui permet √† une classe (appel√©e classe d√©riv√©e ou enfant) d'h√©riter des propri√©t√©s et m√©thodes d'une autre classe (appel√©e classe de base ou parent). C'est comme si vous cr√©iez une nouvelle classe qui poss√®de d√©j√† toutes les fonctionnalit√©s de la classe existante, et √† laquelle vous pouvez ajouter des fonctionnalit√©s suppl√©mentaires.

### Pourquoi utiliser l'h√©ritage ?

- **R√©utilisation du code** : √âvitez de r√©√©crire le m√™me code dans plusieurs classes
- **Extension** : Ajoutez de nouvelles fonctionnalit√©s √† des classes existantes
- **Sp√©cialisation** : Cr√©ez des versions plus sp√©cifiques de classes g√©n√©rales
- **Organisation** : Structurez vos classes en hi√©rarchies logiques

## Syntaxe de base de l'h√©ritage

En Object Pascal, l'h√©ritage s'exprime avec le mot-cl√© `(parent)` apr√®s le nom de la classe :

```pascal
type
  TAnimal = class
    // Classe de base
  end;

  TChien = class(TAnimal)
    // Classe d√©riv√©e qui h√©rite de TAnimal
  end;
```

Dans cet exemple, `TChien` h√©rite de tous les champs, propri√©t√©s et m√©thodes de `TAnimal`.

## Exemple simple d'h√©ritage

Voici un exemple concret pour illustrer l'h√©ritage :

```pascal
type
  TVehicule = class
  private
    FMarque: string;
    FModele: string;
    FAnnee: Integer;
  public
    constructor Create(const AMarque, AModele: string; AAnnee: Integer);
    procedure Demarrer; virtual;
    procedure Arreter; virtual;

    property Marque: string read FMarque;
    property Modele: string read FModele;
    property Annee: Integer read FAnnee;
  end;

  TVoiture = class(TVehicule)
  private
    FNombrePortes: Integer;
  public
    constructor Create(const AMarque, AModele: string; AAnnee, ANombrePortes: Integer);
    procedure Demarrer; override;
    procedure Klaxonner;

    property NombrePortes: Integer read FNombrePortes;
  end;
```

Impl√©mentation :

```pascal
{ TVehicule }

constructor TVehicule.Create(const AMarque, AModele: string; AAnnee: Integer);
begin
  inherited Create;  // Appelle le constructeur de la classe parente (TObject)
  FMarque := AMarque;
  FModele := AModele;
  FAnnee := AAnnee;
end;

procedure TVehicule.Demarrer;
begin
  ShowMessage('Le v√©hicule d√©marre');
end;

procedure TVehicule.Arreter;
begin
  ShowMessage('Le v√©hicule s''arr√™te');
end;

{ TVoiture }

constructor TVoiture.Create(const AMarque, AModele: string; AAnnee, ANombrePortes: Integer);
begin
  inherited Create(AMarque, AModele, AAnnee);  // Appelle le constructeur du parent
  FNombrePortes := ANombrePortes;
end;

procedure TVoiture.Demarrer;
begin
  ShowMessage('La voiture d√©marre avec un bruit de moteur');
  // Si on veut aussi ex√©cuter le code du parent :
  // inherited Demarrer;
end;

procedure TVoiture.Klaxonner;
begin
  ShowMessage('Beep beep!');
end;
```

Utilisation :

```pascal
var
  MaVoiture: TVoiture;
begin
  MaVoiture := TVoiture.Create('Renault', 'Clio', 2020, 5);
  try
    // M√©thodes h√©rit√©es
    ShowMessage(MaVoiture.Marque + ' ' + MaVoiture.Modele);  // "Renault Clio"

    // M√©thode red√©finie
    MaVoiture.Demarrer;  // "La voiture d√©marre avec un bruit de moteur"

    // M√©thode sp√©cifique √† TVoiture
    MaVoiture.Klaxonner;  // "Beep beep!"

    // M√©thode h√©rit√©e non red√©finie
    MaVoiture.Arreter;  // "Le v√©hicule s'arr√™te"
  finally
    MaVoiture.Free;
  end;
end;
```

## M√©thodes virtuelles et red√©finition

Pour permettre √† une classe d√©riv√©e de modifier le comportement d'une m√©thode h√©rit√©e, nous utilisons les mots-cl√©s `virtual` et `override` :

- `virtual` dans la classe de base indique qu'une m√©thode peut √™tre red√©finie
- `override` dans la classe d√©riv√©e indique que l'on red√©finit la m√©thode

```pascal
type
  TAnimal = class
  public
    procedure FaireBruit; virtual;  // Peut √™tre red√©finie
  end;

  TChien = class(TAnimal)
  public
    procedure FaireBruit; override;  // Red√©finition
  end;

  TChat = class(TAnimal)
  public
    procedure FaireBruit; override;  // Autre red√©finition
  end;

implementation

procedure TAnimal.FaireBruit;
begin
  ShowMessage('...');
end;

procedure TChien.FaireBruit;
begin
  ShowMessage('Wouf!');
end;

procedure TChat.FaireBruit;
begin
  ShowMessage('Miaou!');
end;
```

### Appel de la m√©thode parente

Dans une m√©thode red√©finie, vous pouvez appeler la version de la classe parente avec le mot-cl√© `inherited` :

```pascal
procedure TChien.FaireBruit;
begin
  inherited FaireBruit;  // Appelle TAnimal.FaireBruit
  ShowMessage('Wouf!');
end;
```

## Hi√©rarchie d'h√©ritage

L'h√©ritage peut s'√©tendre sur plusieurs niveaux pour cr√©er des hi√©rarchies de classes :

```pascal
type
  TAnimal = class
    // Classe de base
  end;

  TMammifere = class(TAnimal)
    // H√©rite de TAnimal
  end;

  TChien = class(TMammifere)
    // H√©rite de TMammifere, qui h√©rite de TAnimal
  end;
```

Une classe d√©riv√©e h√©rite de toutes les classes dans sa cha√Æne d'h√©ritage.

## Type Object et classes

En Object Pascal, toutes les classes d√©rivent automatiquement de `TObject`, m√™me si vous ne le sp√©cifiez pas :

```pascal
type
  TExemple = class  // Implicitement TExemple = class(TObject)
    // ...
  end;
```

`TObject` fournit des m√©thodes de base comme :
- `Create` : Constructeur par d√©faut
- `Free` : Lib√®re l'objet
- `ClassName` : Renvoie le nom de la classe
- `ClassType` : Renvoie le type de la classe
- `InheritsFrom` : V√©rifie si la classe h√©rite d'une autre classe

## H√©ritage simple vs multiple

Object Pascal supporte uniquement l'h√©ritage simple (une classe ne peut h√©riter que d'une seule classe parente). Pour contourner cette limitation et r√©utiliser du code de plusieurs sources, Delphi utilise les interfaces (que nous verrons dans une section ult√©rieure).

## Polymorphisme : qu'est-ce que c'est ?

Le polymorphisme (du grec "plusieurs formes") est la capacit√© d'objets de classes diff√©rentes √† √™tre trait√©s comme des objets d'une classe commune. C'est l'un des concepts les plus puissants de la POO.

Concr√®tement, cela signifie que vous pouvez :
1. R√©f√©rencer un objet d'une classe d√©riv√©e via une variable de la classe de base
2. Appeler des m√©thodes qui se comporteront diff√©remment selon le type r√©el de l'objet

## Polymorphisme en action

Pour illustrer le polymorphisme, reprenons notre exemple avec les animaux :

```pascal
procedure FaireBruitAuxAnimaux;
var
  Animaux: array[0..2] of TAnimal;
  i: Integer;
begin
  // Cr√©ation d'objets de diff√©rentes classes
  Animaux[0] := TAnimal.Create;
  Animaux[1] := TChien.Create;
  Animaux[2] := TChat.Create;

  try
    // Polymorphisme : m√™me appel, comportements diff√©rents
    for i := 0 to 2 do
      Animaux[i].FaireBruit;
      // Affiche "...", puis "Wouf!", puis "Miaou!"
  finally
    // Lib√©ration de la m√©moire
    for i := 0 to 2 do
      Animaux[i].Free;
  end;
end;
```

Dans cet exemple :
1. Nous avons un tableau d'objets `TAnimal`
2. Nous y stockons des objets de types `TAnimal`, `TChien` et `TChat`
3. Nous appelons la m√™me m√©thode `FaireBruit` sur chaque objet
4. Chaque objet ex√©cute sa propre version de la m√©thode

C'est le c≈ìur du polymorphisme : un m√™me code qui produit diff√©rents comportements selon le type r√©el des objets.

## M√©thodes abstraites

Une m√©thode abstraite est d√©clar√©e dans une classe de base mais n'y est pas impl√©ment√©e. Les classes d√©riv√©es doivent fournir leur propre impl√©mentation.

```pascal
type
  TFigure = class
  public
    function CalculerSurface: Double; virtual; abstract;
    function CalculerPerimetre: Double; virtual; abstract;
  end;

  TCercle = class(TFigure)
  private
    FRayon: Double;
  public
    constructor Create(ARayon: Double);
    function CalculerSurface: Double; override;
    function CalculerPerimetre: Double; override;
  end;

  TRectangle = class(TFigure)
  private
    FLargeur, FHauteur: Double;
  public
    constructor Create(ALargeur, AHauteur: Double);
    function CalculerSurface: Double; override;
    function CalculerPerimetre: Double; override;
  end;
```

Impl√©mentation :

```pascal
{ TCercle }

constructor TCercle.Create(ARayon: Double);
begin
  inherited Create;
  FRayon := ARayon;
end;

function TCercle.CalculerSurface: Double;
begin
  Result := Pi * FRayon * FRayon;
end;

function TCercle.CalculerPerimetre: Double;
begin
  Result := 2 * Pi * FRayon;
end;

{ TRectangle }

constructor TRectangle.Create(ALargeur, AHauteur: Double);
begin
  inherited Create;
  FLargeur := ALargeur;
  FHauteur := AHauteur;
end;

function TRectangle.CalculerSurface: Double;
begin
  Result := FLargeur * FHauteur;
end;

function TRectangle.CalculerPerimetre: Double;
begin
  Result := 2 * (FLargeur + FHauteur);
end;
```

Utilisation avec polymorphisme :

```pascal
procedure AfficherInfosFigure(Figure: TFigure);
begin
  ShowMessage('Surface : ' + FloatToStr(Figure.CalculerSurface));
  ShowMessage('P√©rim√®tre : ' + FloatToStr(Figure.CalculerPerimetre));
end;

var
  Cercle: TCercle;
  Rectangle: TRectangle;
begin
  Cercle := TCercle.Create(5);
  Rectangle := TRectangle.Create(4, 6);

  try
    AfficherInfosFigure(Cercle);      // Utilise TCercle.CalculerSurface/Perimetre
    AfficherInfosFigure(Rectangle);   // Utilise TRectangle.CalculerSurface/Perimetre
  finally
    Cercle.Free;
    Rectangle.Free;
  end;
end;
```

## Classes abstraites

Une classe abstraite contient au moins une m√©thode abstraite et ne peut pas √™tre instanci√©e directement. Elle sert de mod√®le pour les classes d√©riv√©es.

```pascal
type
  TFigure = class  // Classe abstraite (contient des m√©thodes abstraites)
  public
    function CalculerSurface: Double; virtual; abstract;
    function CalculerPerimetre: Double; virtual; abstract;
  end;
```

Vous ne pouvez pas cr√©er d'objet `TFigure` directement :

```pascal
var
  Figure: TFigure;
begin
  Figure := TFigure.Create;  // Erreur de compilation!
end;
```

## V√©rification dynamique de type

Parfois, vous avez besoin de conna√Ætre le type r√©el d'un objet pour effectuer des op√©rations sp√©cifiques :

```pascal
procedure TraiterVehicule(Vehicule: TVehicule);
begin
  // Op√©rations communes √† tous les v√©hicules
  Vehicule.Demarrer;

  // Op√©rations sp√©cifiques selon le type
  if Vehicule is TVoiture then
  begin
    ShowMessage('C''est une voiture!');
    TVoiture(Vehicule).Klaxonner;  // Cast explicite
  end
  else if Vehicule is TMoto then
  begin
    ShowMessage('C''est une moto!');
    // Op√©rations sp√©cifiques aux motos
  end;

  Vehicule.Arreter;
end;
```

Deux op√©rateurs importants :
- `is` : v√©rifie si un objet est d'un type sp√©cifique
- `as` : convertit un objet en un autre type (avec v√©rification)

```pascal
if Vehicule is TVoiture then
begin
  // Deux fa√ßons de faire un cast :
  MaVoiture := TVoiture(Vehicule);  // Cast traditionnel (pas de v√©rification)
  // ou
  MaVoiture := Vehicule as TVoiture;  // Cast s√©curis√© (l√®ve une exception si incompatible)

  MaVoiture.Klaxonner;
end;
```

## Visibilit√© et h√©ritage

Rappel sur les niveaux de visibilit√© et leur impact sur l'h√©ritage :

- `private` : Accessible uniquement dans la classe d√©clarante
- `protected` : Accessible dans la classe d√©clarante et ses descendants
- `public` : Accessible partout
- `published` : Comme public, mais avec des fonctionnalit√©s suppl√©mentaires

Pour l'h√©ritage, la distinction `private`/`protected` est cruciale :

```pascal
type
  TParent = class
  private
    FChampPrive: Integer;      // Non accessible aux descendants
  protected
    FChampProtege: Integer;    // Accessible aux descendants
  public
    property ChampPrive: Integer read FChampPrive;
    property ChampProtege: Integer read FChampProtege;
  end;

  TEnfant = class(TParent)
  public
    procedure Exemple;
  end;

procedure TEnfant.Exemple;
begin
  // FChampPrive := 10;    // Erreur! Champ priv√© inaccessible
  FChampProtege := 20;     // OK, champ prot√©g√© accessible
end;
```

## H√©ritage et propri√©t√©s

Les propri√©t√©s peuvent aussi √™tre red√©finies dans les classes d√©riv√©es :

```pascal
type
  TVehicule = class
  private
    FVitesseMax: Integer;
  protected
    function GetDescription: string; virtual;
  public
    property VitesseMax: Integer read FVitesseMax write FVitesseMax;
    property Description: string read GetDescription;
  end;

  TVoiture = class(TVehicule)
  protected
    function GetDescription: string; override;
  end;

function TVehicule.GetDescription: string;
begin
  Result := 'V√©hicule - Vitesse max: ' + IntToStr(FVitesseMax) + ' km/h';
end;

function TVoiture.GetDescription: string;
begin
  Result := 'Voiture - ' + inherited GetDescription;
end;
```

## Exemple complet

Voici un exemple complet illustrant l'h√©ritage et le polymorphisme avec une hi√©rarchie de formes g√©om√©triques :

```pascal
unit FormeGeometrique;

interface

uses
  System.SysUtils, System.Classes;

type
  TFormeGeometrique = class
  private
    FCouleur: string;
  protected
    function GetAire: Double; virtual; abstract;
    function GetPerimetre: Double; virtual; abstract;
  public
    constructor Create(const ACouleur: string);
    function Dessiner: string; virtual;
    function Description: string; virtual;

    property Couleur: string read FCouleur write FCouleur;
    property Aire: Double read GetAire;
    property Perimetre: Double read GetPerimetre;
  end;

  TRectangle = class(TFormeGeometrique)
  private
    FLargeur: Double;
    FHauteur: Double;
  protected
    function GetAire: Double; override;
    function GetPerimetre: Double; override;
  public
    constructor Create(const ACouleur: string; ALargeur, AHauteur: Double);
    function Dessiner: string; override;
    function Description: string; override;

    property Largeur: Double read FLargeur write FLargeur;
    property Hauteur: Double read FHauteur write FHauteur;
  end;

  TCercle = class(TFormeGeometrique)
  private
    FRayon: Double;
  protected
    function GetAire: Double; override;
    function GetPerimetre: Double; override;
  public
    constructor Create(const ACouleur: string; ARayon: Double);
    function Dessiner: string; override;
    function Description: string; override;

    property Rayon: Double read FRayon write FRayon;
  end;

  TTriangle = class(TFormeGeometrique)
  private
    FCoteA: Double;
    FCoteB: Double;
    FCoteC: Double;
  protected
    function GetAire: Double; override;
    function GetPerimetre: Double; override;
  public
    constructor Create(const ACouleur: string; ACoteA, ACoteB, ACoteC: Double);
    function Dessiner: string; override;
    function Description: string; override;

    property CoteA: Double read FCoteA write FCoteA;
    property CoteB: Double read FCoteB write FCoteB;
    property CoteC: Double read FCoteC write FCoteC;
  end;

implementation

{ TFormeGeometrique }

constructor TFormeGeometrique.Create(const ACouleur: string);
begin
  inherited Create;
  FCouleur := ACouleur;
end;

function TFormeGeometrique.Description: string;
begin
  Result := 'Forme g√©om√©trique de couleur ' + FCouleur;
end;

function TFormeGeometrique.Dessiner: string;
begin
  Result := 'Dessin d''une forme';
end;

{ TRectangle }

constructor TRectangle.Create(const ACouleur: string; ALargeur, AHauteur: Double);
begin
  inherited Create(ACouleur);
  FLargeur := ALargeur;
  FHauteur := AHauteur;
end;

function TRectangle.Description: string;
begin
  Result := Format('Rectangle %s de dimensions %.2f x %.2f',
                  [Couleur, FLargeur, FHauteur]);
end;

function TRectangle.Dessiner: string;
begin
  Result := 'Dessin d''un rectangle ' + Couleur;
end;

function TRectangle.GetAire: Double;
begin
  Result := FLargeur * FHauteur;
end;

function TRectangle.GetPerimetre: Double;
begin
  Result := 2 * (FLargeur + FHauteur);
end;

{ TCercle }

constructor TCercle.Create(const ACouleur: string; ARayon: Double);
begin
  inherited Create(ACouleur);
  FRayon := ARayon;
end;

function TCercle.Description: string;
begin
  Result := Format('Cercle %s de rayon %.2f', [Couleur, FRayon]);
end;

function TCercle.Dessiner: string;
begin
  Result := 'Dessin d''un cercle ' + Couleur;
end;

function TCercle.GetAire: Double;
begin
  Result := Pi * FRayon * FRayon;
end;

function TCercle.GetPerimetre: Double;
begin
  Result := 2 * Pi * FRayon;
end;

{ TTriangle }

constructor TTriangle.Create(const ACouleur: string; ACoteA, ACoteB, ACoteC: Double);
begin
  inherited Create(ACouleur);
  FCoteA := ACoteA;
  FCoteB := ACoteB;
  FCoteC := ACoteC;
end;

function TTriangle.Description: string;
begin
  Result := Format('Triangle %s de c√¥t√©s %.2f, %.2f et %.2f',
                  [Couleur, FCoteA, FCoteB, FCoteC]);
end;

function TTriangle.Dessiner: string;
begin
  Result := 'Dessin d''un triangle ' + Couleur;
end;

function TTriangle.GetAire: Double;
var
  S: Double;
begin
  // Formule de H√©ron
  S := (FCoteA + FCoteB + FCoteC) / 2;
  Result := Sqrt(S * (S - FCoteA) * (S - FCoteB) * (S - FCoteC));
end;

function TTriangle.GetPerimetre: Double;
begin
  Result := FCoteA + FCoteB + FCoteC;
end;

end.
```

Utilisation avec polymorphisme :

```pascal
procedure DemonstrationPolymorphisme;
var
  Formes: array[0..2] of TFormeGeometrique;
  i: Integer;
  TotalAire: Double;
begin
  // Cr√©ation d'objets de diff√©rentes classes
  Formes[0] := TRectangle.Create('Rouge', 5, 3);
  Formes[1] := TCercle.Create('Bleu', 4);
  Formes[2] := TTriangle.Create('Vert', 3, 4, 5);

  try
    // Affichage polymorphique
    for i := 0 to 2 do
    begin
      ShowMessage(Formes[i].Description);
      ShowMessage(Formes[i].Dessiner);
      ShowMessage('Aire: ' + FloatToStr(Formes[i].Aire));
      ShowMessage('P√©rim√®tre: ' + FloatToStr(Formes[i].Perimetre));
    end;

    // Calcul de l'aire totale (polymorphisme en action)
    TotalAire := 0;
    for i := 0 to 2 do
      TotalAire := TotalAire + Formes[i].Aire;

    ShowMessage('Aire totale: ' + FloatToStr(TotalAire));

  finally
    // Lib√©ration de la m√©moire
    for i := 0 to 2 do
      Formes[i].Free;
  end;
end;
```

## Conseils pratiques

1. **Utilisez protected pour l'h√©ritage** :
   - Les √©l√©ments qui doivent √™tre accessibles aux classes d√©riv√©es mais pas au monde ext√©rieur doivent √™tre `protected`

2. **Pensez √† la red√©finition** :
   - D√©clarez comme `virtual` les m√©thodes qui pourraient avoir besoin d'√™tre sp√©cialis√©es
   - Utilisez `override` (et non `reintroduce`) pour red√©finir une m√©thode

3. **Appel de la m√©thode parent** :
   - N'oubliez pas d'appeler la m√©thode parent avec `inherited` quand n√©cessaire
   - C'est particuli√®rement important pour les constructeurs et destructeurs

4. **Hi√©rarchies d'objets** :
   - Concevez vos hi√©rarchies avec soin, en pla√ßant les comportements communs dans les classes de base
   - √âvitez les hi√©rarchies trop profondes (plus de 3-4 niveaux peuvent devenir difficiles √† maintenir)

5. **Destructeurs virtuels** :
   - Assurez-vous que vos destructeurs sont virtuels pour √©viter les fuites de m√©moire

```pascal
destructor TFormeGeometrique.Destroy; override;  // override car TObject.Destroy est virtual
begin
  // Nettoyage sp√©cifique ici

  inherited;  // Appel du destructeur parent (APR√àS le nettoyage)
end;
```

---

L'h√©ritage et le polymorphisme sont des outils puissants qui vous permettent de cr√©er des hi√©rarchies de classes flexibles et extensibles. En comprenant comment les utiliser efficacement, vous pourrez concevoir des applications Delphi bien structur√©es et faciles √† maintenir.

Dans la prochaine section, nous approfondirons la gestion des objets en explorant les constructeurs et destructeurs, qui sont essentiels pour initialiser correctement vos objets et lib√©rer les ressources qu'ils utilisent.

‚è≠Ô∏è [Constructeurs et destructeurs](/03-langage-object-pascal/07.4-constructeurs-destructeurs.md)

