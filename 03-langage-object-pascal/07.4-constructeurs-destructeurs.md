üîù Retour au [Sommaire](/SOMMAIRE.md)

# 3.7.4 Constructeurs et destructeurs en Object Pascal

## Introduction

Les **constructeurs** et **destructeurs** sont des m√©thodes sp√©ciales qui g√®rent le cycle de vie d'un objet : sa cr√©ation (naissance) et sa destruction (mort). Comprendre ces concepts est essentiel pour √©viter les fuites m√©moire et cr√©er des applications robustes.

## Les constructeurs

### Qu'est-ce qu'un constructeur ?

Un **constructeur** est une m√©thode sp√©ciale qui initialise un nouvel objet. C'est la premi√®re m√©thode appel√©e lors de la cr√©ation d'une instance d'une classe. Le constructeur pr√©pare l'objet pour √™tre utilis√©.

### Analogie

Imaginez la construction d'une maison :
- Le **constructeur** est l'√©quipe de construction qui b√¢tit la maison
- Avant que vous puissiez habiter la maison, elle doit √™tre construite
- Le constructeur s'assure que tout est en place : fondations, murs, toit, √©lectricit√©

### Syntaxe d'un constructeur

En Object Pascal, un constructeur se d√©clare avec le mot-cl√© `constructor` :

```pascal
type
  TPersonne = class
  private
    FNom: string;
    FAge: Integer;
  public
    constructor Create;  // Constructeur
    property Nom: string read FNom write FNom;
    property Age: Integer read FAge write FAge;
  end;

// Impl√©mentation
constructor TPersonne.Create;
begin
  inherited Create;  // Appelle le constructeur de la classe parent
  FNom := '';
  FAge := 0;
  ShowMessage('Une personne a √©t√© cr√©√©e');
end;
```

### Utilisation du constructeur

```pascal
var
  Personne: TPersonne;
begin
  // Appel du constructeur
  Personne := TPersonne.Create;
  try
    Personne.Nom := 'Marie';
    Personne.Age := 25;
    ShowMessage(Personne.Nom);
  finally
    Personne.Free;
  end;
end;
```

### Le mot-cl√© inherited

Le mot-cl√© `inherited` dans un constructeur appelle le constructeur de la classe parent. C'est important car :
- Toutes les classes h√©ritent de `TObject`
- `TObject.Create` alloue la m√©moire n√©cessaire pour l'objet
- Sans cet appel, l'objet ne serait pas correctement initialis√©

```pascal
constructor TMaClasse.Create;
begin
  inherited Create;  // TOUJOURS appeler inherited dans un constructeur
  // Votre code d'initialisation ici
end;
```

## Constructeurs avec param√®tres

Les constructeurs peuvent accepter des param√®tres pour initialiser l'objet avec des valeurs sp√©cifiques :

```pascal
type
  TCompte = class
  private
    FTitulaire: string;
    FSolde: Double;
  public
    constructor Create(ATitulaire: string; ASoldeInitial: Double);
    property Titulaire: string read FTitulaire;
    property Solde: Double read FSolde write FSolde;
  end;

constructor TCompte.Create(ATitulaire: string; ASoldeInitial: Double);
begin
  inherited Create;
  FTitulaire := ATitulaire;
  FSolde := ASoldeInitial;
end;
```

### Utilisation

```pascal
var
  MonCompte: TCompte;
begin
  // Cr√©ation avec initialisation
  MonCompte := TCompte.Create('Jean Dupont', 1000.0);
  try
    ShowMessage(Format('%s a un solde de %.2f ‚Ç¨',
                       [MonCompte.Titulaire, MonCompte.Solde]));
  finally
    MonCompte.Free;
  end;
end;
```

## Constructeurs multiples (surcharge)

Une classe peut avoir plusieurs constructeurs avec des param√®tres diff√©rents. C'est ce qu'on appelle la **surcharge** (overload) :

```pascal
type
  TRectangle = class
  private
    FLargeur: Double;
    FHauteur: Double;
  public
    constructor Create; overload;  // Constructeur par d√©faut
    constructor Create(ACote: Double); overload;  // Carr√©
    constructor Create(ALargeur, AHauteur: Double); overload;  // Rectangle
    property Largeur: Double read FLargeur write FLargeur;
    property Hauteur: Double read FHauteur write FHauteur;
  end;

// Constructeur par d√©faut : rectangle 1x1
constructor TRectangle.Create;
begin
  inherited Create;
  FLargeur := 1;
  FHauteur := 1;
end;

// Constructeur pour un carr√©
constructor TRectangle.Create(ACote: Double);
begin
  inherited Create;
  FLargeur := ACote;
  FHauteur := ACote;
end;

// Constructeur pour un rectangle quelconque
constructor TRectangle.Create(ALargeur, AHauteur: Double);
begin
  inherited Create;
  FLargeur := ALargeur;
  FHauteur := AHauteur;
end;
```

### Utilisation des diff√©rents constructeurs

```pascal
var
  Rect1, Rect2, Rect3: TRectangle;
begin
  // Utilisation du constructeur par d√©faut
  Rect1 := TRectangle.Create;

  // Utilisation du constructeur pour un carr√©
  Rect2 := TRectangle.Create(5);

  // Utilisation du constructeur pour un rectangle
  Rect3 := TRectangle.Create(4, 7);

  try
    ShowMessage(Format('Rect1 : %.1f x %.1f', [Rect1.Largeur, Rect1.Hauteur]));
    ShowMessage(Format('Rect2 : %.1f x %.1f', [Rect2.Largeur, Rect2.Hauteur]));
    ShowMessage(Format('Rect3 : %.1f x %.1f', [Rect3.Largeur, Rect3.Hauteur]));
  finally
    Rect1.Free;
    Rect2.Free;
    Rect3.Free;
  end;
end;
```

## Les destructeurs

### Qu'est-ce qu'un destructeur ?

Un **destructeur** est une m√©thode sp√©ciale qui nettoie et lib√®re les ressources utilis√©es par un objet avant sa destruction. C'est la derni√®re m√©thode appel√©e avant que l'objet ne soit supprim√© de la m√©moire.

### Analogie

Continuons avec l'analogie de la maison :
- Le **destructeur** est l'√©quipe de d√©molition
- Avant de d√©truire la maison, il faut couper l'eau, l'√©lectricit√©, le gaz
- Il faut aussi r√©cup√©rer les objets de valeur
- Enfin, on peut d√©molir la structure

### Syntaxe d'un destructeur

En Object Pascal, un destructeur se d√©clare avec le mot-cl√© `destructor`. Par convention, il s'appelle `Destroy` :

```pascal
type
  TFichier = class
  private
    FNomFichier: string;
    FContenu: TStringList;
  public
    constructor Create(ANomFichier: string);
    destructor Destroy; override;  // Destructeur
    property NomFichier: string read FNomFichier;
  end;

constructor TFichier.Create(ANomFichier: string);
begin
  inherited Create;
  FNomFichier := ANomFichier;
  FContenu := TStringList.Create;  // Cr√©ation d'un objet interne
  ShowMessage('Fichier ouvert : ' + FNomFichier);
end;

destructor TFichier.Destroy;
begin
  FContenu.Free;  // Lib√©rer l'objet interne
  ShowMessage('Fichier ferm√© : ' + FNomFichier);
  inherited Destroy;  // TOUJOURS appeler inherited en dernier
end;
```

### Points importants sur les destructeurs

1. **Toujours nomm√© `Destroy`** : par convention
2. **Mot-cl√© `override`** : car on red√©finit le destructeur de `TObject`
3. **`inherited Destroy` en dernier** : contrairement au constructeur o√π `inherited` est appel√© en premier
4. **Lib√©rer les objets internes** : tout objet cr√©√© dans le constructeur doit √™tre lib√©r√© dans le destructeur

### La m√©thode Free

Au lieu d'appeler directement `Destroy`, on utilise la m√©thode `Free` qui :
- V√©rifie si l'objet existe (n'est pas `nil`)
- Appelle `Destroy` si l'objet existe
- D√©finit la variable √† `nil` pour √©viter les erreurs

```pascal
var
  MonFichier: TFichier;
begin
  MonFichier := TFichier.Create('document.txt');
  try
    // Utilisation de l'objet
  finally
    MonFichier.Free;  // Appelle Destroy de mani√®re s√©curis√©e
  end;
end;
```

## Exemple complet : Classe Connexion Base de Donn√©es

Voici un exemple illustrant l'importance des constructeurs et destructeurs :

```pascal
type
  TConnexionDB = class
  private
    FServeur: string;
    FBaseDeDonnees: string;
    FConnecte: Boolean;
    FDateConnexion: TDateTime;
  public
    constructor Create(AServeur, ABaseDeDonnees: string);
    destructor Destroy; override;
    procedure Connecter;
    procedure Deconnecter;
    property Connecte: Boolean read FConnecte;
    property DateConnexion: TDateTime read FDateConnexion;
  end;

constructor TConnexionDB.Create(AServeur, ABaseDeDonnees: string);
begin
  inherited Create;
  FServeur := AServeur;
  FBaseDeDonnees := ABaseDeDonnees;
  FConnecte := False;
  FDateConnexion := 0;
  ShowMessage('Objet connexion cr√©√©');
end;

destructor TConnexionDB.Destroy;
begin
  // Nettoyer avant de d√©truire
  if FConnecte then
    Deconnecter;

  ShowMessage('Objet connexion d√©truit');
  inherited Destroy;  // Toujours en dernier
end;

procedure TConnexionDB.Connecter;
begin
  if not FConnecte then
  begin
    // Simulation de connexion
    FConnecte := True;
    FDateConnexion := Now;
    ShowMessage(Format('Connect√© √† %s/%s', [FServeur, FBaseDeDonnees]));
  end;
end;

procedure TConnexionDB.Deconnecter;
begin
  if FConnecte then
  begin
    // Simulation de d√©connexion
    FConnecte := False;
    ShowMessage('D√©connect√©');
  end;
end;
```

### Utilisation

```pascal
var
  Connexion: TConnexionDB;
begin
  Connexion := TConnexionDB.Create('localhost', 'MaBase');
  try
    Connexion.Connecter;
    // Utilisation de la connexion
    ShowMessage('Travail avec la base de donn√©es...');
  finally
    Connexion.Free;  // Le destructeur d√©connectera automatiquement
  end;
end;
```

## Constructeurs et destructeurs avec h√©ritage

Lorsqu'on travaille avec l'h√©ritage, l'ordre d'appel est important :

```pascal
type
  // Classe de base
  TVehicule = class
  private
    FMarque: string;
  public
    constructor Create(AMarque: string);
    destructor Destroy; override;
  end;

  // Classe d√©riv√©e
  TVoiture = class(TVehicule)
  private
    FNombrePortes: Integer;
  public
    constructor Create(AMarque: string; ANombrePortes: Integer);
    destructor Destroy; override;
  end;

// Impl√©mentation TVehicule

constructor TVehicule.Create(AMarque: string);
begin
  inherited Create;
  FMarque := AMarque;
  ShowMessage('V√©hicule cr√©√© : ' + FMarque);
end;

destructor TVehicule.Destroy;
begin
  ShowMessage('V√©hicule d√©truit : ' + FMarque);
  inherited Destroy;
end;

// Impl√©mentation TVoiture

constructor TVoiture.Create(AMarque: string; ANombrePortes: Integer);
begin
  inherited Create(AMarque);  // Appelle le constructeur du parent
  FNombrePortes := ANombrePortes;
  ShowMessage(Format('Voiture avec %d portes cr√©√©e', [FNombrePortes]));
end;

destructor TVoiture.Destroy;
begin
  ShowMessage('Voiture d√©truite');
  inherited Destroy;  // Appelle le destructeur du parent
end;
```

### Ordre d'ex√©cution

```pascal
var
  MaVoiture: TVoiture;
begin
  MaVoiture := TVoiture.Create('Renault', 5);
  // Ordre de cr√©ation :
  // 1. TObject.Create (implicite)
  // 2. TVehicule.Create
  // 3. TVoiture.Create

  try
    // Utilisation
  finally
    MaVoiture.Free;
    // Ordre de destruction :
    // 1. TVoiture.Destroy
    // 2. TVehicule.Destroy
    // 3. TObject.Destroy (implicite)
  end;
end;
```

## Gestion des erreurs dans les constructeurs

Si une erreur se produit dans un constructeur, l'objet peut √™tre partiellement construit. Il faut g√©rer ce cas :

```pascal
type
  TRessource = class
  private
    FDonnees: TStringList;
    FFichier: TFileStream;
  public
    constructor Create(ANomFichier: string);
    destructor Destroy; override;
  end;

constructor TRessource.Create(ANomFichier: string);
begin
  inherited Create;
  FDonnees := TStringList.Create;

  try
    FFichier := TFileStream.Create(ANomFichier, fmOpenRead);
  except
    // Si l'ouverture du fichier √©choue, lib√©rer ce qui a √©t√© cr√©√©
    FDonnees.Free;
    raise;  // Relancer l'exception
  end;
end;

destructor TRessource.Destroy;
begin
  FFichier.Free;
  FDonnees.Free;
  inherited Destroy;
end;
```

## Exemple avanc√© : Pool d'objets

Voici un exemple montrant l'utilisation de constructeurs/destructeurs pour g√©rer un compteur d'instances :

```pascal
type
  TConnexion = class
  private
    class var FNombreInstances: Integer;  // Variable de classe
    FID: Integer;
  public
    constructor Create;
    destructor Destroy; override;
    class function ObtenirNombreInstances: Integer;
    property ID: Integer read FID;
  end;

constructor TConnexion.Create;
begin
  inherited Create;
  Inc(FNombreInstances);
  FID := FNombreInstances;
  ShowMessage(Format('Connexion #%d cr√©√©e (Total: %d)',
                     [FID, FNombreInstances]));
end;

destructor TConnexion.Destroy;
begin
  ShowMessage(Format('Connexion #%d d√©truite (Restant: %d)',
                     [FID, FNombreInstances - 1]));
  Dec(FNombreInstances);
  inherited Destroy;
end;

class function TConnexion.ObtenirNombreInstances: Integer;
begin
  Result := FNombreInstances;
end;
```

### Utilisation

```pascal
var
  Conn1, Conn2, Conn3: TConnexion;
begin
  Conn1 := TConnexion.Create;  // Connexion #1 cr√©√©e (Total: 1)
  Conn2 := TConnexion.Create;  // Connexion #2 cr√©√©e (Total: 2)
  Conn3 := TConnexion.Create;  // Connexion #3 cr√©√©e (Total: 3)

  ShowMessage('Instances actives : ' +
              IntToStr(TConnexion.ObtenirNombreInstances));

  Conn2.Free;  // Connexion #2 d√©truite (Restant: 2)

  ShowMessage('Instances actives : ' +
              IntToStr(TConnexion.ObtenirNombreInstances));

  Conn1.Free;
  Conn3.Free;
end;
```

## La m√©thode FreeAndNil

Pour √©viter les erreurs avec des pointeurs dangling (pointant vers de la m√©moire lib√©r√©e), utilisez `FreeAndNil` :

```pascal
var
  MonObjet: TMonObjet;
begin
  MonObjet := TMonObjet.Create;
  try
    // Utilisation
  finally
    FreeAndNil(MonObjet);  // Lib√®re ET met √† nil
  end;

  // MonObjet vaut maintenant nil, pas de risque d'acc√®s invalide
end;
```

`FreeAndNil` fait deux choses :
1. Appelle `Free` sur l'objet
2. Met la variable √† `nil`

## Constructeurs virtuels

Les constructeurs peuvent √™tre virtuels, ce qui permet le polymorphisme :

```pascal
type
  TDocument = class
  public
    constructor Create; virtual;
    procedure Sauvegarder; virtual; abstract;
  end;

  TDocumentTexte = class(TDocument)
  public
    constructor Create; override;
    procedure Sauvegarder; override;
  end;

  TDocumentImage = class(TDocument)
  public
    constructor Create; override;
    procedure Sauvegarder; override;
  end;

constructor TDocument.Create;
begin
  inherited Create;
  ShowMessage('Document g√©n√©rique cr√©√©');
end;

constructor TDocumentTexte.Create;
begin
  inherited Create;
  ShowMessage('Document texte cr√©√©');
end;

constructor TDocumentImage.Create;
begin
  inherited Create;
  ShowMessage('Document image cr√©√©');
end;
```

### Utilisation avec les m√©taclasses

```pascal
type
  TDocumentClass = class of TDocument;

procedure CreerEtUtiliser(ClasseDocument: TDocumentClass);
var
  Doc: TDocument;
begin
  Doc := ClasseDocument.Create;  // Polymorphisme au niveau de la classe
  try
    Doc.Sauvegarder;
  finally
    Doc.Free;
  end;
end;

begin
  CreerEtUtiliser(TDocumentTexte);
  CreerEtUtiliser(TDocumentImage);
end;
```

## Bonnes pratiques

### 1. Toujours utiliser try...finally

```pascal
// ‚úÖ Bon
var
  Obj: TMonObjet;
begin
  Obj := TMonObjet.Create;
  try
    // Utilisation
  finally
    Obj.Free;
  end;
end;

// ‚ùå Mauvais - risque de fuite m√©moire en cas d'exception
var
  Obj: TMonObjet;
begin
  Obj := TMonObjet.Create;
  // Utilisation
  Obj.Free;
end;
```

### 2. Initialiser tous les champs dans le constructeur

```pascal
constructor TPersonne.Create;
begin
  inherited Create;
  FNom := '';           // Toujours initialiser
  FAge := 0;            // Ne pas laisser de valeurs ind√©finies
  FActif := False;
  FDateCreation := Now;
end;
```

### 3. Lib√©rer tous les objets cr√©√©s dans le destructeur

```pascal
constructor TMaClasse.Create;
begin
  inherited Create;
  FListe := TStringList.Create;
  FDictionnaire := TDictionary<string, Integer>.Create;
end;

destructor TMaClasse.Destroy;
begin
  FDictionnaire.Free;  // Lib√©rer tout ce qui a √©t√© cr√©√©
  FListe.Free;
  inherited Destroy;   // Toujours en dernier
end;
```

### 4. inherited Create en premier, inherited Destroy en dernier

```pascal
// ‚úÖ Bon
constructor TMaClasse.Create;
begin
  inherited Create;  // EN PREMIER
  // Initialisation
end;

destructor TMaClasse.Destroy;
begin
  // Nettoyage
  inherited Destroy;  // EN DERNIER
end;
```

### 5. Utiliser FreeAndNil pour √©viter les acc√®s invalides

```pascal
procedure TForm.FermerConnexion;
begin
  FreeAndNil(FConnexion);  // Lib√®re et met √† nil
  // FConnexion vaut maintenant nil, s√ªr pour les tests ult√©rieurs
end;
```

### 6. Valider les param√®tres du constructeur

```pascal
constructor TRectangle.Create(ALargeur, AHauteur: Double);
begin
  inherited Create;

  if (ALargeur <= 0) or (AHauteur <= 0) then
    raise Exception.Create('Les dimensions doivent √™tre positives');

  FLargeur := ALargeur;
  FHauteur := AHauteur;
end;
```

## Erreurs courantes √† √©viter

### 1. Oublier inherited

```pascal
// ‚ùå Mauvais
constructor TMaClasse.Create;
begin
  // Manque inherited Create !
  FValeur := 10;
end;

// ‚úÖ Bon
constructor TMaClasse.Create;
begin
  inherited Create;
  FValeur := 10;
end;
```

### 2. Ne pas lib√©rer les objets internes

```pascal
// ‚ùå Mauvais - fuite m√©moire !
constructor TMaClasse.Create;
begin
  inherited Create;
  FListe := TStringList.Create;
end;

destructor TMaClasse.Destroy;
begin
  // Manque FListe.Free !
  inherited Destroy;
end;

// ‚úÖ Bon
destructor TMaClasse.Destroy;
begin
  FListe.Free;
  inherited Destroy;
end;
```

### 3. Appeler Free au lieu de Destroy

```pascal
// ‚ùå Mauvais
MyObject.Destroy;  // Ne faites jamais √ßa !

// ‚úÖ Bon
MyObject.Free;  // Utilisez toujours Free
```

## R√©sum√©

- **Constructeur** (`constructor Create`)
  - Initialise un nouvel objet
  - Appel√© avec le mot-cl√© `Create`
  - `inherited Create` doit √™tre appel√© en premier
  - Peut avoir plusieurs versions (surcharge avec `overload`)
  - Peut accepter des param√®tres pour l'initialisation

- **Destructeur** (`destructor Destroy`)
  - Nettoie et lib√®re les ressources
  - Toujours nomm√© `Destroy`
  - `inherited Destroy` doit √™tre appel√© en dernier
  - Lib√®re tous les objets internes cr√©√©s
  - Ne jamais appeler directement, utiliser `Free`

- **Bonnes pratiques**
  - Toujours utiliser `try...finally` avec `Free`
  - Initialiser tous les champs dans le constructeur
  - Lib√©rer tous les objets internes dans le destructeur
  - Utiliser `FreeAndNil` pour √©viter les pointeurs dangling
  - Valider les param√®tres du constructeur

- **Gestion m√©moire**
  - Les objets Delphi ne sont pas lib√©r√©s automatiquement
  - Toujours appeler `Free` pour √©viter les fuites m√©moire
  - Le bloc `try...finally` garantit la lib√©ration m√™me en cas d'exception

Ma√Ætriser les constructeurs et destructeurs est essentiel pour cr√©er des applications Delphi robustes et √©viter les fuites m√©moire.

‚è≠Ô∏è [Interfaces](/03-langage-object-pascal/07.5-interfaces.md)
