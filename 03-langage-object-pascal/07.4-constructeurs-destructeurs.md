# 3.7.4 Constructeurs et destructeurs

üîù Retour √† la [Table des mati√®res](/SOMMAIRE.md)

Les constructeurs et destructeurs sont des m√©thodes sp√©ciales qui g√®rent respectivement la cr√©ation et la destruction des objets. Ces m√©thodes sont essentielles pour garantir que vos objets sont correctement initialis√©s et que toutes les ressources qu'ils utilisent sont proprement lib√©r√©es. Dans cette section, nous allons explorer comment utiliser efficacement ces m√©thodes en Object Pascal.

## Constructeurs : cr√©er et initialiser des objets

Un constructeur est une m√©thode sp√©ciale qui est appel√©e automatiquement lors de la cr√©ation d'un objet. Son r√¥le principal est d'initialiser l'objet et de s'assurer qu'il est dans un √©tat valide avant d'√™tre utilis√©.

### Le constructeur par d√©faut

Toutes les classes en Delphi h√©ritent d'un constructeur par d√©faut nomm√© `Create` de la classe `TObject` :

```pascal
var
  MaClasse: TMaClasse;
begin
  MaClasse := TMaClasse.Create;  // Appel du constructeur par d√©faut
  try
    // Utilisation de l'objet
  finally
    MaClasse.Free;
  end;
end;
```

### Cr√©ation d'un constructeur personnalis√©

Pour cr√©er votre propre constructeur, vous devez :
1. D√©clarer un constructeur dans la section de classe
2. Impl√©menter le constructeur, g√©n√©ralement en appelant d'abord le constructeur parent

```pascal
type
  TPersonne = class
  private
    FNom: string;
    FAge: Integer;
  public
    constructor Create(const ANom: string; AAge: Integer);
    // ...
  end;

constructor TPersonne.Create(const ANom: string; AAge: Integer);
begin
  inherited Create;  // Appelle le constructeur de la classe parente (TObject)
  FNom := ANom;
  FAge := AAge;
end;
```

Utilisation :

```pascal
var
  Personne: TPersonne;
begin
  Personne := TPersonne.Create('Jean Dupont', 30);
  try
    // Utilisation de l'objet
  finally
    Personne.Free;
  end;
end;
```

### Plusieurs constructeurs

Une classe peut avoir plusieurs constructeurs, avec des signatures diff√©rentes :

```pascal
type
  TPersonne = class
  private
    FNom: string;
    FAge: Integer;
  public
    constructor Create; overload;  // Constructeur par d√©faut
    constructor Create(const ANom: string); overload;  // Avec nom seulement
    constructor Create(const ANom: string; AAge: Integer); overload;  // Avec nom et √¢ge
    // ...
  end;

constructor TPersonne.Create;
begin
  inherited Create;
  FNom := 'Inconnu';
  FAge := 0;
end;

constructor TPersonne.Create(const ANom: string);
begin
  inherited Create;
  FNom := ANom;
  FAge := 0;
end;

constructor TPersonne.Create(const ANom: string; AAge: Integer);
begin
  inherited Create;
  FNom := ANom;
  FAge := AAge;
end;
```

### R√©utilisation de code entre constructeurs

Pour √©viter la duplication de code, vous pouvez faire en sorte qu'un constructeur en appelle un autre :

```pascal
constructor TPersonne.Create;
begin
  Create('Inconnu', 0);  // Appel √† un autre constructeur de la m√™me classe
end;

constructor TPersonne.Create(const ANom: string);
begin
  Create(ANom, 0);  // Appel √† un autre constructeur de la m√™me classe
end;

constructor TPersonne.Create(const ANom: string; AAge: Integer);
begin
  inherited Create;  // Appel du constructeur parent
  FNom := ANom;
  FAge := AAge;
end;
```

### Param√®tres par d√©faut

Une autre approche consiste √† utiliser des param√®tres par d√©faut :

```pascal
type
  TPersonne = class
  private
    FNom: string;
    FAge: Integer;
  public
    constructor Create(const ANom: string = 'Inconnu'; AAge: Integer = 0);
    // ...
  end;

constructor TPersonne.Create(const ANom: string; AAge: Integer);
begin
  inherited Create;
  FNom := ANom;
  FAge := AAge;
end;
```

Utilisation :

```pascal
Personne1 := TPersonne.Create;                // Utilise les valeurs par d√©faut
Personne2 := TPersonne.Create('Jean');        // Nom = 'Jean', Age = 0
Personne3 := TPersonne.Create('Marie', 25);   // Nom = 'Marie', Age = 25
```

### Constructeurs virtuels

En Delphi, les constructeurs peuvent √™tre virtuels, ce qui permet aux classes d√©riv√©es de personnaliser le processus de cr√©ation :

```pascal
type
  TBase = class
  public
    constructor Create; virtual;
  end;

  TDerivee = class(TBase)
  public
    constructor Create; override;
  end;
```

Les constructeurs virtuels sont particuli√®rement utiles pour les frameworks et les biblioth√®ques, mais pour les applications standard, les constructeurs non virtuels sont g√©n√©ralement suffisants.

## Destructeurs : lib√©rer les ressources

Un destructeur est une m√©thode sp√©ciale qui est appel√©e avant qu'un objet ne soit d√©truit. Son r√¥le principal est de lib√©rer les ressources que l'objet a acquises pendant sa vie.

### Le destructeur par d√©faut

Toutes les classes h√©ritent d'un destructeur par d√©faut nomm√© `Destroy` de la classe `TObject`, qui est d√©clar√© comme `virtual` :

```pascal
type
  TObject = class
  public
    constructor Create;
    destructor Destroy; virtual;
    // ...
  end;
```

### Cr√©ation d'un destructeur personnalis√©

Pour cr√©er votre propre destructeur, vous devez :
1. D√©clarer un destructeur dans la section de classe avec le mot-cl√© `override`
2. Impl√©menter le destructeur, en terminant g√©n√©ralement par l'appel au destructeur parent

```pascal
type
  TFichierTexte = class
  private
    FFichier: TextFile;
    FFichierOuvert: Boolean;
  public
    constructor Create(const NomFichier: string);
    destructor Destroy; override;
    // ...
  end;

constructor TFichierTexte.Create(const NomFichier: string);
begin
  inherited Create;
  AssignFile(FFichier, NomFichier);
  Reset(FFichier);
  FFichierOuvert := True;
end;

destructor TFichierTexte.Destroy;
begin
  if FFichierOuvert then
    CloseFile(FFichier);

  inherited Destroy;  // Appel du destructeur parent (TOUJOURS EN DERNIER)
end;
```

### Ordre des op√©rations dans un destructeur

Dans un destructeur, il est important de :
1. Lib√©rer d'abord vos propres ressources
2. Appeler `inherited Destroy` en dernier

Cet ordre est l'inverse de celui d'un constructeur o√π vous appelez d'abord `inherited Create` puis initialisez vos propres ressources.

```pascal
destructor TMaClasse.Destroy;
begin
  // 1. Lib√©ration des ressources propres √† cette classe
  MonObjet.Free;
  MaListe.Free;

  // 2. Appel du destructeur parent (TOUJOURS EN DERNIER)
  inherited Destroy;
end;
```

### Pourquoi appeler inherited Destroy en dernier ?

Imaginez une hi√©rarchie de classes o√π chaque niveau alloue ses propres ressources :

```
TObject
  |
  +--> TParent (alloue ressource A)
        |
        +--> TEnfant (alloue ressource B)
```

Si `TEnfant.Destroy` appelle `inherited Destroy` avant de lib√©rer la ressource B, la s√©quence serait :
1. `TEnfant.Destroy` commence
2. `TParent.Destroy` est appel√© et lib√®re la ressource A
3. `TObject.Destroy` est appel√©
4. Retour √† `TEnfant.Destroy` pour lib√©rer la ressource B, mais l'objet pourrait d√©j√† √™tre dans un √©tat invalide

En appelant `inherited Destroy` en dernier, vous garantissez que l'objet reste dans un √©tat coh√©rent jusqu'√† ce que toutes ses propres ressources soient lib√©r√©es.

## Free vs Destroy

Dans Delphi, vous devez rarement appeler `Destroy` directement. √Ä la place, utilisez la m√©thode `Free` :

```pascal
MonObjet.Free;  // Pr√©f√©rer cette approche
// plut√¥t que
MonObjet.Destroy;
```

Pourquoi ? Parce que `Free` v√©rifie d'abord si l'objet est `nil` avant d'appeler `Destroy` :

```pascal
procedure TObject.Free;
begin
  if Self <> nil then
    Destroy;
end;
```

Cela vous √©vite les erreurs "Acc√®s √† une r√©f√©rence nil" si l'objet a d√©j√† √©t√© lib√©r√© ou n'a jamais √©t√© cr√©√©.

## FreeAndNil

Pour √©viter les r√©f√©rences pendantes, vous pouvez utiliser `FreeAndNil` qui lib√®re l'objet et met la r√©f√©rence √† `nil` :

```pascal
var
  MonObjet: TMonObjet;
begin
  MonObjet := TMonObjet.Create;
  // ...
  FreeAndNil(MonObjet);  // Lib√®re l'objet et met MonObjet √† nil

  // Maintenant, c'est s√ªr :
  if MonObjet = nil then
    ShowMessage('L''objet a √©t√© lib√©r√©');
end;
```

## Gestion automatique de la m√©moire avec try-finally

Le pattern standard pour utiliser des objets en Delphi est :

```pascal
var
  MonObjet: TMonObjet;
begin
  MonObjet := TMonObjet.Create;
  try
    // Utilisation de l'objet
  finally
    MonObjet.Free;
  end;
end;
```

Le bloc `try-finally` garantit que `MonObjet.Free` sera appel√© m√™me si une exception se produit dans le bloc `try`. C'est essentiel pour √©viter les fuites de m√©moire.

## Constructeurs, h√©ritage et polymorphisme

### H√©ritage et constructeurs

Lorsque vous cr√©ez une classe d√©riv√©e, vous devez g√©n√©ralement :
1. Cr√©er un constructeur qui accepte les param√®tres n√©cessaires
2. Appeler le constructeur de la classe parente avec les param√®tres appropri√©s

```pascal
type
  TPersonne = class
  private
    FNom: string;
  public
    constructor Create(const ANom: string);
    // ...
  end;

  TEmploye = class(TPersonne)
  private
    FPoste: string;
  public
    constructor Create(const ANom, APoste: string);
    // ...
  end;

constructor TPersonne.Create(const ANom: string);
begin
  inherited Create;  // Appelle TObject.Create
  FNom := ANom;
end;

constructor TEmploye.Create(const ANom, APoste: string);
begin
  inherited Create(ANom);  // Appelle TPersonne.Create avec le nom
  FPoste := APoste;
end;
```

### Polymorphisme et destructeurs

Les destructeurs doivent toujours √™tre d√©clar√©s comme `override` pour garantir le bon fonctionnement du polymorphisme :

```pascal
type
  TBase = class
  public
    destructor Destroy; override;  // override car TObject.Destroy est virtual
  end;

  TDerivee = class(TBase)
  public
    destructor Destroy; override;  // override car TBase.Destroy est override
  end;
```

Si vous oubliez `override`, le destructeur de votre classe d√©riv√©e ne sera pas appel√© lorsque l'objet est r√©f√©renc√© via une variable de la classe de base :

```pascal
var
  Base: TBase;
begin
  Base := TDerivee.Create;
  try
    // ...
  finally
    Base.Free;  // Sans override, seul TBase.Destroy serait appel√©!
  end;
end;
```

## Initialisation d'objets complexes

Pour les objets complexes, il peut √™tre utile de s√©parer la cr√©ation et l'initialisation :

```pascal
type
  TApplication = class
  private
    FConfig: TConfig;
    FDatabase: TDatabase;
    FLogger: TLogger;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Initialize;
    // ...
  end;

constructor TApplication.Create;
begin
  inherited Create;
  // Cr√©ation des objets sans initialisation complexe
  FConfig := TConfig.Create;
  FDatabase := TDatabase.Create;
  FLogger := TLogger.Create;
end;

procedure TApplication.Initialize;
begin
  // Initialisation des objets, potentiellement avec des d√©pendances entre eux
  FConfig.LoadFromFile('config.ini');
  FLogger.SetLogLevel(FConfig.LogLevel);
  FDatabase.Connect(FConfig.DatabaseConnectionString);
end;

destructor TApplication.Destroy;
begin
  FLogger.Free;
  FDatabase.Free;
  FConfig.Free;
  inherited Destroy;
end;
```

Cette approche permet d'avoir un code plus clair et de g√©rer les d√©pendances entre objets plus facilement.

## Constructeurs de classes

Delphi supporte √©galement les "constructeurs de classe", qui sont des m√©thodes statiques appel√©es sans instance :

```pascal
type
  TPersonne = class
  private
    FNom: string;
  public
    constructor Create(const ANom: string);

    // Constructeur de classe
    class function CreateDefaultPerson: TPersonne;
  end;

class function TPersonne.CreateDefaultPerson: TPersonne;
begin
  Result := TPersonne.Create('John Doe');
end;
```

Utilisation :

```pascal
var
  Personne: TPersonne;
begin
  Personne := TPersonne.CreateDefaultPerson;
  try
    // ...
  finally
    Personne.Free;
  end;
end;
```

Ces m√©thodes sont utiles pour encapsuler la logique de cr√©ation complexe ou pour fournir des objets pr√©configur√©s.

## Exemples concrets

### Classe simple avec constructeur et destructeur

```pascal
type
  TJoueur = class
  private
    FNom: string;
    FScore: Integer;
  public
    constructor Create(const ANom: string);
    destructor Destroy; override;

    procedure AugmenterScore(Points: Integer);

    property Nom: string read FNom;
    property Score: Integer read FScore;
  end;

constructor TJoueur.Create(const ANom: string);
begin
  inherited Create;

  if ANom = '' then
    raise Exception.Create('Le nom du joueur ne peut pas √™tre vide');

  FNom := ANom;
  FScore := 0;
end;

destructor TJoueur.Destroy;
begin
  // Pas de ressources sp√©ciales √† lib√©rer ici

  inherited Destroy;
end;

procedure TJoueur.AugmenterScore(Points: Integer);
begin
  if Points > 0 then
    FScore := FScore + Points;
end;
```

### Classe avec des ressources √† lib√©rer

```pascal
type
  TGestionnaireFichiers = class
  private
    FNomFichier: string;
    FFichier: TextFile;
    FFichierOuvert: Boolean;
    FLignes: TStringList;
  public
    constructor Create(const ANomFichier: string);
    destructor Destroy; override;

    procedure ChargerFichier;
    procedure SauvegarderFichier;
    function ObtenirLigne(Index: Integer): string;

    property NomFichier: string read FNomFichier;
  end;

constructor TGestionnaireFichiers.Create(const ANomFichier: string);
begin
  inherited Create;

  FNomFichier := ANomFichier;
  FFichierOuvert := False;

  // Cr√©ation d'objets internes
  FLignes := TStringList.Create;
end;

destructor TGestionnaireFichiers.Destroy;
begin
  // Fermeture du fichier si n√©cessaire
  if FFichierOuvert then
    CloseFile(FFichier);

  // Lib√©ration des objets internes
  FLignes.Free;

  inherited Destroy;
end;

procedure TGestionnaireFichiers.ChargerFichier;
var
  Ligne: string;
begin
  if FileExists(FNomFichier) then
  begin
    AssignFile(FFichier, FNomFichier);
    Reset(FFichier);
    FFichierOuvert := True;

    FLignes.Clear;
    while not Eof(FFichier) do
    begin
      ReadLn(FFichier, Ligne);
      FLignes.Add(Ligne);
    end;

    CloseFile(FFichier);
    FFichierOuvert := False;
  end;
end;

procedure TGestionnaireFichiers.SauvegarderFichier;
var
  i: Integer;
begin
  AssignFile(FFichier, FNomFichier);
  Rewrite(FFichier);
  FFichierOuvert := True;

  for i := 0 to FLignes.Count - 1 do
    WriteLn(FFichier, FLignes[i]);

  CloseFile(FFichier);
  FFichierOuvert := False;
end;

function TGestionnaireFichiers.ObtenirLigne(Index: Integer): string;
begin
  if (Index >= 0) and (Index < FLignes.Count) then
    Result := FLignes[Index]
  else
    Result := '';
end;
```

## Bonnes pratiques

1. **Validez les param√®tres** dans le constructeur pour vous assurer que l'objet est dans un √©tat valide :
   ```pascal
   constructor TProduit.Create(const ACode: string; APrix: Currency);
   begin
     inherited Create;

     if ACode = '' then
       raise Exception.Create('Le code produit ne peut pas √™tre vide');

     if APrix < 0 then
       raise Exception.Create('Le prix ne peut pas √™tre n√©gatif');

     FCode := ACode;
     FPrix := APrix;
   end;
   ```

2. **Lib√©rez les ressources** dans l'ordre inverse de leur cr√©ation dans le destructeur :
   ```pascal
   destructor TMonObjet.Destroy;
   begin
     // Lib√©ration dans l'ordre inverse de la cr√©ation
     FObjet3.Free;  // Cr√©√© en dernier
     FObjet2.Free;
     FObjet1.Free;  // Cr√©√© en premier

     inherited Destroy;
   end;
   ```

3. **Utilisez toujours `try-finally`** pour garantir la lib√©ration des objets :
   ```pascal
   var
     Obj: TMonObjet;
   begin
     Obj := TMonObjet.Create;
     try
       // Utilisation de l'objet
     finally
       Obj.Free;
     end;
   end;
   ```

4. **Initialisez les variables d'objets √† `nil`** :
   ```pascal
   var
     Obj: TMonObjet;
   begin
     Obj := nil;  // Bonne pratique
     try
       Obj := TMonObjet.Create;
       // ...
     finally
       Obj.Free;  // S√ªr m√™me si Create a √©chou√©
     end;
   end;
   ```

5. **N'oubliez pas `override`** pour les destructeurs :
   ```pascal
   destructor TMonObjet.Destroy; override;  // Ne pas oublier override
   ```

6. **Utilisez `FreeAndNil`** pour √©viter les r√©f√©rences pendantes :
   ```pascal
   FreeAndNil(MonObjet);  // Lib√®re et met √† nil
   ```

---

Les constructeurs et destructeurs sont essentiels pour garantir que vos objets sont correctement initialis√©s et que toutes les ressources qu'ils utilisent sont proprement lib√©r√©es. En suivant les bonnes pratiques pr√©sent√©es dans cette section, vous √©viterez les fuites de m√©moire et autres probl√®mes li√©s √† la gestion des objets.

Dans la prochaine section, nous explorerons le concept d'interfaces, qui offre une alternative √† l'h√©ritage pour cr√©er des conceptions flexibles et r√©utilisables.

‚è≠Ô∏è [Interfaces](/03-langage-object-pascal/07.5-interfaces.md)

