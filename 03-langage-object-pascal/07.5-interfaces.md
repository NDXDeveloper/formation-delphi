# 3.7.5 Interfaces

üîù Retour √† la [Table des mati√®res](/SOMMAIRE.md)

Les interfaces constituent un concept fondamental de la programmation orient√©e objet qui offre une alternative puissante √† l'h√©ritage. Dans cette section, nous allons d√©couvrir ce que sont les interfaces, pourquoi elles sont utiles et comment les utiliser efficacement en Object Pascal.

## Qu'est-ce qu'une interface ?

Une interface est une sorte de "contrat" qui d√©finit un ensemble de m√©thodes et de propri√©t√©s, sans fournir leur impl√©mentation. Elle sp√©cifie ce qu'un objet peut faire, sans pr√©ciser comment il le fait. Les classes qui "impl√©mentent" une interface s'engagent √† fournir le code pour toutes les m√©thodes et propri√©t√©s d√©finies par cette interface.

Pour faire une analogie, si une classe est comme un plan de maison complet avec tous les d√©tails, une interface est comme une liste d'exigences que la maison doit satisfaire (avoir une porte d'entr√©e, avoir une cuisine, etc.), sans sp√©cifier comment ces exigences doivent √™tre r√©alis√©es.

## Pourquoi utiliser des interfaces ?

Les interfaces offrent plusieurs avantages importants :

1. **S√©paration entre sp√©cification et impl√©mentation** : Elles permettent de d√©finir ce qu'un objet doit faire, sans se pr√©occuper de comment il le fait.

2. **Polymorphisme sans h√©ritage** : Elles permettent √† des classes non li√©es par h√©ritage d'√™tre utilis√©es de mani√®re interchangeable.

3. **Impl√©mentation multiple** : Contrairement √† l'h√©ritage o√π une classe ne peut h√©riter que d'une seule classe parente, une classe peut impl√©menter plusieurs interfaces.

4. **Extensibilit√©** : Elles facilitent l'ajout de nouvelles fonctionnalit√©s sans modifier le code existant.

5. **D√©couplage** : Elles r√©duisent les d√©pendances entre les diff√©rentes parties de votre application.

## D√©claration d'une interface

En Object Pascal, une interface se d√©clare avec le mot-cl√© `interface` (√† ne pas confondre avec la section `interface` d'une unit√©) :

```pascal
type
  IMonInterface = interface
    // D√©clarations de m√©thodes et propri√©t√©s
  end;
```

Par convention, les noms d'interfaces commencent g√©n√©ralement par la lettre `I` (pour "Interface").

Exemple d'une interface simple :

```pascal
type
  IVehicule = interface
    procedure Demarrer;
    procedure Arreter;
    function GetVitesseMaximale: Integer;
    property VitesseMaximale: Integer read GetVitesseMaximale;
  end;
```

Cette interface d√©finit deux proc√©dures (`Demarrer` et `Arreter`), une fonction (`GetVitesseMaximale`) et une propri√©t√© en lecture seule (`VitesseMaximale`).

## GUID d'interface

En Delphi, il est recommand√© d'associer un identifiant unique global (GUID) √† chaque interface pour faciliter leur identification :

```pascal
type
  IVehicule = interface
    ['{A1B2C3D4-E5F6-4747-8899-AABBCCDDEEFF}']  // GUID unique
    procedure Demarrer;
    procedure Arreter;
    function GetVitesseMaximale: Integer;
    property VitesseMaximale: Integer read GetVitesseMaximale;
  end;
```

Pour g√©n√©rer un GUID, vous pouvez utiliser la combinaison de touches Ctrl+Shift+G dans l'√©diteur Delphi.

## Impl√©mentation d'une interface

Pour qu'une classe impl√©mente une interface, elle doit :
1. D√©clarer l'interface dans la clause `implements`
2. Fournir une impl√©mentation pour toutes les m√©thodes et propri√©t√©s d√©finies par l'interface

```pascal
type
  TVoiture = class(TObject, IVehicule)  // La classe impl√©mente IVehicule
  private
    FVitesseMax: Integer;
    function GetVitesseMaximale: Integer;
  public
    constructor Create(AVitesseMax: Integer);

    // Impl√©mentation des m√©thodes de l'interface
    procedure Demarrer;
    procedure Arreter;

    // Autres m√©thodes sp√©cifiques √† TVoiture
    procedure Klaxonner;
  end;

implementation

constructor TVoiture.Create(AVitesseMax: Integer);
begin
  inherited Create;
  FVitesseMax := AVitesseMax;
end;

procedure TVoiture.Demarrer;
begin
  ShowMessage('La voiture d√©marre');
end;

procedure TVoiture.Arreter;
begin
  ShowMessage('La voiture s''arr√™te');
end;

function TVoiture.GetVitesseMaximale: Integer;
begin
  Result := FVitesseMax;
end;

procedure TVoiture.Klaxonner;
begin
  ShowMessage('Beep beep!');
end;
```

## Utilisation des interfaces

Voici comment utiliser des objets via leurs interfaces :

```pascal
var
  Vehicule: IVehicule;
  Voiture: TVoiture;
begin
  Voiture := TVoiture.Create(200);

  // Assignation d'un objet √† une variable d'interface
  Vehicule := Voiture;

  // Utilisation √† travers l'interface
  Vehicule.Demarrer;
  ShowMessage('Vitesse maximale : ' + IntToStr(Vehicule.VitesseMaximale));
  Vehicule.Arreter;

  // Pas besoin de lib√©rer la m√©moire avec Free!
end;
```

Remarquez qu'il n'y a pas de `Voiture.Free` √† la fin. C'est l'un des avantages des interfaces, comme nous allons le voir.

## Comptage de r√©f√©rences automatique

Un des grands avantages des interfaces en Delphi est la gestion automatique de la m√©moire gr√¢ce au comptage de r√©f√©rences :

1. Quand un objet est assign√© √† une variable d'interface, son compteur de r√©f√©rences est incr√©ment√©
2. Quand une variable d'interface sort de port√©e ou est r√©assign√©e, le compteur est d√©cr√©ment√©
3. Quand le compteur atteint z√©ro, l'objet est automatiquement d√©truit

```pascal
procedure UtiliserVehicule;
var
  Vehicule: IVehicule;
begin
  Vehicule := TVoiture.Create(200);  // Compteur = 1

  Vehicule.Demarrer;
  Vehicule.Arreter;

  // √Ä la fin de la proc√©dure, Vehicule sort de port√©e,
  // le compteur passe √† 0 et l'objet est d√©truit automatiquement
end;
```

Cette gestion automatique de la m√©moire simplifie consid√©rablement le code et r√©duit le risque de fuites m√©moire.

## Attention au m√©lange d'objets et d'interfaces

Il faut √™tre prudent lorsqu'on m√©lange les r√©f√©rences d'objet traditionnelles et les interfaces :

```pascal
var
  Voiture: TVoiture;
  Vehicule: IVehicule;
begin
  Voiture := TVoiture.Create(200);  // Vous √™tes responsable de lib√©rer cet objet
  Vehicule := Voiture;             // Compteur = 1

  // ...

  Vehicule := nil;                 // Compteur = 0, l'objet est d√©truit

  // DANGER : Voiture pointe maintenant vers un objet d√©truit!
  Voiture.Klaxonner;  // Ceci va provoquer une erreur d'acc√®s

  // Voiture.Free; // Ceci provoquerait une double lib√©ration
end;
```

Pour √©viter ce probl√®me, choisissez l'une de ces approches :
1. Utilisez uniquement des variables d'interface
2. Utilisez `FreeAndNil(Voiture)` avant d'assigner `nil` √† `Vehicule`
3. Utilisez l'interface `_AddRef` et `_Release` (avanc√©)

## Interfaces multiples

Une classe peut impl√©menter plusieurs interfaces :

```pascal
type
  IVehicule = interface
    ['{A1B2C3D4-E5F6-4747-8899-AABBCCDDEEFF}']
    procedure Demarrer;
    procedure Arreter;
  end;

  IVehiculeTerrain = interface
    ['{F1E2D3C4-B5A6-4747-8899-FFEEDDCCBBAA}']
    procedure TraverserRiviere;
    function EstToutTerrain: Boolean;
  end;

  IJouet = interface
    ['{1234ABCD-5678-ABCD-EF01-23456789ABCD}']
    procedure Jouer;
    function GetTrancheAge: string;
    property TrancheAge: string read GetTrancheAge;
  end;

  TVoitureToutTerrain = class(TObject, IVehicule, IVehiculeTerrain, IJouet)
  private
    function GetTrancheAge: string;
  public
    // Impl√©mentation de IVehicule
    procedure Demarrer;
    procedure Arreter;

    // Impl√©mentation de IVehiculeTerrain
    procedure TraverserRiviere;
    function EstToutTerrain: Boolean;

    // Impl√©mentation de IJouet
    procedure Jouer;
  end;
```

Cette flexibilit√© est un des grands avantages des interfaces par rapport √† l'h√©ritage.

## Conflit de noms et r√©solution explicite

Que se passe-t-il si deux interfaces d√©finissent des m√©thodes avec le m√™me nom ? Vous pouvez utiliser la r√©solution explicite :

```pascal
type
  IAnimal = interface
    procedure Manger;
  end;

  IMachine = interface
    procedure Manger;  // M√™me nom que dans IAnimal
  end;

  TRobotAnimal = class(TObject, IAnimal, IMachine)
  private
    // R√©solution explicite des conflits
    procedure IAnimal.Manger = MangerCommeAnimal;
    procedure IMachine.Manger = MangerCommeMachine;

    // Impl√©mentations r√©elles
    procedure MangerCommeAnimal;
    procedure MangerCommeMachine;
  public
    // Autres m√©thodes...
  end;

implementation

procedure TRobotAnimal.MangerCommeAnimal;
begin
  ShowMessage('Je mange de la nourriture');
end;

procedure TRobotAnimal.MangerCommeMachine;
begin
  ShowMessage('Je consomme de l''√©lectricit√©');
end;
```

## H√©ritage d'interfaces

Les interfaces peuvent h√©riter d'autres interfaces :

```pascal
type
  IVehicule = interface
    procedure Demarrer;
    procedure Arreter;
  end;

  IVoiture = interface(IVehicule)  // H√©rite de IVehicule
    procedure Klaxonner;
    function NombrePortes: Integer;
  end;
```

Une classe qui impl√©mente `IVoiture` doit fournir une impl√©mentation pour toutes les m√©thodes de `IVoiture` ET de `IVehicule`.

## Interfaces et polymorphisme

Les interfaces permettent un polymorphisme puissant, m√™me entre classes sans relation d'h√©ritage :

```pascal
procedure FaireDemarrerEtArreter(Vehicule: IVehicule);
begin
  Vehicule.Demarrer;
  Sleep(1000);  // Attendre 1 seconde
  Vehicule.Arreter;
end;

var
  Voiture: TVoiture;
  Moto: TMoto;
  TondeuseChevauchable: TTondeuse;  // Pas de relation d'h√©ritage avec TVoiture ou TMoto
begin
  Voiture := TVoiture.Create(200);
  Moto := TMoto.Create(250);
  TondeuseChevauchable := TTondeuse.Create(20);

  try
    // Toutes ces classes impl√©mentent IVehicule, donc cette fonction
    // fonctionne avec chacune d'elles
    FaireDemarrerEtArreter(Voiture);
    FaireDemarrerEtArreter(Moto);
    FaireDemarrerEtArreter(TondeuseChevauchable);
  finally
    Voiture.Free;
    Moto.Free;
    TondeuseChevauchable.Free;
  end;
end;
```

## Interface supports

Delphi fournit un m√©canisme appel√© "supports" pour v√©rifier si un objet impl√©mente une interface sp√©cifique :

```pascal
var
  Obj: TObject;
  Vehicule: IVehicule;
begin
  Obj := TVoiture.Create(200);
  try
    if Supports(Obj, IVehicule, Vehicule) then
    begin
      // Obj impl√©mente IVehicule
      Vehicule.Demarrer;
      Vehicule.Arreter;
    end
    else
      ShowMessage('Cet objet n''est pas un v√©hicule');
  finally
    Obj.Free;
  end;
end;
```

La fonction `Supports` essaie de convertir l'objet en interface et renvoie `True` si c'est possible.

## Interfaces vs classes abstraites

Voici une comparaison entre les interfaces et les classes abstraites :

| Caract√©ristique | Interface | Classe abstraite |
|-----------------|-----------|------------------|
| Impl√©mentation | Aucune impl√©mentation | Peut contenir des impl√©mentations |
| H√©ritage multiple | Une classe peut impl√©menter plusieurs interfaces | Une classe ne peut h√©riter que d'une seule classe |
| √âtat | Pas d'√©tat (pas de champs) | Peut avoir un √©tat (champs) |
| Constructeur | Pas de constructeur | Peut avoir un constructeur |
| Gestion m√©moire | Comptage de r√©f√©rences automatique | Manuelle (Free) |

## Exemple concret : syst√®me de journalisation

Voici un exemple pratique montrant comment les interfaces peuvent √™tre utilis√©es pour cr√©er un syst√®me de journalisation flexible :

```pascal
type
  // Interface de journalisation
  ILogger = interface
    ['{12345678-1234-1234-1234-123456789ABC}']
    procedure Log(const AMessage: string);
    procedure LogError(const AError: string);
  end;

  // Impl√©mentation de journalisation dans un fichier
  TFileLogger = class(TInterfacedObject, ILogger)
  private
    FFileName: string;
    FLogFile: TextFile;
  public
    constructor Create(const AFileName: string);
    destructor Destroy; override;

    // Impl√©mentation ILogger
    procedure Log(const AMessage: string);
    procedure LogError(const AError: string);
  end;

  // Impl√©mentation de journalisation dans la console
  TConsoleLogger = class(TInterfacedObject, ILogger)
  public
    // Impl√©mentation ILogger
    procedure Log(const AMessage: string);
    procedure LogError(const AError: string);
  end;

  // Impl√©mentation de journalisation dans une base de donn√©es
  TDatabaseLogger = class(TInterfacedObject, ILogger)
  private
    FConnection: TDatabaseConnection;  // Hypoth√©tique
  public
    constructor Create(AConnection: TDatabaseConnection);

    // Impl√©mentation ILogger
    procedure Log(const AMessage: string);
    procedure LogError(const AError: string);
  end;

  // Notre application qui utilise la journalisation
  TMonApplication = class
  private
    FLogger: ILogger;
  public
    constructor Create(ALogger: ILogger);
    procedure Executer;
  end;

implementation

// Impl√©mentation de TFileLogger
constructor TFileLogger.Create(const AFileName: string);
begin
  inherited Create;
  FFileName := AFileName;
  AssignFile(FLogFile, FFileName);
  if FileExists(FFileName) then
    Append(FLogFile)
  else
    Rewrite(FLogFile);
end;

destructor TFileLogger.Destroy;
begin
  CloseFile(FLogFile);
  inherited;
end;

procedure TFileLogger.Log(const AMessage: string);
begin
  WriteLn(FLogFile, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' - INFO: ' + AMessage);
  Flush(FLogFile);
end;

procedure TFileLogger.LogError(const AError: string);
begin
  WriteLn(FLogFile, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' - ERROR: ' + AError);
  Flush(FLogFile);
end;

// Impl√©mentation de TConsoleLogger
procedure TConsoleLogger.Log(const AMessage: string);
begin
  WriteLn('INFO: ' + AMessage);
end;

procedure TConsoleLogger.LogError(const AError: string);
begin
  WriteLn('ERROR: ' + AError);
end;

// Impl√©mentation de TMonApplication
constructor TMonApplication.Create(ALogger: ILogger);
begin
  inherited Create;
  FLogger := ALogger;
end;

procedure TMonApplication.Executer;
begin
  FLogger.Log('Application d√©marr√©e');
  try
    // Code de l'application...
    FLogger.Log('Op√©ration r√©ussie');
  except
    on E: Exception do
      FLogger.LogError('Erreur: ' + E.Message);
  end;
  FLogger.Log('Application termin√©e');
end;
```

Utilisation :

```pascal
var
  FileLogger: ILogger;
  ConsoleLogger: ILogger;
  App1, App2: TMonApplication;
begin
  // Cr√©ation de diff√©rents types de loggers
  FileLogger := TFileLogger.Create('app.log');
  ConsoleLogger := TConsoleLogger.Create;

  // Cr√©ation de deux applications avec diff√©rents loggers
  App1 := TMonApplication.Create(FileLogger);
  App2 := TMonApplication.Create(ConsoleLogger);
  try
    App1.Executer;  // Journalise dans un fichier
    App2.Executer;  // Journalise dans la console
  finally
    App1.Free;
    App2.Free;
    // Pas besoin de lib√©rer FileLogger et ConsoleLogger (interfaces)
  end;
end;
```

L'avantage de cette approche est que vous pouvez facilement changer le syst√®me de journalisation sans modifier le code de l'application.

## TInterfacedObject

Delphi fournit une classe de base `TInterfacedObject` qui impl√©mente le comptage de r√©f√©rences pour vous :

```pascal
type
  TMyClass = class(TInterfacedObject, IMyInterface)
    // Impl√©mentation...
  end;
```

Cette classe g√®re automatiquement les m√©thodes `_AddRef` et `_Release` requises pour le comptage de r√©f√©rences.

## Bonnes pratiques

1. **Nommez clairement vos interfaces** :
   - Utilisez le pr√©fixe `I`
   - Choisissez des noms qui d√©crivent le r√¥le ou le comportement (`IComparable`, `IEnumerable`, `IDisposable`)

2. **Gardez les interfaces focalis√©es** :
   - Une interface devrait avoir une responsabilit√© unique
   - Pr√©f√©rez plusieurs petites interfaces plut√¥t qu'une grande

3. **Utilisez des GUID** :
   - Ajoutez toujours un GUID √† vos interfaces

4. **Attention au m√©lange objets/interfaces** :
   - √âvitez de m√©langer les r√©f√©rences d'objets et d'interfaces pour le m√™me objet
   - Si vous devez le faire, soyez conscient des pi√®ges li√©s au comptage de r√©f√©rences

5. **Utilisez des interfaces pour le d√©couplage** :
   - Les interfaces sont excellentes pour s√©parer les diff√©rentes parties de votre application
   - Elles facilitent les tests unitaires en permettant de remplacer facilement des impl√©mentations

---

Les interfaces constituent un outil puissant dans votre bo√Æte √† outils de programmation orient√©e objet en Delphi. Elles vous permettent de cr√©er des designs flexibles et extensibles, tout en profitant de la gestion automatique de la m√©moire gr√¢ce au comptage de r√©f√©rences. En ma√Ætrisant les interfaces, vous pourrez cr√©er des applications plus modulaires et plus faciles √† maintenir.

Dans la prochaine section, nous explorerons la g√©n√©ricit√©, qui vous permettra de cr√©er des classes et des m√©thodes travaillant avec diff√©rents types de donn√©es.

‚è≠Ô∏è [G√©n√©ricit√©](/03-langage-object-pascal/07.6-genericite.md)


