üîù Retour au [Sommaire](/SOMMAIRE.md)

# 3.7.5 Interfaces en Object Pascal

## Introduction

Les **interfaces** sont un concept avanc√© de la programmation orient√©e objet qui permet de d√©finir un "contrat" que les classes doivent respecter. Une interface d√©crit **ce qu'un objet peut faire** sans sp√©cifier **comment il le fait**.

## Qu'est-ce qu'une interface ?

Une **interface** est une d√©finition abstraite d'un ensemble de m√©thodes et de propri√©t√©s qu'une classe doit impl√©menter. C'est comme un cahier des charges ou un contrat.

### Analogie du monde r√©el

Imaginez une prise √©lectrique :
- L'**interface** = la forme standardis√©e de la prise (deux ou trois trous)
- Les **classes qui impl√©mentent** = les diff√©rents appareils (lampe, ordinateur, t√©l√©phone)
- Tous ces appareils sont diff√©rents mais peuvent se brancher sur la m√™me prise car ils respectent le m√™me "contrat"

### Diff√©rence entre classe et interface

| Classe | Interface |
|--------|-----------|
| Contient des donn√©es (champs) | Ne contient pas de donn√©es |
| Contient l'impl√©mentation des m√©thodes | D√©finit uniquement la signature des m√©thodes |
| Une classe peut h√©riter d'une seule classe | Une classe peut impl√©menter plusieurs interfaces |
| Peut √™tre instanci√©e | Ne peut PAS √™tre instanci√©e |

## D√©claration d'une interface

Une interface se d√©clare avec le mot-cl√© `interface` dans une d√©finition de type :

```pascal
type
  IDessinable = interface
    ['{3B8F9C12-5E4D-4A3B-9F2E-1C8D5A7B3F9E}']  // GUID
    procedure Dessiner;
    function ObtenirCouleur: string;
    procedure DefinirCouleur(const ACouleur: string);
  end;
```

### Points importants

1. **Nom** : par convention, les interfaces commencent par `I` (IDessinable, IComparable, etc.)
2. **GUID** : un identifiant unique global entre crochets (optionnel mais recommand√©)
3. **Pas d'impl√©mentation** : uniquement les signatures des m√©thodes
4. **Pas de visibilit√©** : tout est public par d√©faut

## G√©n√©rer un GUID

Dans l'IDE Delphi, utilisez **Ctrl+Shift+G** pour g√©n√©rer automatiquement un GUID. Vous pouvez aussi utiliser cette fonction :

```pascal
// Pour g√©n√©rer un GUID
uses System.SysUtils;

var
  MonGUID: TGUID;
begin
  CreateGUID(MonGUID);
  ShowMessage(GUIDToString(MonGUID));
end;
```

## Impl√©menter une interface

Une classe impl√©mente une interface en ajoutant le nom de l'interface apr√®s sa d√©claration :

```pascal
type
  // D√©claration de l'interface
  IDessinable = interface
    ['{3B8F9C12-5E4D-4A3B-9F2E-1C8D5A7B3F9E}']
    procedure Dessiner;
    function ObtenirCouleur: string;
    procedure DefinirCouleur(const ACouleur: string);
  end;

  // Classe qui impl√©mente l'interface
  TCercle = class(TInterfacedObject, IDessinable)
  private
    FRayon: Double;
    FCouleur: string;
  public
    constructor Create(ARayon: Double);

    // Impl√©mentation des m√©thodes de l'interface
    procedure Dessiner;
    function ObtenirCouleur: string;
    procedure DefinirCouleur(const ACouleur: string);

    property Rayon: Double read FRayon write FRayon;
  end;

constructor TCercle.Create(ARayon: Double);
begin
  inherited Create;
  FRayon := ARayon;
  FCouleur := 'noir';
end;

procedure TCercle.Dessiner;
begin
  ShowMessage(Format('Dessin d''un cercle %s de rayon %.2f',
                     [FCouleur, FRayon]));
end;

function TCercle.ObtenirCouleur: string;
begin
  Result := FCouleur;
end;

procedure TCercle.DefinirCouleur(const ACouleur: string);
begin
  FCouleur := ACouleur;
end;
```

### TInterfacedObject

`TInterfacedObject` est une classe de base qui g√®re automatiquement le comptage de r√©f√©rences des interfaces. C'est important pour la gestion m√©moire automatique des interfaces.

## Utilisation d'une interface

```pascal
var
  MonCercle: IDessinable;  // Variable de type interface
begin
  MonCercle := TCercle.Create(5);

  // Pas besoin de try...finally avec les interfaces !
  // La m√©moire est lib√©r√©e automatiquement

  MonCercle.DefinirCouleur('rouge');
  MonCercle.Dessiner;

  ShowMessage('Couleur : ' + MonCercle.ObtenirCouleur);

  // MonCercle sera automatiquement lib√©r√© √† la fin du bloc
end;
```

### Avantage : gestion m√©moire automatique

Avec les interfaces, vous n'avez **pas besoin** d'appeler `Free` ! La m√©moire est lib√©r√©e automatiquement gr√¢ce au comptage de r√©f√©rences.

## Interfaces multiples

Une classe peut impl√©menter plusieurs interfaces :

```pascal
type
  IDessinable = interface
    ['{3B8F9C12-5E4D-4A3B-9F2E-1C8D5A7B3F9E}']
    procedure Dessiner;
  end;

  IRedimensionnable = interface
    ['{7F2A4B8C-1D3E-4F5A-8B9C-2D4E6F8A1B3C}']
    procedure Agrandir(Facteur: Double);
    procedure Retrecir(Facteur: Double);
  end;

  IColorable = interface
    ['{9E4D7C2B-3A5F-4E8D-9C2A-5F7E9D3B8C4A}']
    function ObtenirCouleur: string;
    procedure DefinirCouleur(const ACouleur: string);
  end;

  // Classe impl√©mentant trois interfaces
  TRectangle = class(TInterfacedObject, IDessinable, IRedimensionnable, IColorable)
  private
    FLargeur: Double;
    FHauteur: Double;
    FCouleur: string;
  public
    constructor Create(ALargeur, AHauteur: Double);

    // M√©thodes de IDessinable
    procedure Dessiner;

    // M√©thodes de IRedimensionnable
    procedure Agrandir(Facteur: Double);
    procedure Retrecir(Facteur: Double);

    // M√©thodes de IColorable
    function ObtenirCouleur: string;
    procedure DefinirCouleur(const ACouleur: string);
  end;

constructor TRectangle.Create(ALargeur, AHauteur: Double);
begin
  inherited Create;
  FLargeur := ALargeur;
  FHauteur := AHauteur;
  FCouleur := 'bleu';
end;

procedure TRectangle.Dessiner;
begin
  ShowMessage(Format('Rectangle %s : %.2f x %.2f',
                     [FCouleur, FLargeur, FHauteur]));
end;

procedure TRectangle.Agrandir(Facteur: Double);
begin
  FLargeur := FLargeur * Facteur;
  FHauteur := FHauteur * Facteur;
end;

procedure TRectangle.Retrecir(Facteur: Double);
begin
  Agrandir(1 / Facteur);
end;

function TRectangle.ObtenirCouleur: string;
begin
  Result := FCouleur;
end;

procedure TRectangle.DefinirCouleur(const ACouleur: string);
begin
  FCouleur := ACouleur;
end;
```

### Utilisation avec plusieurs interfaces

```pascal
var
  MonRectangle: TRectangle;
  Dessinable: IDessinable;
  Redimensionnable: IRedimensionnable;
  Colorable: IColorable;
begin
  MonRectangle := TRectangle.Create(10, 5);
  try
    // Utilisation directe
    MonRectangle.Dessiner;

    // Affectation √† une variable d'interface
    Dessinable := MonRectangle;
    Dessinable.Dessiner;

    Redimensionnable := MonRectangle;
    Redimensionnable.Agrandir(2);

    Colorable := MonRectangle;
    Colorable.DefinirCouleur('vert');

    MonRectangle.Dessiner;
  finally
    MonRectangle.Free;
  end;
end;
```

## L'op√©rateur Supports

L'op√©rateur `Supports` v√©rifie si un objet impl√©mente une interface donn√©e :

```pascal
var
  MonObjet: TObject;
  Dessinable: IDessinable;
begin
  MonObjet := TRectangle.Create(10, 5);
  try
    // V√©rifier si l'objet supporte l'interface
    if Supports(MonObjet, IDessinable, Dessinable) then
    begin
      ShowMessage('L''objet peut √™tre dessin√©');
      Dessinable.Dessiner;
    end
    else
      ShowMessage('L''objet ne peut pas √™tre dessin√©');

  finally
    MonObjet.Free;
  end;
end;
```

## L'op√©rateur as avec les interfaces

On peut aussi utiliser `as` pour convertir vers une interface :

```pascal
var
  MonRectangle: TRectangle;
  Dessinable: IDessinable;
begin
  MonRectangle := TRectangle.Create(10, 5);
  try
    // Conversion vers l'interface
    Dessinable := MonRectangle as IDessinable;
    Dessinable.Dessiner;

  finally
    MonRectangle.Free;
  end;
end;
```

## H√©ritage d'interfaces

Les interfaces peuvent h√©riter d'autres interfaces :

```pascal
type
  IAnimal = interface
    ['{1A2B3C4D-5E6F-7A8B-9C0D-1E2F3A4B5C6D}']
    procedure SeNourrir;
    procedure Dormir;
  end;

  IAnimalDomestique = interface(IAnimal)  // H√©rite de IAnimal
    ['{7F8E9D0C-1B2A-3D4E-5F6A-7B8C9D0E1F2A}']
    procedure Caresser;
    procedure Nommer(const ANom: string);
  end;

  TChien = class(TInterfacedObject, IAnimalDomestique)
  private
    FNom: string;
  public
    // M√©thodes de IAnimal
    procedure SeNourrir;
    procedure Dormir;

    // M√©thodes de IAnimalDomestique
    procedure Caresser;
    procedure Nommer(const ANom: string);
  end;

procedure TChien.SeNourrir;
begin
  ShowMessage(FNom + ' mange des croquettes');
end;

procedure TChien.Dormir;
begin
  ShowMessage(FNom + ' dort dans son panier');
end;

procedure TChien.Caresser;
begin
  ShowMessage(FNom + ' remue la queue de joie !');
end;

procedure TChien.Nommer(const ANom: string);
begin
  FNom := ANom;
end;
```

## Exemple pratique : Plugin System

Les interfaces sont parfaites pour cr√©er des syst√®mes de plugins :

```pascal
type
  // Interface commune √† tous les plugins
  IPlugin = interface
    ['{8D3E4F5A-6B7C-8D9E-0F1A-2B3C4D5E6F7A}']
    function ObtenirNom: string;
    function ObtenirVersion: string;
    procedure Initialiser;
    procedure Executer;
    procedure Terminer;
  end;

  // Plugin de sauvegarde
  TPluginSauvegarde = class(TInterfacedObject, IPlugin)
  public
    function ObtenirNom: string;
    function ObtenirVersion: string;
    procedure Initialiser;
    procedure Executer;
    procedure Terminer;
  end;

  // Plugin d'export
  TPluginExport = class(TInterfacedObject, IPlugin)
  public
    function ObtenirNom: string;
    function ObtenirVersion: string;
    procedure Initialiser;
    procedure Executer;
    procedure Terminer;
  end;

// Impl√©mentation TPluginSauvegarde

function TPluginSauvegarde.ObtenirNom: string;
begin
  Result := 'Plugin de sauvegarde';
end;

function TPluginSauvegarde.ObtenirVersion: string;
begin
  Result := '1.0';
end;

procedure TPluginSauvegarde.Initialiser;
begin
  ShowMessage('Initialisation du plugin de sauvegarde');
end;

procedure TPluginSauvegarde.Executer;
begin
  ShowMessage('Sauvegarde des donn√©es...');
end;

procedure TPluginSauvegarde.Terminer;
begin
  ShowMessage('Plugin de sauvegarde termin√©');
end;

// Impl√©mentation TPluginExport

function TPluginExport.ObtenirNom: string;
begin
  Result := 'Plugin d''export';
end;

function TPluginExport.ObtenirVersion: string;
begin
  Result := '2.0';
end;

procedure TPluginExport.Initialiser;
begin
  ShowMessage('Initialisation du plugin d''export');
end;

procedure TPluginExport.Executer;
begin
  ShowMessage('Export des donn√©es vers Excel...');
end;

procedure TPluginExport.Terminer;
begin
  ShowMessage('Plugin d''export termin√©');
end;
```

### Gestionnaire de plugins

```pascal
type
  TGestionnairePlugins = class
  private
    FPlugins: TList<IPlugin>;
  public
    constructor Create;
    destructor Destroy; override;
    procedure AjouterPlugin(Plugin: IPlugin);
    procedure ExecuterTousLesPlugins;
  end;

constructor TGestionnairePlugins.Create;
begin
  inherited Create;
  FPlugins := TList<IPlugin>.Create;
end;

destructor TGestionnairePlugins.Destroy;
begin
  FPlugins.Free;
  inherited Destroy;
end;

procedure TGestionnairePlugins.AjouterPlugin(Plugin: IPlugin);
begin
  FPlugins.Add(Plugin);
end;

procedure TGestionnairePlugins.ExecuterTousLesPlugins;
var
  Plugin: IPlugin;
begin
  for Plugin in FPlugins do
  begin
    ShowMessage(Format('Plugin : %s (v%s)',
                       [Plugin.ObtenirNom, Plugin.ObtenirVersion]));
    Plugin.Initialiser;
    Plugin.Executer;
    Plugin.Terminer;
  end;
end;
```

### Utilisation

```pascal
var
  Gestionnaire: TGestionnairePlugins;
begin
  Gestionnaire := TGestionnairePlugins.Create;
  try
    // Ajouter des plugins
    Gestionnaire.AjouterPlugin(TPluginSauvegarde.Create);
    Gestionnaire.AjouterPlugin(TPluginExport.Create);

    // Ex√©cuter tous les plugins
    Gestionnaire.ExecuterTousLesPlugins;
  finally
    Gestionnaire.Free;
  end;
end;
```

## Interfaces et propri√©t√©s

Les interfaces peuvent d√©clarer des propri√©t√©s avec des getters et setters :

```pascal
type
  IPersonne = interface
    ['{2C4D6E8F-1A3B-5C7D-9E0F-1A2B3C4D5E6F}']
    function GetNom: string;
    procedure SetNom(const Value: string);
    function GetAge: Integer;
    procedure SetAge(const Value: Integer);

    property Nom: string read GetNom write SetNom;
    property Age: Integer read GetAge write SetAge;
  end;

  TPersonne = class(TInterfacedObject, IPersonne)
  private
    FNom: string;
    FAge: Integer;
    function GetNom: string;
    procedure SetNom(const Value: string);
    function GetAge: Integer;
    procedure SetAge(const Value: Integer);
  public
    property Nom: string read GetNom write SetNom;
    property Age: Integer read GetAge write SetAge;
  end;

function TPersonne.GetNom: string;
begin
  Result := FNom;
end;

procedure TPersonne.SetNom(const Value: string);
begin
  FNom := Value;
end;

function TPersonne.GetAge: Integer;
begin
  Result := FAge;
end;

procedure TPersonne.SetAge(const Value: Integer);
begin
  if (Value >= 0) and (Value <= 150) then
    FAge := Value;
end;
```

### Utilisation

```pascal
var
  Personne: IPersonne;
begin
  Personne := TPersonne.Create;

  Personne.Nom := 'Marie Dupont';
  Personne.Age := 30;

  ShowMessage(Format('%s a %d ans', [Personne.Nom, Personne.Age]));

  // Lib√©ration automatique
end;
```

## D√©l√©gation d'interface

Delphi permet de d√©l√©guer l'impl√©mentation d'une interface √† un champ avec le mot-cl√© `implements` :

```pascal
type
  ICalculatrice = interface
    ['{5A6B7C8D-9E0F-1A2B-3C4D-5E6F7A8B9C0D}']
    function Additionner(A, B: Integer): Integer;
    function Soustraire(A, B: Integer): Integer;
  end;

  TMoteurCalcul = class(TInterfacedObject, ICalculatrice)
  public
    function Additionner(A, B: Integer): Integer;
    function Soustraire(A, B: Integer): Integer;
  end;

  // Classe qui d√©l√®gue l'interface
  TCalculatriceScientifique = class(TInterfacedObject, ICalculatrice)
  private
    FMoteur: ICalculatrice;  // D√©l√©gation √† ce champ
  public
    constructor Create;
    property Moteur: ICalculatrice read FMoteur implements ICalculatrice;
  end;

function TMoteurCalcul.Additionner(A, B: Integer): Integer;
begin
  Result := A + B;
end;

function TMoteurCalcul.Soustraire(A, B: Integer): Integer;
begin
  Result := A - B;
end;

constructor TCalculatriceScientifique.Create;
begin
  inherited Create;
  FMoteur := TMoteurCalcul.Create;
end;
```

## Interfaces vs Classes abstraites

| Crit√®re | Interface | Classe abstraite |
|---------|-----------|------------------|
| H√©ritage multiple | ‚úÖ Oui | ‚ùå Non (h√©ritage simple uniquement) |
| Impl√©mentation | ‚ùå Aucune | ‚úÖ Peut avoir des m√©thodes impl√©ment√©es |
| Champs/donn√©es | ‚ùå Non | ‚úÖ Oui |
| Gestion m√©moire | ‚úÖ Automatique | ‚ùå Manuelle (Free) |
| Flexibilit√© | ‚úÖ Plus flexible | ‚ö†Ô∏è Moins flexible |
| Performance | ‚ö†Ô∏è L√©g√®rement plus lent | ‚úÖ Plus rapide |

### Quand utiliser une interface ?

- Vous avez besoin d'impl√©menter plusieurs "contrats"
- Vous voulez la gestion m√©moire automatique
- Vous cr√©ez un syst√®me de plugins
- Vous voulez maximiser la flexibilit√©

### Quand utiliser une classe abstraite ?

- Vous voulez partager du code commun entre classes
- Vous avez des donn√©es √† stocker
- L'h√©ritage simple suffit
- La performance est critique

## Exemple complet : Syst√®me de notification

```pascal
type
  // Interface de notification
  INotification = interface
    ['{9B8C7D6E-5F4A-3B2C-1D0E-9F8A7B6C5D4E}']
    procedure Envoyer(const AMessage: string);
    function EstDisponible: Boolean;
  end;

  // Notification par email
  TNotificationEmail = class(TInterfacedObject, INotification)
  private
    FAdresseEmail: string;
  public
    constructor Create(const AEmail: string);
    procedure Envoyer(const AMessage: string);
    function EstDisponible: Boolean;
  end;

  // Notification par SMS
  TNotificationSMS = class(TInterfacedObject, INotification)
  private
    FNumeroTelephone: string;
  public
    constructor Create(const ANumero: string);
    procedure Envoyer(const AMessage: string);
    function EstDisponible: Boolean;
  end;

  // Notification push
  TNotificationPush = class(TInterfacedObject, INotification)
  private
    FDeviceToken: string;
  public
    constructor Create(const AToken: string);
    procedure Envoyer(const AMessage: string);
    function EstDisponible: Boolean;
  end;

  // Gestionnaire de notifications
  TGestionnaireNotifications = class
  private
    FNotifications: TList<INotification>;
  public
    constructor Create;
    destructor Destroy; override;
    procedure AjouterCanal(Notification: INotification);
    procedure DiffuserMessage(const AMessage: string);
  end;

// Impl√©mentation TNotificationEmail

constructor TNotificationEmail.Create(const AEmail: string);
begin
  inherited Create;
  FAdresseEmail := AEmail;
end;

procedure TNotificationEmail.Envoyer(const AMessage: string);
begin
  ShowMessage(Format('Email envoy√© √† %s : %s', [FAdresseEmail, AMessage]));
end;

function TNotificationEmail.EstDisponible: Boolean;
begin
  Result := FAdresseEmail <> '';
end;

// Impl√©mentation TNotificationSMS

constructor TNotificationSMS.Create(const ANumero: string);
begin
  inherited Create;
  FNumeroTelephone := ANumero;
end;

procedure TNotificationSMS.Envoyer(const AMessage: string);
begin
  ShowMessage(Format('SMS envoy√© au %s : %s', [FNumeroTelephone, AMessage]));
end;

function TNotificationSMS.EstDisponible: Boolean;
begin
  Result := FNumeroTelephone <> '';
end;

// Impl√©mentation TNotificationPush

constructor TNotificationPush.Create(const AToken: string);
begin
  inherited Create;
  FDeviceToken := AToken;
end;

procedure TNotificationPush.Envoyer(const AMessage: string);
begin
  ShowMessage(Format('Notification push envoy√©e : %s', [AMessage]));
end;

function TNotificationPush.EstDisponible: Boolean;
begin
  Result := FDeviceToken <> '';
end;

// Impl√©mentation TGestionnaireNotifications

constructor TGestionnaireNotifications.Create;
begin
  inherited Create;
  FNotifications := TList<INotification>.Create;
end;

destructor TGestionnaireNotifications.Destroy;
begin
  FNotifications.Free;
  inherited Destroy;
end;

procedure TGestionnaireNotifications.AjouterCanal(Notification: INotification);
begin
  FNotifications.Add(Notification);
end;

procedure TGestionnaireNotifications.DiffuserMessage(const AMessage: string);
var
  Notification: INotification;
begin
  for Notification in FNotifications do
  begin
    if Notification.EstDisponible then
      Notification.Envoyer(AMessage);
  end;
end;
```

### Utilisation du syst√®me de notification

```pascal
var
  Gestionnaire: TGestionnaireNotifications;
begin
  Gestionnaire := TGestionnaireNotifications.Create;
  try
    // Ajouter diff√©rents canaux de notification
    Gestionnaire.AjouterCanal(TNotificationEmail.Create('user@example.com'));
    Gestionnaire.AjouterCanal(TNotificationSMS.Create('+33612345678'));
    Gestionnaire.AjouterCanal(TNotificationPush.Create('device-token-123'));

    // Diffuser un message sur tous les canaux
    Gestionnaire.DiffuserMessage('Votre commande a √©t√© exp√©di√©e !');
  finally
    Gestionnaire.Free;
  end;
end;
```

## Bonnes pratiques

### 1. Pr√©fixez les interfaces par "I"

```pascal
// ‚úÖ Bon
IDessinable, IComparable, INotification

// ‚ùå Mauvais
Dessinable, Comparable, Notification
```

### 2. Utilisez toujours des GUID

```pascal
// ‚úÖ Bon
IMonInterface = interface
  ['{3B8F9C12-5E4D-4A3B-9F2E-1C8D5A7B3F9E}']
  ...
end;

// ‚ö†Ô∏è Fonctionne mais d√©conseill√©
IMonInterface = interface
  ...
end;
```

### 3. H√©ritez de TInterfacedObject pour la gestion m√©moire automatique

```pascal
// ‚úÖ Bon
TMaClasse = class(TInterfacedObject, IMonInterface)

// ‚ö†Ô∏è Possible mais n√©cessite une gestion manuelle
TMaClasse = class(TObject, IMonInterface)
```

### 4. Gardez les interfaces simples et focalis√©es

```pascal
// ‚úÖ Bon - interfaces simples et sp√©cifiques
ILisible = interface
  procedure Lire;
end;

IEcrivable = interface
  procedure Ecrire;
end;

// ‚ùå √âviter - interface trop large
IFichier = interface
  procedure Lire;
  procedure Ecrire;
  procedure Copier;
  procedure Deplacer;
  procedure Supprimer;
  procedure Renommer;
  // ... trop de responsabilit√©s
end;
```

### 5. Pr√©f√©rez les interfaces pour les d√©pendances

```pascal
// ‚úÖ Bon - d√©pend d'une interface
procedure TraiterDonnees(Source: ISourceDonnees);

// ‚ö†Ô∏è Moins flexible - d√©pend d'une classe concr√®te
procedure TraiterDonnees(Source: TBaseDonnees);
```

## R√©sum√©

- **Interface** = contrat d√©finissant ce qu'une classe doit faire
  - Syntaxe : `interface` avec un GUID
  - Nom conventionnel : pr√©fixe `I`
  - Pas d'impl√©mentation, uniquement des signatures

- **Impl√©mentation**
  - Une classe peut impl√©menter plusieurs interfaces
  - H√©riter de `TInterfacedObject` pour la gestion m√©moire automatique
  - Toutes les m√©thodes de l'interface doivent √™tre impl√©ment√©es

- **Avantages**
  - H√©ritage multiple
  - Gestion m√©moire automatique
  - Flexibilit√© et d√©couplage
  - Parfait pour les syst√®mes de plugins

- **Op√©rateurs**
  - `Supports` : v√©rifier si un objet impl√©mente une interface
  - `as` : convertir vers une interface
  - `implements` : d√©l√©guer l'impl√©mentation

- **Utilisation**
  - Syst√®mes de plugins
  - Injection de d√©pendances
  - Architecture d√©coupl√©e
  - Contrats entre modules

Les interfaces sont un outil puissant pour cr√©er du code flexible, testable et maintenable. Elles favorisent le principe de programmation "contre une abstraction" plut√¥t que "contre une impl√©mentation".

‚è≠Ô∏è [G√©n√©ricit√©](/03-langage-object-pascal/07.6-genericite.md)
