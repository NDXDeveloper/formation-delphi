üîù Retour au [Sommaire](/SOMMAIRE.md)

# 3.7.6 G√©n√©ricit√© en Object Pascal

## Introduction

La **g√©n√©ricit√©** (ou **generics** en anglais) est un m√©canisme qui permet de cr√©er des classes, des m√©thodes et des types qui peuvent fonctionner avec diff√©rents types de donn√©es sans avoir √† r√©√©crire le code pour chaque type.

## Pourquoi utiliser la g√©n√©ricit√© ?

### Le probl√®me sans g√©n√©ricit√©

Imaginez que vous voulez cr√©er une liste pour stocker des entiers :

```pascal
type
  TListeEntiers = class
  private
    FItems: array of Integer;
  public
    procedure Ajouter(Item: Integer);
    function Obtenir(Index: Integer): Integer;
  end;
```

Maintenant vous voulez une liste pour des cha√Ænes de caract√®res. Il faut cr√©er une autre classe :

```pascal
type
  TListeChaines = class
  private
    FItems: array of string;
  public
    procedure Ajouter(Item: string);
    function Obtenir(Index: Integer): string;
  end;
```

Et pour des personnes, encore une autre classe :

```pascal
type
  TListePersonnes = class
  private
    FItems: array of TPersonne;
  public
    procedure Ajouter(Item: TPersonne);
    function Obtenir(Index: Integer): TPersonne;
  end;
```

**Probl√®me** : Beaucoup de duplication de code !

### La solution avec g√©n√©ricit√©

Avec la g√©n√©ricit√©, vous cr√©ez **une seule classe** qui fonctionne avec n'importe quel type :

```pascal
type
  TListe<T> = class
  private
    FItems: array of T;
  public
    procedure Ajouter(Item: T);
    function Obtenir(Index: Integer): T;
  end;
```

Le `<T>` signifie "type g√©n√©rique". `T` est un **param√®tre de type** qui sera remplac√© par le type r√©el lors de l'utilisation.

## Analogie du monde r√©el

Pensez √† un **moule √† g√¢teau en silicone** :
- Le moule peut faire des g√¢teaux au chocolat, √† la vanille, aux fruits...
- C'est toujours le **m√™me moule** (la classe g√©n√©rique)
- Mais le **contenu change** (le type T)
- Vous n'avez pas besoin d'un moule diff√©rent pour chaque saveur !

## D√©claration d'une classe g√©n√©rique

### Syntaxe de base

```pascal
type
  TMaClasse<T> = class
  private
    FValeur: T;
  public
    constructor Create(AValeur: T);
    function ObtenirValeur: T;
    procedure DefinirValeur(AValeur: T);
    property Valeur: T read FValeur write FValeur;
  end;
```

### Impl√©mentation

```pascal
constructor TMaClasse<T>.Create(AValeur: T);
begin
  inherited Create;
  FValeur := AValeur;
end;

function TMaClasse<T>.ObtenirValeur: T;
begin
  Result := FValeur;
end;

procedure TMaClasse<T>.DefinirValeur(AValeur: T);
begin
  FValeur := AValeur;
end;
```

### Utilisation

```pascal
var
  ConteneurEntier: TMaClasse<Integer>;
  ConteneurChaine: TMaClasse<string>;
  ConteneurDouble: TMaClasse<Double>;
begin
  // Cr√©er un conteneur d'entiers
  ConteneurEntier := TMaClasse<Integer>.Create(42);
  try
    ShowMessage('Valeur enti√®re : ' + IntToStr(ConteneurEntier.Valeur));
  finally
    ConteneurEntier.Free;
  end;

  // Cr√©er un conteneur de cha√Ænes
  ConteneurChaine := TMaClasse<string>.Create('Bonjour');
  try
    ShowMessage('Valeur cha√Æne : ' + ConteneurChaine.Valeur);
  finally
    ConteneurChaine.Free;
  end;

  // Cr√©er un conteneur de doubles
  ConteneurDouble := TMaClasse<Double>.Create(3.14);
  try
    ShowMessage('Valeur double : ' + FloatToStr(ConteneurDouble.Valeur));
  finally
    ConteneurDouble.Free;
  end;
end;
```

## Exemple pratique : Pile g√©n√©rique

Une pile (stack) est une structure de donn√©es LIFO (Last In, First Out - dernier entr√©, premier sorti).

```pascal
type
  TPile<T> = class
  private
    FItems: array of T;
    FCount: Integer;
  public
    constructor Create;
    procedure Empiler(Item: T);
    function Depiler: T;
    function EstVide: Boolean;
    function Sommet: T;
    property Count: Integer read FCount;
  end;

constructor TPile<T>.Create;
begin
  inherited Create;
  SetLength(FItems, 0);
  FCount := 0;
end;

procedure TPile<T>.Empiler(Item: T);
begin
  Inc(FCount);
  SetLength(FItems, FCount);
  FItems[FCount - 1] := Item;
end;

function TPile<T>.Depiler: T;
begin
  if EstVide then
    raise Exception.Create('La pile est vide');

  Result := FItems[FCount - 1];
  Dec(FCount);
  SetLength(FItems, FCount);
end;

function TPile<T>.EstVide: Boolean;
begin
  Result := (FCount = 0);
end;

function TPile<T>.Sommet: T;
begin
  if EstVide then
    raise Exception.Create('La pile est vide');

  Result := FItems[FCount - 1];
end;
```

### Utilisation de la pile g√©n√©rique

```pascal
var
  PileEntiers: TPile<Integer>;
  PileChaines: TPile<string>;
begin
  // Pile d'entiers
  PileEntiers := TPile<Integer>.Create;
  try
    PileEntiers.Empiler(10);
    PileEntiers.Empiler(20);
    PileEntiers.Empiler(30);

    ShowMessage('Sommet : ' + IntToStr(PileEntiers.Sommet));  // 30
    ShowMessage('D√©piler : ' + IntToStr(PileEntiers.Depiler));  // 30
    ShowMessage('Nouveau sommet : ' + IntToStr(PileEntiers.Sommet));  // 20
  finally
    PileEntiers.Free;
  end;

  // Pile de cha√Ænes
  PileChaines := TPile<string>.Create;
  try
    PileChaines.Empiler('Premier');
    PileChaines.Empiler('Deuxi√®me');
    PileChaines.Empiler('Troisi√®me');

    while not PileChaines.EstVide do
      ShowMessage(PileChaines.Depiler);
  finally
    PileChaines.Free;
  end;
end;
```

## Plusieurs param√®tres de type

Une classe peut avoir plusieurs param√®tres de type :

```pascal
type
  TPaire<TKey, TValue> = class
  private
    FCle: TKey;
    FValeur: TValue;
  public
    constructor Create(ACle: TKey; AValeur: TValue);
    property Cle: TKey read FCle write FCle;
    property Valeur: TValue read FValeur write FValeur;
  end;

constructor TPaire<TKey, TValue>.Create(ACle: TKey; AValeur: TValue);
begin
  inherited Create;
  FCle := ACle;
  FValeur := AValeur;
end;
```

### Utilisation

```pascal
var
  PaireEntierChaine: TPaire<Integer, string>;
  PaireChaineBooleen: TPaire<string, Boolean>;
begin
  // Paire Integer-String
  PaireEntierChaine := TPaire<Integer, string>.Create(1, 'Premier');
  try
    ShowMessage(Format('Cl√© : %d, Valeur : %s',
                       [PaireEntierChaine.Cle, PaireEntierChaine.Valeur]));
  finally
    PaireEntierChaine.Free;
  end;

  // Paire String-Boolean
  PaireChaineBooleen := TPaire<string, Boolean>.Create('Actif', True);
  try
    if PaireChaineBooleen.Valeur then
      ShowMessage(PaireChaineBooleen.Cle + ' est actif');
  finally
    PaireChaineBooleen.Free;
  end;
end;
```

## Contraintes de type

Parfois, vous voulez restreindre les types qui peuvent √™tre utilis√©s avec votre classe g√©n√©rique. C'est ce qu'on appelle les **contraintes**.

### Types de contraintes

```pascal
type
  // T doit √™tre une classe
  TMaClasse1<T: class> = class
  end;

  // T doit √™tre un record
  TMaClasse2<T: record> = class
  end;

  // T doit avoir un constructeur sans param√®tres
  TMaClasse3<T: constructor> = class
  end;

  // T doit descendre de TStream
  TMaClasse4<T: TStream> = class
  end;

  // Plusieurs contraintes
  TMaClasse5<T: class, constructor> = class
  end;
```

### Exemple avec contrainte

```pascal
type
  // TFactory peut cr√©er n'importe quelle classe avec un constructeur
  TFactory<T: class, constructor> = class
  public
    class function Creer: T;
  end;

class function TFactory<T>.Creer: T;
begin
  Result := T.Create;  // Possible car T a la contrainte 'constructor'
end;
```

### Utilisation

```pascal
type
  TPersonne = class
  public
    Nom: string;
    constructor Create;
  end;

constructor TPersonne.Create;
begin
  inherited Create;
  Nom := 'Sans nom';
end;

var
  Factory: TFactory<TPersonne>;
  Personne: TPersonne;
begin
  Personne := TFactory<TPersonne>.Creer;
  try
    ShowMessage('Nom : ' + Personne.Nom);
  finally
    Personne.Free;
  end;
end;
```

## M√©thodes g√©n√©riques

Les m√©thodes peuvent aussi √™tre g√©n√©riques, ind√©pendamment de leur classe :

```pascal
type
  TUtilitaires = class
  public
    class function Max<T>(A, B: T): T;
    class function Min<T>(A, B: T): T;
    class procedure Echanger<T>(var A, B: T);
  end;

class function TUtilitaires.Max<T>(A, B: T): T;
var
  Comparer: IComparer<T>;
begin
  Comparer := TComparer<T>.Default;
  if Comparer.Compare(A, B) > 0 then
    Result := A
  else
    Result := B;
end;

class function TUtilitaires.Min<T>(A, B: T): T;
var
  Comparer: IComparer<T>;
begin
  Comparer := TComparer<T>.Default;
  if Comparer.Compare(A, B) < 0 then
    Result := A
  else
    Result := B;
end;

class procedure TUtilitaires.Echanger<T>(var A, B: T);
var
  Temp: T;
begin
  Temp := A;
  A := B;
  B := Temp;
end;
```

### Utilisation des m√©thodes g√©n√©riques

```pascal
var
  X, Y: Integer;
  Nom1, Nom2: string;
  Prix1, Prix2: Double;
begin
  // Avec des entiers
  X := 10;
  Y := 20;
  ShowMessage('Max : ' + IntToStr(TUtilitaires.Max<Integer>(X, Y)));  // 20

  TUtilitaires.Echanger<Integer>(X, Y);
  ShowMessage(Format('Apr√®s √©change : X=%d, Y=%d', [X, Y]));  // X=20, Y=10

  // Avec des cha√Ænes
  Nom1 := 'Alice';
  Nom2 := 'Bob';
  ShowMessage('Max : ' + TUtilitaires.Max<string>(Nom1, Nom2));  // Bob

  // Avec des doubles
  Prix1 := 19.99;
  Prix2 := 24.99;
  ShowMessage('Min : ' + FloatToStr(TUtilitaires.Min<Double>(Prix1, Prix2)));  // 19.99
end;
```

## Collections g√©n√©riques de Delphi

Delphi fournit des collections g√©n√©riques pr√™tes √† l'emploi dans l'unit√© `System.Generics.Collections` :

### TList<T> - Liste dynamique

```pascal
uses System.Generics.Collections;

var
  ListeNombres: TList<Integer>;
  ListeNoms: TList<string>;
  Nombre: Integer;
  Nom: string;
begin
  // Liste d'entiers
  ListeNombres := TList<Integer>.Create;
  try
    ListeNombres.Add(10);
    ListeNombres.Add(20);
    ListeNombres.Add(30);

    for Nombre in ListeNombres do
      ShowMessage(IntToStr(Nombre));

    ShowMessage('Premier √©l√©ment : ' + IntToStr(ListeNombres[0]));
    ShowMessage('Nombre d''√©l√©ments : ' + IntToStr(ListeNombres.Count));
  finally
    ListeNombres.Free;
  end;

  // Liste de cha√Ænes
  ListeNoms := TList<string>.Create;
  try
    ListeNoms.Add('Alice');
    ListeNoms.Add('Bob');
    ListeNoms.Add('Charlie');

    for Nom in ListeNoms do
      ShowMessage(Nom);

    ListeNoms.Sort;  // Tri automatique

    if ListeNoms.Contains('Bob') then
      ShowMessage('Bob est dans la liste');
  finally
    ListeNoms.Free;
  end;
end;
```

### TDictionary<TKey, TValue> - Dictionnaire

Un dictionnaire stocke des paires cl√©-valeur :

```pascal
uses System.Generics.Collections;

var
  Ages: TDictionary<string, Integer>;
  Paire: TPair<string, Integer>;
begin
  Ages := TDictionary<string, Integer>.Create;
  try
    // Ajouter des √©l√©ments
    Ages.Add('Alice', 25);
    Ages.Add('Bob', 30);
    Ages.Add('Charlie', 28);

    // Acc√©der √† une valeur
    ShowMessage('√Çge de Bob : ' + IntToStr(Ages['Bob']));

    // V√©rifier l'existence d'une cl√©
    if Ages.ContainsKey('Alice') then
      ShowMessage('Alice est pr√©sente');

    // Parcourir le dictionnaire
    for Paire in Ages do
      ShowMessage(Format('%s a %d ans', [Paire.Key, Paire.Value]));

    // Modifier une valeur
    Ages['Bob'] := 31;

    // Supprimer un √©l√©ment
    Ages.Remove('Charlie');

  finally
    Ages.Free;
  end;
end;
```

### TObjectList<T> - Liste d'objets avec gestion automatique

```pascal
uses System.Generics.Collections;

type
  TPersonne = class
  public
    Nom: string;
    Age: Integer;
    constructor Create(ANom: string; AAge: Integer);
  end;

constructor TPersonne.Create(ANom: string; AAge: Integer);
begin
  inherited Create;
  Nom := ANom;
  Age := AAge;
end;

var
  Personnes: TObjectList<TPersonne>;
  Personne: TPersonne;
begin
  // TObjectList lib√®re automatiquement les objets !
  Personnes := TObjectList<TPersonne>.Create(True);  // True = OwnsObjects
  try
    Personnes.Add(TPersonne.Create('Alice', 25));
    Personnes.Add(TPersonne.Create('Bob', 30));
    Personnes.Add(TPersonne.Create('Charlie', 28));

    for Personne in Personnes do
      ShowMessage(Format('%s a %d ans', [Personne.Nom, Personne.Age]));

    // Les objets seront automatiquement lib√©r√©s !
  finally
    Personnes.Free;  // Lib√®re la liste ET tous les objets qu'elle contient
  end;
end;
```

### TQueue<T> - File (FIFO)

```pascal
uses System.Generics.Collections;

var
  File: TQueue<string>;
begin
  File := TQueue<string>.Create;
  try
    // Ajouter des √©l√©ments
    File.Enqueue('Premier');
    File.Enqueue('Deuxi√®me');
    File.Enqueue('Troisi√®me');

    // Retirer dans l'ordre FIFO (First In, First Out)
    while File.Count > 0 do
      ShowMessage(File.Dequeue);

    // Affichera : Premier, Deuxi√®me, Troisi√®me
  finally
    File.Free;
  end;
end;
```

### TStack<T> - Pile (LIFO)

```pascal
uses System.Generics.Collections;

var
  Pile: TStack<Integer>;
begin
  Pile := TStack<Integer>.Create;
  try
    // Empiler des √©l√©ments
    Pile.Push(10);
    Pile.Push(20);
    Pile.Push(30);

    // D√©piler dans l'ordre LIFO (Last In, First Out)
    while Pile.Count > 0 do
      ShowMessage(IntToStr(Pile.Pop));

    // Affichera : 30, 20, 10
  finally
    Pile.Free;
  end;
end;
```

## Exemple complet : Gestionnaire de cache g√©n√©rique

```pascal
uses System.Generics.Collections;

type
  TCache<TKey, TValue> = class
  private
    FDonnees: TDictionary<TKey, TValue>;
    FCapaciteMax: Integer;
  public
    constructor Create(ACapacite: Integer);
    destructor Destroy; override;
    procedure Ajouter(Cle: TKey; Valeur: TValue);
    function Obtenir(Cle: TKey): TValue;
    function Existe(Cle: TKey): Boolean;
    procedure Supprimer(Cle: TKey);
    procedure Vider;
    property Count: Integer read GetCount;
  private
    function GetCount: Integer;
  end;

constructor TCache<TKey, TValue>.Create(ACapacite: Integer);
begin
  inherited Create;
  FDonnees := TDictionary<TKey, TValue>.Create;
  FCapaciteMax := ACapacite;
end;

destructor TCache<TKey, TValue>.Destroy;
begin
  FDonnees.Free;
  inherited Destroy;
end;

procedure TCache<TKey, TValue>.Ajouter(Cle: TKey; Valeur: TValue);
begin
  // Si le cache est plein, supprimer le premier √©l√©ment
  if FDonnees.Count >= FCapaciteMax then
  begin
    // Simplification : supprimer un √©l√©ment al√©atoire
    // En pratique, on impl√©menterait LRU (Least Recently Used)
    var PremiereCle := FDonnees.Keys.ToArray[0];
    FDonnees.Remove(PremiereCle);
  end;

  FDonnees.AddOrSetValue(Cle, Valeur);
end;

function TCache<TKey, TValue>.Obtenir(Cle: TKey): TValue;
begin
  if not FDonnees.TryGetValue(Cle, Result) then
    raise Exception.CreateFmt('Cl√© non trouv√©e : %s', [TValue.From<TKey>(Cle).ToString]);
end;

function TCache<TKey, TValue>.Existe(Cle: TKey): Boolean;
begin
  Result := FDonnees.ContainsKey(Cle);
end;

procedure TCache<TKey, TValue>.Supprimer(Cle: TKey);
begin
  FDonnees.Remove(Cle);
end;

procedure TCache<TKey, TValue>.Vider;
begin
  FDonnees.Clear;
end;

function TCache<TKey, TValue>.GetCount: Integer;
begin
  Result := FDonnees.Count;
end;
```

### Utilisation du cache

```pascal
var
  CacheUtilisateurs: TCache<Integer, string>;
  CachePrix: TCache<string, Double>;
begin
  // Cache d'utilisateurs (ID -> Nom)
  CacheUtilisateurs := TCache<Integer, string>.Create(100);
  try
    CacheUtilisateurs.Ajouter(1, 'Alice');
    CacheUtilisateurs.Ajouter(2, 'Bob');
    CacheUtilisateurs.Ajouter(3, 'Charlie');

    if CacheUtilisateurs.Existe(2) then
      ShowMessage('Utilisateur 2 : ' + CacheUtilisateurs.Obtenir(2));

    ShowMessage('√âl√©ments en cache : ' + IntToStr(CacheUtilisateurs.Count));
  finally
    CacheUtilisateurs.Free;
  end;

  // Cache de prix (Produit -> Prix)
  CachePrix := TCache<string, Double>.Create(50);
  try
    CachePrix.Ajouter('Pomme', 2.50);
    CachePrix.Ajouter('Orange', 3.00);
    CachePrix.Ajouter('Banane', 1.80);

    ShowMessage('Prix de la pomme : ' + FloatToStr(CachePrix.Obtenir('Pomme')));
  finally
    CachePrix.Free;
  end;
end;
```

## Comparaison et tri avec g√©n√©riques

Delphi fournit `IComparer<T>` pour comparer des √©l√©ments :

```pascal
uses System.Generics.Collections, System.Generics.Defaults;

type
  TPersonne = class
  public
    Nom: string;
    Age: Integer;
    constructor Create(ANom: string; AAge: Integer);
  end;

constructor TPersonne.Create(ANom: string; AAge: Integer);
begin
  inherited Create;
  Nom := ANom;
  Age := AAge;
end;

var
  Personnes: TList<TPersonne>;
  Personne: TPersonne;
  ComparerParAge: IComparer<TPersonne>;
begin
  Personnes := TList<TPersonne>.Create;
  try
    Personnes.Add(TPersonne.Create('Charlie', 28));
    Personnes.Add(TPersonne.Create('Alice', 25));
    Personnes.Add(TPersonne.Create('Bob', 30));

    // Cr√©er un comparateur personnalis√©
    ComparerParAge := TComparer<TPersonne>.Construct(
      function(const A, B: TPersonne): Integer
      begin
        Result := A.Age - B.Age;
      end
    );

    // Trier par √¢ge
    Personnes.Sort(ComparerParAge);

    ShowMessage('Liste tri√©e par √¢ge :');
    for Personne in Personnes do
      ShowMessage(Format('%s (%d ans)', [Personne.Nom, Personne.Age]));

  finally
    for Personne in Personnes do
      Personne.Free;
    Personnes.Free;
  end;
end;
```

## Avantages de la g√©n√©ricit√©

1. **R√©utilisabilit√©** : un seul code pour plusieurs types
2. **S√©curit√© des types** : erreurs d√©tect√©es √† la compilation
3. **Performance** : pas de boxing/unboxing comme avec TObject
4. **Lisibilit√©** : le code est plus clair et explicite
5. **Maintenance** : moins de duplication de code

### Comparaison : avec et sans g√©n√©riques

```pascal
// ‚ùå Sans g√©n√©riques (ancienne m√©thode)
var
  Liste: TList;  // TList de TObject
  Personne: TPersonne;
begin
  Liste := TList.Create;
  try
    Liste.Add(TPersonne.Create('Alice', 25));

    // N√©cessite un cast !
    Personne := TPersonne(Liste[0]);

    // Risque : si on met le mauvais type, erreur √† l'ex√©cution
    Liste.Add(TStringList.Create);  // Oups !
  finally
    Liste.Free;
  end;
end;

// ‚úÖ Avec g√©n√©riques (m√©thode moderne)
var
  Liste: TObjectList<TPersonne>;
  Personne: TPersonne;
begin
  Liste := TObjectList<TPersonne>.Create(True);
  try
    Liste.Add(TPersonne.Create('Alice', 25));

    // Pas de cast n√©cessaire !
    Personne := Liste[0];

    // Erreur de compilation si mauvais type
    // Liste.Add(TStringList.Create);  // Ne compile pas !
  finally
    Liste.Free;
  end;
end;
```

## Bonnes pratiques

### 1. Utilisez des noms de param√®tres explicites

```pascal
// ‚úÖ Bon - noms explicites
TDictionnaire<TKey, TValue> = class

// ‚ö†Ô∏è Acceptable mais moins clair
TDictionnaire<K, V> = class

// ‚ùå √âviter - pas assez clair
TDictionnaire<T1, T2> = class
```

### 2. Pr√©f√©rez les collections g√©n√©riques aux anciennes

```pascal
// ‚úÖ Bon
var Liste: TList<Integer>;

// ‚ùå √âviter (ancienne m√©thode)
var Liste: TList;  // Liste de TObject
```

### 3. Utilisez TObjectList<T> pour les objets

```pascal
// ‚úÖ Bon - lib√©ration automatique
var Personnes: TObjectList<TPersonne>;
Personnes := TObjectList<TPersonne>.Create(True);

// ‚ùå Plus risqu√© - lib√©ration manuelle
var Personnes: TList<TPersonne>;
Personnes := TList<TPersonne>.Create;
// Il faut lib√©rer chaque objet manuellement !
```

### 4. Utilisez les contraintes quand n√©cessaire

```pascal
// ‚úÖ Bon - contrainte appropri√©e
TFactory<T: class, constructor> = class

// ‚ö†Ô∏è Pas de contrainte - moins s√ªr
TFactory<T> = class
```

### 5. Documentez vos classes g√©n√©riques

```pascal
/// <summary>
/// Cache g√©n√©rique avec capacit√© limit√©e
/// </summary>
/// <typeparam name="TKey">Type de la cl√©</typeparam>
/// <typeparam name="TValue">Type de la valeur</typeparam>
TCache<TKey, TValue> = class
```

## Limitations de la g√©n√©ricit√©

1. **Pas de sp√©cialisation** : on ne peut pas avoir des impl√©mentations diff√©rentes pour des types sp√©cifiques
2. **Pas de valeurs par d√©faut pour T** : on ne peut pas faire `FValeur: T = DefaultValue`
3. **Contraintes limit√©es** : les contraintes sont moins puissantes que dans d'autres langages

## R√©sum√©

- **G√©n√©ricit√©** = m√©canisme permettant de cr√©er du code r√©utilisable pour diff√©rents types
  - Syntaxe : `TMaClasse<T>` o√π `T` est le param√®tre de type
  - √âvite la duplication de code

- **Param√®tres de type**
  - Un seul : `TListe<T>`
  - Plusieurs : `TDictionnaire<TKey, TValue>`
  - Noms conventionnels : `T`, `TKey`, `TValue`, etc.

- **Contraintes**
  - `class` : doit √™tre une classe
  - `record` : doit √™tre un record
  - `constructor` : doit avoir un constructeur
  - Classe de base : `T: TStream`

- **Collections g√©n√©riques Delphi**
  - `TList<T>` : liste dynamique
  - `TDictionary<TKey, TValue>` : dictionnaire
  - `TObjectList<T>` : liste d'objets avec gestion automatique
  - `TQueue<T>` : file FIFO
  - `TStack<T>` : pile LIFO

- **Avantages**
  - S√©curit√© des types √† la compilation
  - Pas de cast n√©cessaire
  - Meilleure performance
  - Code plus lisible et maintenable

La g√©n√©ricit√© est un outil puissant et moderne en Delphi. Elle permet d'√©crire du code plus s√ªr, plus performant et plus facile √† maintenir. Les collections g√©n√©riques doivent √™tre privil√©gi√©es dans tout nouveau code.

‚è≠Ô∏è [Mod√®les de conception (Design Patterns)](/03-langage-object-pascal/08-modeles-de-conception.md)
