# 3.7.6 G√©n√©ricit√©

üîù Retour √† la [Table des mati√®res](/SOMMAIRE.md)

La g√©n√©ricit√© est une fonctionnalit√© puissante qui permet de cr√©er des classes, des m√©thodes et des proc√©dures qui peuvent fonctionner avec diff√©rents types de donn√©es. C'est un concept qui peut sembler complexe au premier abord, mais qui offre d'√©normes avantages en termes de r√©utilisation et de s√©curit√© du code. Dans cette section, nous allons explorer la g√©n√©ricit√© en Object Pascal et voir comment l'utiliser efficacement.

## Qu'est-ce que la g√©n√©ricit√© ?

La g√©n√©ricit√© permet de cr√©er du code qui fonctionne avec des types non sp√©cifi√©s √† l'avance. Au lieu d'√©crire une classe ou une m√©thode pour chaque type de donn√©es, vous √©crivez un mod√®le (template) qui peut √™tre instanci√© pour n'importe quel type.

Imaginez que vous cr√©ez une bo√Æte. Avec la g√©n√©ricit√©, vous ne cr√©ez pas une bo√Æte sp√©cifique pour les pommes, une autre pour les chaussures, etc. Vous cr√©ez un mod√®le de bo√Æte qui peut contenir n'importe quel type d'objet. C'est comme si vous √©criviez une fois le plan, puis que vous pouviez fabriquer diff√©rentes bo√Ætes selon les besoins.

## Pourquoi utiliser la g√©n√©ricit√© ?

La g√©n√©ricit√© offre plusieurs avantages importants :

1. **R√©utilisation du code** : √âcrivez une fois, utilisez pour plusieurs types
2. **S√©curit√© de type** : V√©rification des types √† la compilation
3. **Performance** : Pas besoin de conversions de types √† l'ex√©cution
4. **Lisibilit√©** : Code plus clair et plus expressif
5. **Maintenabilit√©** : Moins de code √† maintenir

## Classes g√©n√©riques

Commen√ßons par d√©couvrir les classes g√©n√©riques en Object Pascal. Une classe g√©n√©rique se d√©clare en ajoutant un ou plusieurs param√®tres de type entre chevrons `<>` :

```pascal
type
  TBoite<T> = class
  private
    FContenu: T;
  public
    procedure AjouterContenu(const Valeur: T);
    function ObtenirContenu: T;
  end;
```

Dans cet exemple, `T` est un param√®tre de type qui sera remplac√© par un type r√©el lorsque la classe sera utilis√©e.

### Impl√©mentation d'une classe g√©n√©rique

L'impl√©mentation d'une classe g√©n√©rique est similaire √† celle d'une classe normale :

```pascal
procedure TBoite<T>.AjouterContenu(const Valeur: T);
begin
  FContenu := Valeur;
end;

function TBoite<T>.ObtenirContenu: T;
begin
  Result := FContenu;
end;
```

### Utilisation d'une classe g√©n√©rique

Pour utiliser une classe g√©n√©rique, vous devez sp√©cifier le type concret qui remplacera le param√®tre de type :

```pascal
var
  BoiteEntiers: TBoite<Integer>;
  BoiteChaines: TBoite<string>;
begin
  // Cr√©ation d'une bo√Æte pour les entiers
  BoiteEntiers := TBoite<Integer>.Create;
  try
    BoiteEntiers.AjouterContenu(42);
    ShowMessage('Contenu : ' + IntToStr(BoiteEntiers.ObtenirContenu));
  finally
    BoiteEntiers.Free;
  end;

  // Cr√©ation d'une bo√Æte pour les cha√Ænes
  BoiteChaines := TBoite<string>.Create;
  try
    BoiteChaines.AjouterContenu('Bonjour Delphi');
    ShowMessage('Contenu : ' + BoiteChaines.ObtenirContenu);
  finally
    BoiteChaines.Free;
  end;
end;
```

Notez que nous avons cr√©√© deux instances diff√©rentes de la m√™me classe g√©n√©rique : une pour les entiers et une pour les cha√Ænes.

## M√©thodes g√©n√©riques

En plus des classes, vous pouvez √©galement cr√©er des m√©thodes g√©n√©riques :

```pascal
type
  TUtilitaires = class
  public
    class procedure Echanger<T>(var A, B: T);
  end;

class procedure TUtilitaires.Echanger<T>(var A, B: T);
var
  Temp: T;
begin
  Temp := A;
  A := B;
  B := Temp;
end;
```

Utilisation :

```pascal
var
  X, Y: Integer;
  S1, S2: string;
begin
  X := 10;
  Y := 20;
  TUtilitaires.Echanger<Integer>(X, Y);
  ShowMessage('X = ' + IntToStr(X) + ', Y = ' + IntToStr(Y));  // X = 20, Y = 10

  S1 := 'Bonjour';
  S2 := 'Delphi';
  TUtilitaires.Echanger<string>(S1, S2);
  ShowMessage('S1 = ' + S1 + ', S2 = ' + S2);  // S1 = Delphi, S2 = Bonjour
end;
```

Delphi peut souvent inf√©rer le type √† partir des param√®tres, donc vous pouvez g√©n√©ralement omettre le type entre chevrons :

```pascal
TUtilitaires.Echanger(X, Y);  // Le compilateur d√©duit <Integer>
TUtilitaires.Echanger(S1, S2);  // Le compilateur d√©duit <string>
```

## Exemple pratique : liste g√©n√©rique

Cr√©ons un exemple un peu plus complexe avec une liste g√©n√©rique simple :

```pascal
type
  TListeGenerique<T> = class
  private
    FItems: array of T;
    FCount: Integer;
  public
    constructor Create;
    procedure AjouterItem(const Item: T);
    function ObtenirItem(Index: Integer): T;
    procedure SupprimerItem(Index: Integer);
    property Count: Integer read FCount;
  end;

constructor TListeGenerique<T>.Create;
begin
  inherited Create;
  FCount := 0;
  SetLength(FItems, 0);
end;

procedure TListeGenerique<T>.AjouterItem(const Item: T);
begin
  SetLength(FItems, FCount + 1);
  FItems[FCount] := Item;
  Inc(FCount);
end;

function TListeGenerique<T>.ObtenirItem(Index: Integer): T;
begin
  if (Index >= 0) and (Index < FCount) then
    Result := FItems[Index]
  else
    raise Exception.Create('Index hors limites');
end;

procedure TListeGenerique<T>.SupprimerItem(Index: Integer);
var
  I: Integer;
begin
  if (Index >= 0) and (Index < FCount) then
  begin
    // D√©caler les √©l√©ments
    for I := Index to FCount - 2 do
      FItems[I] := FItems[I + 1];

    // R√©duire le tableau
    Dec(FCount);
    SetLength(FItems, FCount);
  end
  else
    raise Exception.Create('Index hors limites');
end;
```

Utilisation :

```pascal
var
  ListeNombres: TListeGenerique<Integer>;
  ListeNoms: TListeGenerique<string>;
  I: Integer;
begin
  // Liste d'entiers
  ListeNombres := TListeGenerique<Integer>.Create;
  try
    ListeNombres.AjouterItem(10);
    ListeNombres.AjouterItem(20);
    ListeNombres.AjouterItem(30);

    for I := 0 to ListeNombres.Count - 1 do
      ShowMessage('Nombre ' + IntToStr(I) + ' : ' + IntToStr(ListeNombres.ObtenirItem(I)));

    ListeNombres.SupprimerItem(1);  // Supprime 20
    ShowMessage('Apr√®s suppression : ' + IntToStr(ListeNombres.Count) + ' √©l√©ments');
  finally
    ListeNombres.Free;
  end;

  // Liste de cha√Ænes
  ListeNoms := TListeGenerique<string>.Create;
  try
    ListeNoms.AjouterItem('Alice');
    ListeNoms.AjouterItem('Bob');
    ListeNoms.AjouterItem('Charlie');

    for I := 0 to ListeNoms.Count - 1 do
      ShowMessage('Nom ' + IntToStr(I) + ' : ' + ListeNoms.ObtenirItem(I));
  finally
    ListeNoms.Free;
  end;
end;
```

## Contraintes de type

Par d√©faut, un param√®tre de type g√©n√©rique peut √™tre remplac√© par n'importe quel type. Cependant, il est parfois n√©cessaire de restreindre les types possibles. C'est l√† qu'interviennent les contraintes de type.

### Types de contraintes

En Object Pascal, vous pouvez appliquer plusieurs types de contraintes :

#### Contrainte de classe

Limite le param√®tre de type aux classes d√©riv√©es d'une classe sp√©cifique :

```pascal
type
  TAnimal = class
    procedure Manger; virtual; abstract;
  end;

  TChien = class(TAnimal)
    procedure Manger; override;
  end;

  TChat = class(TAnimal)
    procedure Manger; override;
  end;

  // T doit h√©riter de TAnimal
  TZoo<T: TAnimal> = class
  private
    FAnimaux: array of T;
    FCount: Integer;
  public
    procedure AjouterAnimal(Animal: T);
    procedure NourrirAnimaux;
  end;

procedure TZoo<T>.NourrirAnimaux;
var
  I: Integer;
begin
  for I := 0 to FCount - 1 do
    FAnimaux[I].Manger;  // On peut appeler Manger car T h√©rite de TAnimal
end;
```

#### Contrainte d'interface

Limite le param√®tre de type aux classes qui impl√©mentent une interface sp√©cifique :

```pascal
type
  IComparable = interface
    function ComparerAvec(Autre: TObject): Integer;
  end;

  // T doit impl√©menter IComparable
  TTrieur<T: IComparable> = class
  public
    procedure Trier(var Items: array of T);
  end;
```

#### Contrainte de constructeur

Sp√©cifie que le type doit avoir un constructeur par d√©faut :

```pascal
type
  // T doit avoir un constructeur par d√©faut
  TFabrique<T: constructor> = class
  public
    function CreerInstance: T;
  end;

function TFabrique<T>.CreerInstance: T;
begin
  Result := T.Create;  // On peut appeler le constructeur par d√©faut
end;
```

#### Contraintes multiples

Vous pouvez combiner plusieurs contraintes :

```pascal
type
  // T doit h√©riter de TPersonne et impl√©menter IComparable
  TGestionnaire<T: TPersonne, IComparable> = class
    // ...
  end;
```

## Classes g√©n√©riques pr√©d√©finies dans Delphi

Delphi offre plusieurs classes g√©n√©riques pr√™tes √† l'emploi dans l'unit√© `System.Generics.Collections` :

### TList\<T>

Une liste dynamique d'√©l√©ments de type T :

```pascal
uses
  System.Generics.Collections;

var
  ListeEntiers: TList<Integer>;
begin
  ListeEntiers := TList<Integer>.Create;
  try
    ListeEntiers.Add(10);
    ListeEntiers.Add(20);
    ListeEntiers.Add(30);

    ShowMessage('Premier √©l√©ment : ' + IntToStr(ListeEntiers[0]));
    ShowMessage('Nombre d''√©l√©ments : ' + IntToStr(ListeEntiers.Count));

    ListeEntiers.Delete(1);  // Supprime 20

    if ListeEntiers.Contains(30) then
      ShowMessage('La liste contient 30');
  finally
    ListeEntiers.Free;
  end;
end;
```

### TDictionary\<TKey, TValue>

Une table de hachage associant des cl√©s et des valeurs :

```pascal
var
  Dictionnaire: TDictionary<string, Integer>;
begin
  Dictionnaire := TDictionary<string, Integer>.Create;
  try
    // Ajout d'√©l√©ments
    Dictionnaire.Add('Un', 1);
    Dictionnaire.Add('Deux', 2);
    Dictionnaire.Add('Trois', 3);

    // Acc√®s par cl√©
    ShowMessage('Deux = ' + IntToStr(Dictionnaire['Deux']));

    // V√©rification d'existence
    if Dictionnaire.ContainsKey('Trois') then
      ShowMessage('La cl√© "Trois" existe');

    // Parcours des cl√©s et valeurs
    for var Paire in Dictionnaire do
      ShowMessage(Paire.Key + ' = ' + IntToStr(Paire.Value));
  finally
    Dictionnaire.Free;
  end;
end;
```

### TQueue\<T>

Une file d'attente (premier entr√©, premier sorti) :

```pascal
var
  File: TQueue<string>;
begin
  File := TQueue<string>.Create;
  try
    File.Enqueue('Premier');
    File.Enqueue('Deuxi√®me');
    File.Enqueue('Troisi√®me');

    while File.Count > 0 do
      ShowMessage('Traitement de : ' + File.Dequeue);
  finally
    File.Free;
  end;
end;
```

### TStack\<T>

Une pile (dernier entr√©, premier sorti) :

```pascal
var
  Pile: TStack<Integer>;
begin
  Pile := TStack<Integer>.Create;
  try
    Pile.Push(10);
    Pile.Push(20);
    Pile.Push(30);

    while Pile.Count > 0 do
      ShowMessage('D√©pilage : ' + IntToStr(Pile.Pop));
    // Affiche 30, puis 20, puis 10
  finally
    Pile.Free;
  end;
end;
```

## Exemple pratique : un gestionnaire de t√¢ches g√©n√©rique

Voici un exemple plus complet montrant comment utiliser la g√©n√©ricit√© pour cr√©er un gestionnaire de t√¢ches flexible :

```pascal
type
  // Interface pour les t√¢ches
  ITask = interface
    ['{12345678-1234-1234-1234-123456789ABC}']
    procedure Execute;
    function GetDescription: string;
    property Description: string read GetDescription;
  end;

  // Classe g√©n√©rique pour g√©rer une file d'attente de t√¢ches
  TTaskManager<T: ITask> = class
  private
    FTasks: TQueue<T>;
  public
    constructor Create;
    destructor Destroy; override;
    procedure AddTask(const Task: T);
    procedure ProcessAllTasks;
    function GetPendingTasksCount: Integer;
  end;

  // Impl√©mentation de t√¢ches sp√©cifiques
  TEmailTask = class(TInterfacedObject, ITask)
  private
    FRecipient: string;
    FSubject: string;
    FContent: string;
    function GetDescription: string;
  public
    constructor Create(const ARecipient, ASubject, AContent: string);
    procedure Execute;
  end;

  TPrintTask = class(TInterfacedObject, ITask)
  private
    FDocument: string;
    FPrinter: string;
    function GetDescription: string;
  public
    constructor Create(const ADocument, APrinter: string);
    procedure Execute;
  end;

{ TTaskManager<T> }

constructor TTaskManager<T>.Create;
begin
  inherited Create;
  FTasks := TQueue<T>.Create;
end;

destructor TTaskManager<T>.Destroy;
begin
  FTasks.Free;
  inherited;
end;

procedure TTaskManager<T>.AddTask(const Task: T);
begin
  FTasks.Enqueue(Task);
end;

procedure TTaskManager<T>.ProcessAllTasks;
var
  Task: T;
begin
  while FTasks.Count > 0 do
  begin
    Task := FTasks.Dequeue;
    try
      ShowMessage('Ex√©cution de : ' + Task.Description);
      Task.Execute;
    except
      on E: Exception do
        ShowMessage('Erreur lors de l''ex√©cution de la t√¢che : ' + E.Message);
    end;
  end;
end;

function TTaskManager<T>.GetPendingTasksCount: Integer;
begin
  Result := FTasks.Count;
end;

{ TEmailTask }

constructor TEmailTask.Create(const ARecipient, ASubject, AContent: string);
begin
  inherited Create;
  FRecipient := ARecipient;
  FSubject := ASubject;
  FContent := AContent;
end;

procedure TEmailTask.Execute;
begin
  // Code d'envoi d'email (simulation)
  ShowMessage('Email envoy√© √† ' + FRecipient);
end;

function TEmailTask.GetDescription: string;
begin
  Result := 'Email √† ' + FRecipient + ' : ' + FSubject;
end;

{ TPrintTask }

constructor TPrintTask.Create(const ADocument, APrinter: string);
begin
  inherited Create;
  FDocument := ADocument;
  FPrinter := APrinter;
end;

procedure TPrintTask.Execute;
begin
  // Code d'impression (simulation)
  ShowMessage('Document ' + FDocument + ' imprim√© sur ' + FPrinter);
end;

function TPrintTask.GetDescription: string;
begin
  Result := 'Impression de ' + FDocument + ' sur ' + FPrinter;
end;
```

Utilisation :

```pascal
var
  TaskManager: TTaskManager<ITask>;
  EmailTask: ITask;
  PrintTask: ITask;
begin
  TaskManager := TTaskManager<ITask>.Create;
  try
    // Cr√©ation de t√¢ches
    EmailTask := TEmailTask.Create('john.doe@example.com', 'Rappel', 'N''oubliez pas la r√©union');
    PrintTask := TPrintTask.Create('Rapport.pdf', 'HP LaserJet');

    // Ajout des t√¢ches au gestionnaire
    TaskManager.AddTask(EmailTask);
    TaskManager.AddTask(PrintTask);

    ShowMessage('Nombre de t√¢ches en attente : ' + IntToStr(TaskManager.GetPendingTasksCount));

    // Traitement de toutes les t√¢ches
    TaskManager.ProcessAllTasks;

    ShowMessage('Toutes les t√¢ches ont √©t√© trait√©es');
  finally
    TaskManager.Free;
    // Pas besoin de lib√©rer EmailTask et PrintTask (interfaces)
  end;
end;
```

## Limitations et consid√©rations

### 1. Surcharge du code g√©n√©r√©

La g√©n√©ricit√© peut g√©n√©rer beaucoup de code, car le compilateur cr√©e une version distincte pour chaque instanciation de type. Cela peut augmenter la taille de votre ex√©cutable.

### 2. Lisibilit√©

Les types g√©n√©riques complexes peuvent √™tre difficiles √† lire et √† comprendre, surtout avec plusieurs param√®tres de type et contraintes.

### 3. Erreurs de compilation

Les erreurs dans le code g√©n√©rique peuvent √™tre difficiles √† d√©tecter et √† corriger, car elles apparaissent souvent lors de l'instanciation du type.

## Bonnes pratiques

1. **Utilisez des noms de param√®tres de type significatifs** :
   - `T` est conventionnel pour un seul param√®tre g√©n√©ral
   - Pour plusieurs param√®tres, utilisez des noms comme `TKey`, `TValue`, `TItem`

2. **Documentez les hypoth√®ses** :
   - Ajoutez des commentaires expliquant ce que vous attendez des types g√©n√©riques

3. **Utilisez des contraintes appropri√©es** :
   - Restreignez les param√®tres de type quand c'est logique
   - Cela rend votre code plus s√ªr et plus clair

4. **Pr√©f√©rez les classes g√©n√©riques pr√©d√©finies** :
   - Utilisez `TList<T>`, `TDictionary<TKey, TValue>`, etc. quand possible
   - Elles sont bien test√©es et optimis√©es

5. **√âvitez la g√©n√©ricit√© excessive** :
   - N'utilisez pas la g√©n√©ricit√© quand une solution simple suffit
   - Trop de param√®tres de type rend le code difficile √† comprendre

---

La g√©n√©ricit√© est un outil puissant qui permet de cr√©er du code r√©utilisable et typ√© de mani√®re s√©curis√©e. En comprenant ses principes et en l'utilisant judicieusement, vous pouvez am√©liorer consid√©rablement la qualit√© et la maintenabilit√© de vos applications Delphi.

Dans les sections suivantes de ce tutoriel, nous verrons comment utiliser ces concepts dans des applications r√©elles et comment ils s'int√®grent avec d'autres fonctionnalit√©s avanc√©es de Delphi.

‚è≠Ô∏è [Mod√®les de conception (Design Patterns)](/03-langage-object-pascal/08-modeles-de-conception.md)
