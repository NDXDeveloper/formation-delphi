üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.3.2 Contr√¥les de saisie (Edit, Memo, ComboBox)

## Introduction

Les contr√¥les de saisie sont au c≈ìur de l'interaction entre l'utilisateur et votre application. Contrairement aux contr√¥les d'affichage qui montrent simplement des informations, les **contr√¥les de saisie** permettent √† l'utilisateur d'**entrer, modifier et s√©lectionner des donn√©es**.

Dans cette section, nous allons explorer trois des contr√¥les de saisie les plus importants de la VCL :
- **TEdit** : pour la saisie de texte sur une seule ligne
- **TMemo** : pour la saisie de texte multi-lignes
- **TComboBox** : pour la s√©lection dans une liste d√©roulante

Ces trois composants sont essentiels et vous les utiliserez dans pratiquement toutes vos applications.

## Le composant TEdit (Zone de saisie)

### Qu'est-ce qu'un TEdit ?

Le composant **TEdit** est une zone de saisie de texte sur **une seule ligne**. C'est l'un des composants les plus utilis√©s dans les applications Windows.

**Utilisations courantes :**
- Saisir un nom, pr√©nom
- Entrer une adresse email
- Taper un num√©ro de t√©l√©phone
- Saisir un mot de passe
- Entrer une quantit√©, un prix
- Rechercher dans une liste
- Saisir n'importe quelle donn√©e textuelle courte

### O√π trouver TEdit ?

TEdit se trouve dans l'onglet **Standard** de la palette de composants. C'est g√©n√©ralement l'un des premiers composants de cet onglet.

### Propri√©t√©s essentielles de TEdit

#### 1. Text - Le contenu de la zone de saisie

C'est la propri√©t√© la plus importante : elle contient le **texte saisi** par l'utilisateur.

```pascal
// D√©finir le texte
Edit1.Text := 'Valeur par d√©faut';

// R√©cup√©rer le texte
var
  NomUtilisateur: string;
begin
  NomUtilisateur := Edit1.Text;
end;

// Effacer le texte
Edit1.Text := '';

// V√©rifier si le champ est vide
if Edit1.Text = '' then
  ShowMessage('Veuillez saisir une valeur');
```

#### 2. MaxLength - Longueur maximale

Limite le nombre de caract√®res que l'utilisateur peut saisir :

```pascal
EditNom.MaxLength := 50;        // Maximum 50 caract√®res
EditCodePostal.MaxLength := 5;   // Maximum 5 caract√®res
Edit1.MaxLength := 0;            // Pas de limite (par d√©faut)
```

**Conseil :** D√©finissez toujours une MaxLength raisonnable pour √©viter les saisies excessives.

#### 3. PasswordChar - Masquer la saisie

Permet de masquer le texte saisi (pour les mots de passe) :

```pascal
EditMotDePasse.PasswordChar := '*';  // Affiche des √©toiles
EditMotDePasse.PasswordChar := '‚Ä¢';  // Affiche des points
EditMotDePasse.PasswordChar := #0;   // Texte normal (par d√©faut)
```

#### 4. ReadOnly - Lecture seule

Si True, l'utilisateur ne peut pas modifier le texte (mais peut le s√©lectionner et le copier) :

```pascal
EditID.ReadOnly := True;  // Lecture seule
EditNom.ReadOnly := False; // Modifiable (par d√©faut)
```

**Diff√©rence avec Enabled :**
- `ReadOnly = True` : Le champ garde son apparence normale mais n'est pas modifiable
- `Enabled = False` : Le champ est gris√© et compl√®tement d√©sactiv√©

#### 5. CharCase - Casse des caract√®res

Force la casse du texte saisi :

```pascal
EditEmail.CharCase := ecLowerCase;  // Force les minuscules
EditCode.CharCase := ecUpperCase;   // Force les majuscules
Edit1.CharCase := ecNormal;         // Normal (par d√©faut)
```

#### 6. TextHint - Texte indicatif

Affiche un texte d'aide en gris quand le champ est vide :

```pascal
EditNom.TextHint := 'Saisissez votre nom';
EditEmail.TextHint := 'exemple@email.com';
EditRecherche.TextHint := 'Rechercher...';
```

C'est un excellent moyen de guider l'utilisateur sans utiliser de label suppl√©mentaire.

#### 7. Alignment - Alignement du texte

D√©termine l'alignement du texte dans le champ :

```pascal
EditPrix.Alignment := taRightJustify;  // Align√© √† droite (utile pour les nombres)
EditNom.Alignment := taLeftJustify;    // Align√© √† gauche (par d√©faut)
EditCode.Alignment := taCenter;        // Centr√©
```

#### 8. AutoSelect - S√©lection automatique

Si True, tout le texte est s√©lectionn√© automatiquement quand le champ re√ßoit le focus :

```pascal
Edit1.AutoSelect := True;  // S√©lectionne tout au focus
```

Tr√®s pratique pour permettre √† l'utilisateur de remplacer rapidement une valeur.

#### 9. AutoSize - Ajustement automatique de la hauteur

Si True, la hauteur du champ s'ajuste √† la taille de la police :

```pascal
Edit1.AutoSize := True;  // Ajustement automatique (recommand√©)
```

#### 10. NumbersOnly - Saisie num√©rique uniquement

Si True, seuls les chiffres peuvent √™tre saisis :

```pascal
EditAge.NumbersOnly := True;  // Seulement des chiffres
```

**Limitation :** Cette propri√©t√© accepte uniquement les chiffres entiers, pas de virgules ou points d√©cimaux.

### Utilisation pratique de TEdit

#### Exemple 1 : Formulaire de saisie simple

```pascal
procedure TForm1.FormCreate(Sender: TObject);
begin
  // Configuration des champs
  EditNom.TextHint := 'Nom complet';
  EditNom.MaxLength := 100;
  EditNom.CharCase := ecNormal;

  EditEmail.TextHint := 'adresse@email.com';
  EditEmail.MaxLength := 255;
  EditEmail.CharCase := ecLowerCase;

  EditTelephone.TextHint := '06 12 34 56 78';
  EditTelephone.MaxLength := 14;
end;
```

#### Exemple 2 : Validation de saisie

```pascal
procedure TForm1.BoutonValiderClick(Sender: TObject);
begin
  // V√©rifier que les champs sont remplis
  if EditNom.Text = '' then
  begin
    ShowMessage('Veuillez saisir un nom');
    EditNom.SetFocus;
    Exit;
  end;

  if EditEmail.Text = '' then
  begin
    ShowMessage('Veuillez saisir un email');
    EditEmail.SetFocus;
    Exit;
  end;

  // V√©rifier le format de l'email (simple)
  if Pos('@', EditEmail.Text) = 0 then
  begin
    ShowMessage('L''adresse email est invalide');
    EditEmail.SetFocus;
    Exit;
  end;

  // Traiter les donn√©es
  ShowMessage('Donn√©es valides !');
end;
```

#### Exemple 3 : Saisie de nombre avec validation

```pascal
procedure TForm1.EditPrixKeyPress(Sender: TObject; var Key: Char);
begin
  // Autoriser seulement les chiffres, la virgule et le backspace
  if not (Key in ['0'..'9', ',', '.', #8]) then
    Key := #0;  // Ignorer la touche

  // Remplacer le point par une virgule
  if Key = '.' then
    Key := ',';
end;

procedure TForm1.BoutonCalculerClick(Sender: TObject);
var
  Prix: Double;
begin
  try
    Prix := StrToFloat(EditPrix.Text);
    ShowMessage(Format('Prix saisi : %.2f ‚Ç¨', [Prix]));
  except
    on E: Exception do
    begin
      ShowMessage('Prix invalide');
      EditPrix.SetFocus;
    end;
  end;
end;
```

#### Exemple 4 : Recherche en temps r√©el

```pascal
procedure TForm1.EditRechercheChange(Sender: TObject);
var
  TexteRecherche: string;
  i: Integer;
begin
  TexteRecherche := LowerCase(EditRecherche.Text);
  ListBox1.Items.Clear;

  // Filtrer les √©l√©ments
  for i := 0 to ListeComplete.Count - 1 do
  begin
    if Pos(TexteRecherche, LowerCase(ListeComplete[i])) > 0 then
      ListBox1.Items.Add(ListeComplete[i]);
  end;
end;
```

### √âv√©nements importants de TEdit

**OnChange** : D√©clench√© √† chaque modification du texte

```pascal
procedure TForm1.Edit1Change(Sender: TObject);
begin
  // Mettre √† jour quelque chose en temps r√©el
  LabelCaracteres.Caption := Format('%d caract√®res', [Length(Edit1.Text)]);
end;
```

**OnKeyPress** : D√©clench√© quand une touche est press√©e

```pascal
procedure TForm1.Edit1KeyPress(Sender: TObject; var Key: Char);
begin
  // Valider avec Enter
  if Key = #13 then  // Touche Entr√©e
  begin
    BoutonValider.Click;
    Key := #0;  // Emp√™cher le "beep"
  end;
end;
```

**OnEnter** : D√©clench√© quand le champ re√ßoit le focus

```pascal
procedure TForm1.Edit1Enter(Sender: TObject);
begin
  Edit1.Color := clYellow;  // Surligner le champ actif
end;
```

**OnExit** : D√©clench√© quand le champ perd le focus

```pascal
procedure TForm1.Edit1Exit(Sender: TObject);
begin
  Edit1.Color := clWindow;  // Revenir √† la couleur normale
  // Valider le contenu du champ
  ValiderSaisie(Edit1);
end;
```

### Astuces et bonnes pratiques pour TEdit

#### 1. Toujours valider les saisies

Ne faites jamais confiance aveugl√©ment aux donn√©es saisies par l'utilisateur.

```pascal
// V√©rifier si vide
if Trim(Edit1.Text) = '' then
  ShowMessage('Champ obligatoire');

// V√©rifier la longueur
if Length(Edit1.Text) < 3 then
  ShowMessage('Au moins 3 caract√®res requis');
```

#### 2. Utiliser TextHint au lieu de valeurs par d√©faut

**Mauvais :**
```pascal
Edit1.Text := 'Entrez votre nom ici';
```

**Bon :**
```pascal
Edit1.TextHint := 'Entrez votre nom ici';
```

#### 3. G√©rer les conversions num√©riques avec pr√©caution

Toujours utiliser try-except pour les conversions :

```pascal
try
  Valeur := StrToInt(Edit1.Text);
except
  ShowMessage('Valeur num√©rique invalide');
  Exit;
end;
```

#### 4. Utiliser Trim pour √©liminer les espaces

```pascal
NomUtilisateur := Trim(EditNom.Text);
```

#### 5. Fournir un feedback visuel

Indiquez clairement quel champ est actif et s'il y a des erreurs :

```pascal
procedure TForm1.MarquerErreur(Edit: TEdit; const Message: string);
begin
  Edit.Color := $C0C0FF;  // Fond rouge clair
  Edit.SetFocus;
  ShowMessage(Message);
end;
```

## Le composant TMemo (Zone de texte multi-lignes)

### Qu'est-ce qu'un TMemo ?

Le composant **TMemo** est une zone de saisie de texte **multi-lignes**. C'est comme un petit √©diteur de texte int√©gr√© dans votre application.

**Utilisations courantes :**
- Saisir des commentaires ou remarques
- Afficher ou √©diter des logs
- √âcrire des descriptions longues
- Saisir des adresses postales
- Cr√©er des √©diteurs de texte simples
- Afficher du contenu format√©

### O√π trouver TMemo ?

TMemo se trouve dans l'onglet **Standard** de la palette de composants, juste √† c√¥t√© de TEdit.

### Propri√©t√©s essentielles de TMemo

#### 1. Lines - Le contenu du Memo

C'est une **collection de lignes de texte** (TStrings). C'est la propri√©t√© principale du Memo.

```pascal
// Ajouter du texte
Memo1.Lines.Add('Premi√®re ligne');
Memo1.Lines.Add('Deuxi√®me ligne');

// D√©finir tout le texte
Memo1.Lines.Text := 'Ligne 1' + sLineBreak + 'Ligne 2';

// R√©cup√©rer tout le texte
var
  Contenu: string;
begin
  Contenu := Memo1.Lines.Text;
end;

// Effacer tout
Memo1.Lines.Clear;

// Nombre de lignes
NombreLignes := Memo1.Lines.Count;

// Acc√©der √† une ligne sp√©cifique
PremiereLigne := Memo1.Lines[0];  // Premi√®re ligne (index 0)
```

#### 2. ScrollBars - Barres de d√©filement

D√©finit quelles barres de d√©filement sont affich√©es :

```pascal
Memo1.ScrollBars := ssNone;       // Aucune
Memo1.ScrollBars := ssHorizontal; // Horizontale seulement
Memo1.ScrollBars := ssVertical;   // Verticale seulement
Memo1.ScrollBars := ssBoth;       // Les deux
```

**Recommandation :** `ssVertical` ou `ssBoth` selon les besoins.

#### 3. WordWrap - Retour √† la ligne automatique

Si True, le texte passe automatiquement √† la ligne suivante :

```pascal
Memo1.WordWrap := True;   // Retour automatique (recommand√©)
Memo1.WordWrap := False;  // Pas de retour automatique
```

**Note :** Si WordWrap est True, vous voudrez g√©n√©ralement `ScrollBars := ssVertical`.

#### 4. ReadOnly - Lecture seule

Comme pour TEdit, rend le Memo non modifiable :

```pascal
Memo1.ReadOnly := True;   // Lecture seule (pour afficher des logs par exemple)
Memo1.ReadOnly := False;  // Modifiable
```

#### 5. WantTabs - Autoriser les tabulations

Si True, la touche Tab ins√®re une tabulation au lieu de passer au contr√¥le suivant :

```pascal
Memo1.WantTabs := True;   // Tab ins√®re une tabulation
Memo1.WantTabs := False;  // Tab change de contr√¥le (par d√©faut)
```

#### 6. WantReturns - Autoriser les retours √† la ligne

Si True, la touche Entr√©e ins√®re une nouvelle ligne :

```pascal
Memo1.WantReturns := True;  // Entr√©e cr√©e une nouvelle ligne (par d√©faut)
Memo1.WantReturns := False; // Entr√©e active le bouton par d√©faut
```

#### 7. MaxLength - Longueur maximale

Limite le nombre total de caract√®res :

```pascal
Memo1.MaxLength := 5000;  // Maximum 5000 caract√®res
Memo1.MaxLength := 0;     // Pas de limite (par d√©faut)
```

### Utilisation pratique de TMemo

#### Exemple 1 : Journal d'activit√© (log)

```pascal
procedure TForm1.AjouterLog(const Message: string);
begin
  MemoLog.Lines.Add(FormatDateTime('hh:nn:ss', Now) + ' - ' + Message);
  // Faire d√©filer vers le bas
  MemoLog.SelStart := Length(MemoLog.Text);
  MemoLog.Perform(EM_SCROLLCARET, 0, 0);
end;

procedure TForm1.BoutonActionClick(Sender: TObject);
begin
  AjouterLog('Traitement d√©marr√©...');
  // Effectuer l'action
  Sleep(1000);
  AjouterLog('Traitement termin√©.');
end;
```

#### Exemple 2 : Saisie de commentaires

```pascal
procedure TForm1.FormCreate(Sender: TObject);
begin
  MemoCommentaire.Lines.Clear;
  MemoCommentaire.MaxLength := 500;
  MemoCommentaire.ScrollBars := ssVertical;
  MemoCommentaire.WordWrap := True;

  // Afficher le nombre de caract√®res restants
  LabelCaracteres.Caption := '500 caract√®res restants';
end;

procedure TForm1.MemoCommentaireChange(Sender: TObject);
var
  Restant: Integer;
begin
  Restant := MemoCommentaire.MaxLength - Length(MemoCommentaire.Text);
  LabelCaracteres.Caption := Format('%d caract√®res restants', [Restant]);

  if Restant < 50 then
    LabelCaracteres.Font.Color := clRed
  else
    LabelCaracteres.Font.Color := clBlack;
end;
```

#### Exemple 3 : Charger et sauvegarder un fichier texte

```pascal
procedure TForm1.BoutonOuvrirClick(Sender: TObject);
begin
  if OpenDialog1.Execute then
  begin
    try
      Memo1.Lines.LoadFromFile(OpenDialog1.FileName);
    except
      on E: Exception do
        ShowMessage('Erreur lors de l''ouverture : ' + E.Message);
    end;
  end;
end;

procedure TForm1.BoutonEnregistrerClick(Sender: TObject);
begin
  if SaveDialog1.Execute then
  begin
    try
      Memo1.Lines.SaveToFile(SaveDialog1.FileName);
      ShowMessage('Fichier enregistr√© avec succ√®s');
    except
      on E: Exception do
        ShowMessage('Erreur lors de l''enregistrement : ' + E.Message);
    end;
  end;
end;
```

#### Exemple 4 : Recherche dans le texte

```pascal
procedure TForm1.BoutonRechercherClick(Sender: TObject);
var
  TexteRecherche: string;
  Position: Integer;
begin
  TexteRecherche := EditRecherche.Text;

  if TexteRecherche = '' then
  begin
    ShowMessage('Veuillez saisir un texte √† rechercher');
    Exit;
  end;

  Position := Pos(LowerCase(TexteRecherche), LowerCase(Memo1.Text));

  if Position > 0 then
  begin
    Memo1.SetFocus;
    Memo1.SelStart := Position - 1;
    Memo1.SelLength := Length(TexteRecherche);
    ShowMessage('Texte trouv√©');
  end
  else
    ShowMessage('Texte non trouv√©');
end;
```

#### Exemple 5 : Formatage simple

```pascal
procedure TForm1.BoutonGrasClick(Sender: TObject);
begin
  Memo1.Font.Style := [fsBold];
end;

procedure TForm1.BoutonItalicClick(Sender: TObject);
begin
  Memo1.Font.Style := [fsItalic];
end;

procedure TForm1.BoutonNormalClick(Sender: TObject);
begin
  Memo1.Font.Style := [];
end;
```

**Note :** TMemo ne supporte pas le formatage mixte (diff√©rents styles dans le m√™me texte). Pour cela, utilisez TRichEdit.

### Astuces et bonnes pratiques pour TMemo

#### 1. Limiter la taille pour les performances

Si vous affichez beaucoup de lignes, limitez le nombre :

```pascal
procedure TForm1.AjouterLogOptimise(const Message: string);
begin
  MemoLog.Lines.Add(Message);

  // Garder seulement les 1000 derni√®res lignes
  while MemoLog.Lines.Count > 1000 do
    MemoLog.Lines.Delete(0);
end;
```

#### 2. Utiliser BeginUpdate/EndUpdate pour les modifications multiples

```pascal
procedure TForm1.ChargerDonnees;
begin
  Memo1.Lines.BeginUpdate;
  try
    Memo1.Lines.Clear;
    // Ajouter beaucoup de lignes
    for i := 0 to 10000 do
      Memo1.Lines.Add('Ligne ' + IntToStr(i));
  finally
    Memo1.Lines.EndUpdate;  // Rafra√Æchir une seule fois
  end;
end;
```

#### 3. V√©rifier les modifications

```pascal
if Memo1.Modified then
begin
  if MessageDlg('Le texte a √©t√© modifi√©. Enregistrer les modifications ?',
                 mtConfirmation, [mbYes, mbNo], 0) = mrYes then
    EnregistrerFichier;
end;
```

#### 4. D√©finir Modified √† False apr√®s sauvegarde

```pascal
procedure TForm1.EnregistrerFichier;
begin
  Memo1.Lines.SaveToFile(NomFichier);
  Memo1.Modified := False;  // Marquer comme non modifi√©
end;
```

## Le composant TComboBox (Liste d√©roulante)

### Qu'est-ce qu'un TComboBox ?

Le composant **TComboBox** combine une zone de saisie avec une liste d√©roulante. L'utilisateur peut soit **s√©lectionner** une option dans la liste, soit **saisir** sa propre valeur (selon le style choisi).

**Utilisations courantes :**
- Choisir un pays, une ville
- S√©lectionner une cat√©gorie
- Choisir une option de configuration
- Historique de recherche
- Liste de valeurs pr√©d√©finies

### O√π trouver TComboBox ?

TComboBox se trouve dans l'onglet **Standard** de la palette de composants.

### Propri√©t√©s essentielles de TComboBox

#### 1. Items - La liste des options

C'est une collection (TStrings) contenant toutes les options disponibles :

```pascal
// Ajouter des √©l√©ments
ComboBox1.Items.Add('Option 1');
ComboBox1.Items.Add('Option 2');
ComboBox1.Items.Add('Option 3');

// Ajouter plusieurs √©l√©ments
ComboBox1.Items.AddStrings(['Rouge', 'Vert', 'Bleu']);

// Effacer tous les √©l√©ments
ComboBox1.Items.Clear;

// Nombre d'√©l√©ments
NombreOptions := ComboBox1.Items.Count;

// Acc√©der √† un √©l√©ment
PremierElement := ComboBox1.Items[0];
```

Vous pouvez aussi remplir Items au moment de la conception via l'Inspecteur d'objets en cliquant sur le bouton [...].

#### 2. ItemIndex - L'√©l√©ment s√©lectionn√©

Indique quel √©l√©ment est actuellement s√©lectionn√© :

```pascal
// S√©lectionner le premier √©l√©ment (index 0)
ComboBox1.ItemIndex := 0;

// S√©lectionner le troisi√®me √©l√©ment
ComboBox1.ItemIndex := 2;

// Aucune s√©lection
ComboBox1.ItemIndex := -1;

// V√©rifier quelle option est s√©lectionn√©e
if ComboBox1.ItemIndex >= 0 then
  ShowMessage('S√©lection : ' + ComboBox1.Items[ComboBox1.ItemIndex]);
```

**Important :** ItemIndex commence √† 0 (comme tous les indices en programmation).

#### 3. Text - Le texte affich√©

Contient le texte actuellement affich√© dans la ComboBox :

```pascal
// R√©cup√©rer le texte
OptionChoisie := ComboBox1.Text;

// D√©finir le texte (si le style le permet)
ComboBox1.Text := 'Nouvelle valeur';
```

#### 4. Style - Le style de la ComboBox

D√©termine comment l'utilisateur peut interagir avec la ComboBox :

**csDropDown** : √âditable avec liste d√©roulante (par d√©faut)
- L'utilisateur peut taper du texte OU s√©lectionner dans la liste

```pascal
ComboBox1.Style := csDropDown;
```

**csDropDownList** : S√©lection uniquement dans la liste
- L'utilisateur ne peut QUE s√©lectionner dans la liste, pas taper

```pascal
ComboBox1.Style := csDropDownList;
```

**csSimple** : Liste toujours visible
- La liste est toujours affich√©e (pas de bouton d√©roulant)

```pascal
ComboBox1.Style := csSimple;
```

**Recommandation :** Utilisez `csDropDownList` pour forcer la s√©lection d'une option valide.

#### 5. Sorted - Tri automatique

Si True, les √©l√©ments sont automatiquement tri√©s par ordre alphab√©tique :

```pascal
ComboBox1.Sorted := True;  // Tri alphab√©tique
ComboBox1.Sorted := False; // Ordre d'insertion (par d√©faut)
```

#### 6. DropDownCount - Nombre d'√©l√©ments visibles

D√©finit combien d'√©l√©ments sont visibles quand la liste est d√©roul√©e :

```pascal
ComboBox1.DropDownCount := 8;  // Affiche 8 √©l√©ments (par d√©faut)
ComboBox1.DropDownCount := 15; // Affiche 15 √©l√©ments
```

#### 7. MaxLength - Longueur maximale de saisie

Pour les styles √©ditables, limite le nombre de caract√®res :

```pascal
ComboBox1.MaxLength := 50;  // Maximum 50 caract√®res
```

#### 8. TextHint - Texte indicatif

Comme pour TEdit, affiche un texte d'aide quand rien n'est s√©lectionn√© :

```pascal
ComboBox1.TextHint := 'S√©lectionnez une option...';
```

### Utilisation pratique de TComboBox

#### Exemple 1 : Liste de pays

```pascal
procedure TForm1.FormCreate(Sender: TObject);
begin
  ComboBoxPays.Items.Clear;
  ComboBoxPays.Items.AddStrings(['France', 'Belgique', 'Suisse',
                                  'Canada', 'Luxembourg']);
  ComboBoxPays.Style := csDropDownList;
  ComboBoxPays.ItemIndex := 0;  // France par d√©faut
end;

procedure TForm1.ComboBoxPaysChange(Sender: TObject);
begin
  case ComboBoxPays.ItemIndex of
    0: LabelCode.Caption := 'FR';
    1: LabelCode.Caption := 'BE';
    2: LabelCode.Caption := 'CH';
    3: LabelCode.Caption := 'CA';
    4: LabelCode.Caption := 'LU';
  end;
end;
```

#### Exemple 2 : Recherche avec historique

```pascal
procedure TForm1.BoutonRechercherClick(Sender: TObject);
var
  TexteRecherche: string;
begin
  TexteRecherche := ComboBoxRecherche.Text;

  if TexteRecherche = '' then
  begin
    ShowMessage('Veuillez saisir un terme de recherche');
    Exit;
  end;

  // Ajouter √† l'historique si pas d√©j√† pr√©sent
  if ComboBoxRecherche.Items.IndexOf(TexteRecherche) = -1 then
  begin
    ComboBoxRecherche.Items.Insert(0, TexteRecherche);

    // Limiter l'historique √† 10 √©l√©ments
    while ComboBoxRecherche.Items.Count > 10 do
      ComboBoxRecherche.Items.Delete(ComboBoxRecherche.Items.Count - 1);
  end;

  // Effectuer la recherche
  EffectuerRecherche(TexteRecherche);
end;
```

#### Exemple 3 : Cat√©gories li√©es

```pascal
procedure TForm1.ComboBoxCategorieChange(Sender: TObject);
begin
  // Remplir la sous-cat√©gorie selon la cat√©gorie
  ComboBoxSousCategorie.Items.Clear;

  case ComboBoxCategorie.ItemIndex of
    0: // √âlectronique
      ComboBoxSousCategorie.Items.AddStrings(['T√©l√©phones', 'Ordinateurs', 'Tablettes']);
    1: // V√™tements
      ComboBoxSousCategorie.Items.AddStrings(['Homme', 'Femme', 'Enfant']);
    2: // Alimentation
      ComboBoxSousCategorie.Items.AddStrings(['Fruits', 'L√©gumes', 'Viande']);
  end;

  if ComboBoxSousCategorie.Items.Count > 0 then
    ComboBoxSousCategorie.ItemIndex := 0;
end;
```

#### Exemple 4 : Validation de s√©lection

```pascal
procedure TForm1.BoutonValiderClick(Sender: TObject);
begin
  if ComboBoxPays.ItemIndex = -1 then
  begin
    ShowMessage('Veuillez s√©lectionner un pays');
    ComboBoxPays.SetFocus;
    Exit;
  end;

  if ComboBoxVille.ItemIndex = -1 then
  begin
    ShowMessage('Veuillez s√©lectionner une ville');
    ComboBoxVille.SetFocus;
    Exit;
  end;

  // Traiter les donn√©es
  TraiterFormulaire;
end;
```

#### Exemple 5 : ComboBox avec objets personnalis√©s

```pascal
type
  TPersonne = class
    Nom: string;
    Age: Integer;
    constructor Create(const ANom: string; AAge: Integer);
  end;

constructor TPersonne.Create(const ANom: string; AAge: Integer);
begin
  Nom := ANom;
  Age := AAge;
end;

procedure TForm1.FormCreate(Sender: TObject);
var
  Personne: TPersonne;
begin
  // Ajouter des personnes
  Personne := TPersonne.Create('Alice', 25);
  ComboBox1.Items.AddObject(Personne.Nom, Personne);

  Personne := TPersonne.Create('Bob', 30);
  ComboBox1.Items.AddObject(Personne.Nom, Personne);
end;

procedure TForm1.ComboBox1Change(Sender: TObject);
var
  Personne: TPersonne;
begin
  if ComboBox1.ItemIndex >= 0 then
  begin
    Personne := TPersonne(ComboBox1.Items.Objects[ComboBox1.ItemIndex]);
    ShowMessage(Format('%s a %d ans', [Personne.Nom, Personne.Age]));
  end;
end;

procedure TForm1.FormDestroy(Sender: TObject);
var
  i: Integer;
begin
  // Lib√©rer la m√©moire
  for i := 0 to ComboBox1.Items.Count - 1 do
    ComboBox1.Items.Objects[i].Free;
end;
```

### √âv√©nements importants de TComboBox

**OnChange** : D√©clench√© quand la s√©lection change

```pascal
procedure TForm1.ComboBox1Change(Sender: TObject);
begin
  if ComboBox1.ItemIndex >= 0 then
    LabelSelection.Caption := 'Vous avez choisi : ' + ComboBox1.Text;
end;
```

**OnSelect** : D√©clench√© quand un √©l√©ment est s√©lectionn√© dans la liste

```pascal
procedure TForm1.ComboBox1Select(Sender: TObject);
begin
  // Traiter la s√©lection
end;
```

**OnDropDown** : D√©clench√© quand la liste se d√©roule

```pascal
procedure TForm1.ComboBox1DropDown(Sender: TObject);
begin
  // Actualiser la liste si n√©cessaire
  MettreAJourListe;
end;
```

### Astuces et bonnes pratiques pour TComboBox

#### 1. V√©rifier la s√©lection avant utilisation

```pascal
if ComboBox1.ItemIndex >= 0 then
  // Traiter la s√©lection
else
  ShowMessage('Veuillez s√©lectionner une option');
```

#### 2. Utiliser csDropDownList pour les listes ferm√©es

Si l'utilisateur doit choisir parmi des options pr√©d√©finies, utilisez `csDropDownList`.

#### 3. Valeur par d√©faut intelligente

D√©finissez toujours une valeur par d√©faut logique :

```pascal
ComboBoxPays.ItemIndex := 0;  // Premi√®re option par d√©faut
```

#### 4. Trier ou ne pas trier

Activez le tri (`Sorted := True`) sauf si l'ordre a une signification (par exemple, ordre de priorit√©).

#### 5. Adapter DropDownCount

Ajustez selon le nombre d'√©l√©ments :

```pascal
if ComboBox1.Items.Count < 8 then
  ComboBox1.DropDownCount := ComboBox1.Items.Count
else
  ComboBox1.DropDownCount := 8;
```

#### 6. Lib√©rer les objets associ√©s

Si vous utilisez AddObject, n'oubliez pas de lib√©rer les objets dans FormDestroy.

## Comparaison rapide des trois composants

| Caract√©ristique | TEdit | TMemo | TComboBox |
|----------------|-------|-------|-----------|
| Nombre de lignes | Une | Multiple | Une |
| Saisie libre | Oui | Oui | Selon style |
| Liste pr√©d√©finie | Non | Non | Oui |
| Barres de d√©filement | Non | Oui | Non |
| Id√©al pour | Texte court | Texte long | S√©lection |

## Validation des saisies - Bonnes pratiques g√©n√©rales

### 1. Validation en temps r√©el

```pascal
procedure TForm1.EditEmailChange(Sender: TObject);
begin
  if Pos('@', EditEmail.Text) > 0 then
    EditEmail.Color := clWindow
  else
    EditEmail.Color := $C0C0FF;  // Rouge clair
end;
```

### 2. Validation √† la perte de focus

```pascal
procedure TForm1.EditEmailExit(Sender: TObject);
begin
  if (EditEmail.Text <> '') and (Pos('@', EditEmail.Text) = 0) then
  begin
    ShowMessage('L''adresse email doit contenir un @');
    EditEmail.SetFocus;
  end;
end;
```

### 3. Validation globale avant soumission

```pascal
function TForm1.ValiderFormulaire: Boolean;
begin
  Result := False;

  if Trim(EditNom.Text) = '' then
  begin
    ShowMessage('Le nom est obligatoire');
    EditNom.SetFocus;
    Exit;
  end;

  if ComboBoxPays.ItemIndex = -1 then
  begin
    ShowMessage('Veuillez s√©lectionner un pays');
    ComboBoxPays.SetFocus;
    Exit;
  end;

  Result := True;
end;

procedure TForm1.BoutonValiderClick(Sender: TObject);
begin
  if ValiderFormulaire then
    EnregistrerDonnees;
end;
```

### 4. Feedback visuel

```pascal
procedure TForm1.MarquerChampErreur(Control: TWinControl);
begin
  if Control is TEdit then
    TEdit(Control).Color := $C0C0FF
  else if Control is TComboBox then
    TComboBox(Control).Color := $C0C0FF;

  Control.SetFocus;
end;

procedure TForm1.ResetCouleurs;
begin
  EditNom.Color := clWindow;
  EditEmail.Color := clWindow;
  ComboBoxPays.Color := clWindow;
end;
```

## Conclusion

Les contr√¥les de saisie **TEdit**, **TMemo** et **TComboBox** sont essentiels dans pratiquement toutes les applications Delphi. Ils constituent l'interface principale entre l'utilisateur et les donn√©es de votre application.

**Points cl√©s √† retenir :**

**TEdit :**
- Pour la saisie de texte sur une ligne
- Utilisez MaxLength pour limiter la saisie
- TextHint pour guider l'utilisateur
- PasswordChar pour masquer les mots de passe
- Validez toujours les saisies

**TMemo :**
- Pour la saisie de texte multi-lignes
- Utilisez Lines pour manipuler le contenu
- ScrollBars et WordWrap pour le confort
- ReadOnly pour afficher des logs
- BeginUpdate/EndUpdate pour les performances

**TComboBox :**
- Pour la s√©lection dans une liste ou saisie combin√©e
- Items pour g√©rer la liste
- ItemIndex pour la s√©lection
- Style pour contr√¥ler le comportement
- csDropDownList pour forcer une s√©lection valide

En ma√Ætrisant ces trois composants et en appliquant les bonnes pratiques de validation, vous pouvez cr√©er des formulaires de saisie robustes, intuitifs et professionnels.

Dans la section suivante, nous explorerons les boutons et les actions, qui permettent √† l'utilisateur de d√©clencher des op√©rations dans votre application.

‚è≠Ô∏è [Boutons et actions](/04-conception-dinterfaces-utilisateur-avec-la-vcl/03.3-boutons-et-actions.md)
