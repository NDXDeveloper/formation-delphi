üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.10.1 Applications graphiques Linux avec FireMonkey

## Introduction

Maintenant que nous avons explor√© les bases de FMXLinux, passons √† la pratique avec des exemples concrets d'applications graphiques Linux. Cette section vous guidera √† travers la cr√©ation d'applications r√©elles, en respectant les conventions et les attentes des utilisateurs Linux, tout en tirant parti de la puissance de FireMonkey.

## 1. Philosophie des applications Linux

### Principes de conception

Les utilisateurs Linux ont des attentes sp√©cifiques concernant leurs applications :

**Simplicit√© et efficacit√©** :
- Interfaces √©pur√©es et fonctionnelles
- Pas de fioritures inutiles
- Accent sur la productivit√©

**Configurabilit√©** :
- Options en ligne de commande
- Fichiers de configuration √©ditables
- Personnalisation pouss√©e

**Int√©gration syst√®me** :
- Respect du th√®me syst√®me
- Utilisation des standards (XDG, FreeDesktop)
- Interop√©rabilit√© avec d'autres outils

**Transparence** :
- Logs accessibles
- Messages d'erreur informatifs
- Open source appr√©ci√© (mais pas obligatoire)

### Conventions d'interface

**Menus et organisation** :
```
Application
‚îú‚îÄ‚îÄ Fichier (File)
‚îÇ   ‚îú‚îÄ‚îÄ Nouveau
‚îÇ   ‚îú‚îÄ‚îÄ Ouvrir
‚îÇ   ‚îú‚îÄ‚îÄ Enregistrer
‚îÇ   ‚îî‚îÄ‚îÄ Quitter
‚îú‚îÄ‚îÄ √âdition (Edit)
‚îÇ   ‚îú‚îÄ‚îÄ Annuler
‚îÇ   ‚îú‚îÄ‚îÄ Refaire
‚îÇ   ‚îú‚îÄ‚îÄ Copier
‚îÇ   ‚îî‚îÄ‚îÄ Coller
‚îú‚îÄ‚îÄ Affichage (View)
‚îî‚îÄ‚îÄ Aide (Help)
    ‚îú‚îÄ‚îÄ Documentation
    ‚îî‚îÄ‚îÄ √Ä propos
```

**Raccourcis clavier standards** :
- Ctrl+N : Nouveau
- Ctrl+O : Ouvrir
- Ctrl+S : Enregistrer
- Ctrl+Q : Quitter
- Ctrl+Z : Annuler
- Ctrl+Y : Refaire
- Ctrl+C : Copier
- Ctrl+V : Coller

## 2. Application de visualisation de fichiers

### Objectif

Cr√©er un explorateur de fichiers simple avec pr√©visualisation d'images et de texte.

### Interface

```pascal
unit ViewerMain;

interface

uses
  System.SysUtils, System.Types, System.UITypes, System.Classes,
  System.IOUtils, System.Variants,
  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,
  FMX.ListView.Types, FMX.ListView.Appearances, FMX.ListView.Adapters.Base,
  FMX.StdCtrls, FMX.ListView, FMX.Layouts, FMX.TreeView, FMX.Objects,
  FMX.ScrollBox, FMX.Memo, FMX.Controls.Presentation;

type
  TFormViewer = class(TForm)
    LayoutPrincipal: TLayout;
    LayoutGauche: TLayout;
    LayoutDroite: TLayout;
    TreeViewDossiers: TTreeView;
    ListViewFichiers: TListView;
    LayoutPreview: TLayout;
    ImagePreview: TImage;
    MemoPreview: TMemo;
    ToolBar1: TToolBar;
    LabelChemin: TLabel;
    ButtonRemonter: TButton;
    Splitter1: TSplitter;
    Splitter2: TSplitter;
    procedure FormCreate(Sender: TObject);
    procedure TreeViewDossiersChange(Sender: TObject);
    procedure ListViewFichiersItemClick(const Sender: TObject;
      const AItem: TListViewItem);
    procedure ButtonRemonterClick(Sender: TObject);
  private
    FCheminActuel: string;
    procedure ChargerArborescence(const CheminRacine: string);
    procedure AjouterDossier(Parent: TTreeViewItem; const Chemin: string);
    procedure ChargerFichiers(const Chemin: string);
    procedure PrevisualiserFichier(const Fichier: string);
    function EstImage(const Extension: string): Boolean;
    function EstTexte(const Extension: string): Boolean;
  public
    { D√©clarations publiques }
  end;

var
  FormViewer: TFormViewer;

implementation

{$R *.fmx}

procedure TFormViewer.FormCreate(Sender: TObject);
begin
  Caption := 'Explorateur de fichiers Linux';

  {$IFDEF LINUX}
  // D√©marrer dans le home de l'utilisateur
  FCheminActuel := TPath.GetHomePath;
  {$ELSE}
  FCheminActuel := TPath.GetDocumentsPath;
  {$ENDIF}

  // Configurer les layouts
  LayoutGauche.Width := 200;
  LayoutDroite.Align := TAlignLayout.Client;

  // Masquer la pr√©visualisation par d√©faut
  ImagePreview.Visible := False;
  MemoPreview.Visible := False;

  // Charger l'arborescence
  ChargerArborescence(FCheminActuel);
  ChargerFichiers(FCheminActuel);

  LabelChemin.Text := FCheminActuel;
end;

procedure TFormViewer.ChargerArborescence(const CheminRacine: string);
var
  RootItem: TTreeViewItem;
begin
  TreeViewDossiers.Clear;
  TreeViewDossiers.BeginUpdate;
  try
    RootItem := TTreeViewItem.Create(TreeViewDossiers);
    RootItem.Parent := TreeViewDossiers;
    RootItem.Text := TPath.GetFileName(CheminRacine);
    RootItem.TagString := CheminRacine;

    AjouterDossier(RootItem, CheminRacine);
    RootItem.Expand;
  finally
    TreeViewDossiers.EndUpdate;
  end;
end;

procedure TFormViewer.AjouterDossier(Parent: TTreeViewItem; const Chemin: string);
var
  Dossiers: TStringDynArray;
  Dossier: string;
  Item: TTreeViewItem;
begin
  try
    Dossiers := TDirectory.GetDirectories(Chemin);
    for Dossier in Dossiers do
    begin
      // Ignorer les dossiers cach√©s
      if TPath.GetFileName(Dossier).StartsWith('.') then
        Continue;

      Item := TTreeViewItem.Create(Parent);
      Item.Parent := Parent;
      Item.Text := TPath.GetFileName(Dossier);
      Item.TagString := Dossier;
    end;
  except
    // Ignorer les erreurs de permission
  end;
end;

procedure TFormViewer.TreeViewDossiersChange(Sender: TObject);
var
  Item: TTreeViewItem;
begin
  Item := TreeViewDossiers.Selected;
  if Assigned(Item) then
  begin
    FCheminActuel := Item.TagString;
    LabelChemin.Text := FCheminActuel;
    ChargerFichiers(FCheminActuel);

    // Charger les sous-dossiers si pas encore fait
    if Item.Count = 0 then
      AjouterDossier(Item, Item.TagString);
  end;
end;

procedure TFormViewer.ChargerFichiers(const Chemin: string);
var
  Fichiers: TStringDynArray;
  Fichier: string;
  Item: TListViewItem;
  Taille: Int64;
  Info: TSearchRec;
begin
  ListViewFichiers.BeginUpdate;
  try
    ListViewFichiers.Items.Clear;

    try
      Fichiers := TDirectory.GetFiles(Chemin);
      for Fichier in Fichiers do
      begin
        // Ignorer les fichiers cach√©s
        if TPath.GetFileName(Fichier).StartsWith('.') then
          Continue;

        Item := ListViewFichiers.Items.Add;
        Item.Text := TPath.GetFileName(Fichier);
        Item.TagString := Fichier;

        // Ajouter la taille
        if FindFirst(Fichier, faAnyFile, Info) = 0 then
        begin
          Taille := Info.Size;
          if Taille < 1024 then
            Item.Detail := Format('%d octets', [Taille])
          else if Taille < 1024 * 1024 then
            Item.Detail := Format('%.1f Ko', [Taille / 1024])
          else
            Item.Detail := Format('%.1f Mo', [Taille / (1024 * 1024)]);
          FindClose(Info);
        end;
      end;
    except
      // Ignorer les erreurs de permission
    end;
  finally
    ListViewFichiers.EndUpdate;
  end;
end;

procedure TFormViewer.ListViewFichiersItemClick(const Sender: TObject;
  const AItem: TListViewItem);
begin
  if Assigned(AItem) then
    PrevisualiserFichier(AItem.TagString);
end;

procedure TFormViewer.PrevisualiserFichier(const Fichier: string);
var
  Extension: string;
begin
  Extension := TPath.GetExtension(Fichier).ToLower;

  // Masquer tout d'abord
  ImagePreview.Visible := False;
  MemoPreview.Visible := False;

  if EstImage(Extension) then
  begin
    // Pr√©visualisation image
    try
      ImagePreview.Bitmap.LoadFromFile(Fichier);
      ImagePreview.Visible := True;
    except
      on E: Exception do
        ShowMessage('Erreur chargement image : ' + E.Message);
    end;
  end
  else if EstTexte(Extension) then
  begin
    // Pr√©visualisation texte
    try
      MemoPreview.Lines.LoadFromFile(Fichier);
      MemoPreview.Visible := True;
    except
      on E: Exception do
        ShowMessage('Erreur chargement texte : ' + E.Message);
    end;
  end
  else
  begin
    ShowMessage('Type de fichier non support√© pour la pr√©visualisation');
  end;
end;

function TFormViewer.EstImage(const Extension: string): Boolean;
begin
  Result := (Extension = '.jpg') or (Extension = '.jpeg') or
            (Extension = '.png') or (Extension = '.bmp') or
            (Extension = '.gif');
end;

function TFormViewer.EstTexte(const Extension: string): Boolean;
begin
  Result := (Extension = '.txt') or (Extension = '.pas') or
            (Extension = '.log') or (Extension = '.ini') or
            (Extension = '.conf') or (Extension = '.sh') or
            (Extension = '.py') or (Extension = '.xml') or
            (Extension = '.json');
end;

procedure TFormViewer.ButtonRemonterClick(Sender: TObject);
var
  CheminParent: string;
begin
  CheminParent := TPath.GetDirectoryName(FCheminActuel);
  if not CheminParent.IsEmpty then
  begin
    FCheminActuel := CheminParent;
    LabelChemin.Text := FCheminActuel;
    ChargerArborescence(FCheminActuel);
    ChargerFichiers(FCheminActuel);
  end;
end;

end.
```

### Fonctionnalit√©s

‚úÖ **Navigation** : Arborescence des dossiers
‚úÖ **Liste de fichiers** : Avec taille
‚úÖ **Pr√©visualisation** : Images et fichiers texte
‚úÖ **Respecte les conventions** : Ignore les fichiers cach√©s (.)
‚úÖ **Gestion des permissions** : N'affiche pas les erreurs intrusives

## 3. Application de prise de notes

### Objectif

Cr√©er un √©diteur de notes avec sauvegarde automatique et organisation par cat√©gories.

### Structure de l'application

```pascal
unit NotesMain;

interface

uses
  System.SysUtils, System.Types, System.UITypes, System.Classes,
  System.IOUtils, System.JSON,
  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,
  FMX.StdCtrls, FMX.Layouts, FMX.ListBox, FMX.Memo, FMX.Edit,
  FMX.Controls.Presentation, FMX.ScrollBox;

type
  TNote = record
    Titre: string;
    Contenu: string;
    Categorie: string;
    DateCreation: TDateTime;
    DateModification: TDateTime;
  end;

  TFormNotes = class(TForm)
    LayoutPrincipal: TLayout;
    LayoutGauche: TLayout;
    LayoutCentre: TLayout;
    ToolBarHaut: TToolBar;
    ButtonNouvelleNote: TButton;
    ButtonSauvegarder: TButton;
    ListBoxNotes: TListBox;
    EditTitre: TEdit;
    MemoContenu: TMemo;
    ComboBoxCategorie: TComboBox;
    LabelTitre: TLabel;
    LabelCategorie: TLabel;
    EditRecherche: TEdit;
    ButtonRechercher: TButton;
    LabelInfo: TLabel;
    TimerSauvegarde: TTimer;
    procedure FormCreate(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure ButtonNouvelleNoteClick(Sender: TObject);
    procedure ButtonSauvegarderClick(Sender: TObject);
    procedure ListBoxNotesItemClick(const Sender: TCustomListBox;
      const Item: TListBoxItem);
    procedure EditTitreChange(Sender: TObject);
    procedure MemoContenuChange(Sender: TObject);
    procedure ComboBoxCategorieChange(Sender: TObject);
    procedure ButtonRechercherClick(Sender: TObject);
    procedure TimerSauvegardeTimer(Sender: TObject);
  private
    FNotes: TArray<TNote>;
    FNoteActuelle: Integer;
    FModifie: Boolean;
    FCheminDonnees: string;
    procedure ChargerNotes;
    procedure SauvegarderNotes;
    procedure AfficherNote(Index: Integer);
    procedure MettreAJourListe;
    procedure NouvelleNote;
    procedure AutoSauvegarder;
    function CheminFichierNotes: string;
  public
    { D√©clarations publiques }
  end;

var
  FormNotes: TFormNotes;

implementation

{$R *.fmx}

procedure TFormNotes.FormCreate(Sender: TObject);
begin
  Caption := 'Gestionnaire de notes';

  {$IFDEF LINUX}
  // Utiliser le r√©pertoire standard Linux
  FCheminDonnees := TPath.Combine(
    TPath.GetHomePath,
    '.local', 'share', 'NotesApp'
  );
  {$ELSE}
  FCheminDonnees := TPath.Combine(
    TPath.GetDocumentsPath,
    'NotesApp'
  );
  {$ENDIF}

  // Cr√©er le r√©pertoire si n√©cessaire
  ForceDirectories(FCheminDonnees);

  // Configuration interface
  LayoutGauche.Width := 250;
  FNoteActuelle := -1;
  FModifie := False;

  // Cat√©gories pr√©d√©finies
  ComboBoxCategorie.Items.Add('Personnel');
  ComboBoxCategorie.Items.Add('Travail');
  ComboBoxCategorie.Items.Add('Id√©es');
  ComboBoxCategorie.Items.Add('√Ä faire');
  ComboBoxCategorie.Items.Add('Autres');

  // Sauvegarde auto toutes les 30 secondes
  TimerSauvegarde.Interval := 30000;
  TimerSauvegarde.Enabled := True;

  // Charger les notes existantes
  ChargerNotes;
  MettreAJourListe;
end;

function TFormNotes.CheminFichierNotes: string;
begin
  Result := TPath.Combine(FCheminDonnees, 'notes.json');
end;

procedure TFormNotes.ChargerNotes;
var
  JSON: TJSONArray;
  JSONNote: TJSONObject;
  Note: TNote;
  i: Integer;
  Contenu: string;
begin
  SetLength(FNotes, 0);

  if not FileExists(CheminFichierNotes) then
    Exit;

  try
    Contenu := TFile.ReadAllText(CheminFichierNotes);
    JSON := TJSONObject.ParseJSONValue(Contenu) as TJSONArray;
    try
      for i := 0 to JSON.Count - 1 do
      begin
        JSONNote := JSON.Items[i] as TJSONObject;

        Note.Titre := JSONNote.GetValue<string>('titre');
        Note.Contenu := JSONNote.GetValue<string>('contenu');
        Note.Categorie := JSONNote.GetValue<string>('categorie');
        Note.DateCreation := JSONNote.GetValue<TDateTime>('dateCreation');
        Note.DateModification := JSONNote.GetValue<TDateTime>('dateModification');

        SetLength(FNotes, Length(FNotes) + 1);
        FNotes[High(FNotes)] := Note;
      end;
    finally
      JSON.Free;
    end;
  except
    on E: Exception do
      ShowMessage('Erreur chargement notes : ' + E.Message);
  end;
end;

procedure TFormNotes.SauvegarderNotes;
var
  JSON: TJSONArray;
  JSONNote: TJSONObject;
  Note: TNote;
begin
  JSON := TJSONArray.Create;
  try
    for Note in FNotes do
    begin
      JSONNote := TJSONObject.Create;
      JSONNote.AddPair('titre', Note.Titre);
      JSONNote.AddPair('contenu', Note.Contenu);
      JSONNote.AddPair('categorie', Note.Categorie);
      JSONNote.AddPair('dateCreation', TJSONNumber.Create(Note.DateCreation));
      JSONNote.AddPair('dateModification', TJSONNumber.Create(Note.DateModification));
      JSON.AddElement(JSONNote);
    end;

    TFile.WriteAllText(CheminFichierNotes, JSON.ToString);
    FModifie := False;
    LabelInfo.Text := 'Sauvegard√© √† ' + TimeToStr(Now);
  except
    on E: Exception do
      ShowMessage('Erreur sauvegarde : ' + E.Message);
  end;

  JSON.Free;
end;

procedure TFormNotes.MettreAJourListe;
var
  i: Integer;
  Item: TListBoxItem;
  DateStr: string;
begin
  ListBoxNotes.BeginUpdate;
  try
    ListBoxNotes.Clear;

    for i := 0 to High(FNotes) do
    begin
      Item := TListBoxItem.Create(ListBoxNotes);
      Item.Parent := ListBoxNotes;
      Item.Text := FNotes[i].Titre;

      DateStr := FormatDateTime('dd/mm/yyyy', FNotes[i].DateModification);
      Item.ItemData.Detail := FNotes[i].Categorie + ' - ' + DateStr;
      Item.Tag := i;
    end;
  finally
    ListBoxNotes.EndUpdate;
  end;
end;

procedure TFormNotes.NouvelleNote;
var
  Note: TNote;
begin
  // Sauvegarder la note actuelle si modifi√©e
  if FModifie then
    AutoSauvegarder;

  // Cr√©er nouvelle note
  Note.Titre := 'Nouvelle note';
  Note.Contenu := '';
  Note.Categorie := 'Personnel';
  Note.DateCreation := Now;
  Note.DateModification := Now;

  SetLength(FNotes, Length(FNotes) + 1);
  FNotes[High(FNotes)] := Note;

  FNoteActuelle := High(FNotes);
  AfficherNote(FNoteActuelle);
  MettreAJourListe;

  EditTitre.SetFocus;
end;

procedure TFormNotes.AfficherNote(Index: Integer);
begin
  if (Index < 0) or (Index > High(FNotes)) then
    Exit;

  FNoteActuelle := Index;
  EditTitre.Text := FNotes[Index].Titre;
  MemoContenu.Text := FNotes[Index].Contenu;
  ComboBoxCategorie.ItemIndex := ComboBoxCategorie.Items.IndexOf(FNotes[Index].Categorie);

  FModifie := False;
end;

procedure TFormNotes.AutoSauvegarder;
begin
  if (FNoteActuelle >= 0) and (FNoteActuelle <= High(FNotes)) then
  begin
    FNotes[FNoteActuelle].Titre := EditTitre.Text;
    FNotes[FNoteActuelle].Contenu := MemoContenu.Text;
    FNotes[FNoteActuelle].Categorie := ComboBoxCategorie.Selected.Text;
    FNotes[FNoteActuelle].DateModification := Now;

    SauvegarderNotes;
    MettreAJourListe;
  end;
end;

procedure TFormNotes.ButtonNouvelleNoteClick(Sender: TObject);
begin
  NouvelleNote;
end;

procedure TFormNotes.ButtonSauvegarderClick(Sender: TObject);
begin
  AutoSauvegarder;
end;

procedure TFormNotes.ListBoxNotesItemClick(const Sender: TCustomListBox;
  const Item: TListBoxItem);
begin
  if FModifie then
    AutoSauvegarder;

  AfficherNote(Item.Tag);
end;

procedure TFormNotes.EditTitreChange(Sender: TObject);
begin
  FModifie := True;
end;

procedure TFormNotes.MemoContenuChange(Sender: TObject);
begin
  FModifie := True;
end;

procedure TFormNotes.ComboBoxCategorieChange(Sender: TObject);
begin
  FModifie := True;
end;

procedure TFormNotes.ButtonRechercherClick(Sender: TObject);
var
  Recherche: string;
  i: Integer;
  Item: TListBoxItem;
begin
  Recherche := EditRecherche.Text.ToLower;
  if Recherche.IsEmpty then
  begin
    MettreAJourListe;
    Exit;
  end;

  ListBoxNotes.BeginUpdate;
  try
    ListBoxNotes.Clear;

    for i := 0 to High(FNotes) do
    begin
      if FNotes[i].Titre.ToLower.Contains(Recherche) or
         FNotes[i].Contenu.ToLower.Contains(Recherche) then
      begin
        Item := TListBoxItem.Create(ListBoxNotes);
        Item.Parent := ListBoxNotes;
        Item.Text := FNotes[i].Titre;
        Item.ItemData.Detail := FNotes[i].Categorie;
        Item.Tag := i;
      end;
    end;
  finally
    ListBoxNotes.EndUpdate;
  end;
end;

procedure TFormNotes.TimerSauvegardeTimer(Sender: TObject);
begin
  if FModifie then
    AutoSauvegarder;
end;

procedure TFormNotes.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  if FModifie then
    AutoSauvegarder;
end;

end.
```

### Fonctionnalit√©s

‚úÖ **Cr√©ation/√©dition** : Notes avec titre et contenu
‚úÖ **Cat√©gories** : Organisation par cat√©gorie
‚úÖ **Recherche** : Recherche dans titre et contenu
‚úÖ **Sauvegarde auto** : Toutes les 30 secondes
‚úÖ **Persistance** : Format JSON dans r√©pertoire standard Linux
‚úÖ **Horodatage** : Date cr√©ation et modification

## 4. Application de monitoring syst√®me

### Objectif

Dashboard de surveillance des ressources syst√®me.

### Interface de monitoring

```pascal
unit SystemMonitor;

interface

uses
  System.SysUtils, System.Types, System.UITypes, System.Classes,
  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,
  FMX.StdCtrls, FMX.Layouts, FMX.Objects, FMX.Controls.Presentation,
  {$IFDEF LINUX}
  Posix.SysUtsname, Posix.Stdlib,
  {$ENDIF}
  System.IOUtils;

type
  TFormMonitor = class(TForm)
    LayoutPrincipal: TLayout;
    LayoutCPU: TLayout;
    LayoutMemoire: TLayout;
    LayoutDisque: TLayout;
    RectangleCPU: TRectangle;
    RectangleMemoire: TRectangle;
    RectangleDisque: TRectangle;
    LabelCPUTitre: TLabel;
    LabelCPUValeur: TLabel;
    ProgressBarCPU: TProgressBar;
    LabelMemoireTitre: TLabel;
    LabelMemoireValeur: TLabel;
    ProgressBarMemoire: TProgressBar;
    LabelDisqueTitre: TLabel;
    LabelDisqueValeur: TLabel;
    ProgressBarDisque: TProgressBar;
    TimerUpdate: TTimer;
    LabelSysteme: TLabel;
    RectangleInfo: TRectangle;
    LabelNoyau: TLabel;
    LabelArch: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure TimerUpdateTimer(Sender: TObject);
  private
    {$IFDEF LINUX}
    function ObtenirUtilisationCPU: Single;
    function ObtenirUtilisationMemoire: Single;
    function ObtenirUtilisationDisque: Single;
    function ObtenirInfosSysteme: string;
    procedure LireStatCPU(var Total, Idle: Int64);
    {$ENDIF}
    FLastTotal, FLastIdle: Int64;
  public
    { D√©clarations publiques }
  end;

var
  FormMonitor: TFormMonitor;

implementation

{$R *.fmx}

procedure TFormMonitor.FormCreate(Sender: TObject);
begin
  Caption := 'Moniteur Syst√®me Linux';

  {$IFDEF LINUX}
  // Afficher les infos syst√®me
  LabelSysteme.Text := ObtenirInfosSysteme;

  // Initialiser les valeurs CPU
  LireStatCPU(FLastTotal, FLastIdle);
  {$ELSE}
  LabelSysteme.Text := 'Application Linux uniquement';
  TimerUpdate.Enabled := False;
  {$ENDIF}

  // Configurer l'interface
  LayoutCPU.Height := 100;
  LayoutMemoire.Height := 100;
  LayoutDisque.Height := 100;

  RectangleCPU.Fill.Color := $FF4CAF50;
  RectangleMemoire.Fill.Color := $FF2196F3;
  RectangleDisque.Fill.Color := $FFFF9800;

  // D√©marrer les mises √† jour
  TimerUpdate.Interval := 2000;  // 2 secondes
  TimerUpdate.Enabled := True;
end;

{$IFDEF LINUX}

function TFormMonitor.ObtenirInfosSysteme: string;
var
  UtsName: utsname;
begin
  if uname(UtsName) = 0 then
  begin
    LabelNoyau.Text := 'Noyau : ' + string(UtsName.release);
    LabelArch.Text := 'Architecture : ' + string(UtsName.machine);
    Result := Format('%s %s', [string(UtsName.sysname), string(UtsName.release)]);
  end
  else
    Result := 'Informations non disponibles';
end;

procedure TFormMonitor.LireStatCPU(var Total, Idle: Int64);
var
  Fichier: TextFile;
  Ligne: string;
  Valeurs: TArray<string>;
  i: Integer;
  Somme: Int64;
begin
  Total := 0;
  Idle := 0;

  if not FileExists('/proc/stat') then
    Exit;

  try
    AssignFile(Fichier, '/proc/stat');
    Reset(Fichier);
    try
      ReadLn(Fichier, Ligne);

      // Ligne format : cpu  user nice system idle iowait irq softirq
      Valeurs := Ligne.Split([' '], TStringSplitOptions.ExcludeEmpty);

      if Length(Valeurs) >= 5 then
      begin
        // Calculer le total
        Somme := 0;
        for i := 1 to High(Valeurs) do
          Somme := Somme + StrToInt64Def(Valeurs[i], 0);

        Total := Somme;
        Idle := StrToInt64Def(Valeurs[4], 0);  // 4√®me valeur = idle
      end;
    finally
      CloseFile(Fichier);
    end;
  except
    // Ignorer les erreurs
  end;
end;

function TFormMonitor.ObtenirUtilisationCPU: Single;
var
  Total, Idle: Int64;
  DiffTotal, DiffIdle: Int64;
begin
  Result := 0;

  LireStatCPU(Total, Idle);

  DiffTotal := Total - FLastTotal;
  DiffIdle := Idle - FLastIdle;

  if DiffTotal > 0 then
    Result := (1 - (DiffIdle / DiffTotal)) * 100;

  FLastTotal := Total;
  FLastIdle := Idle;
end;

function TFormMonitor.ObtenirUtilisationMemoire: Single;
var
  Fichier: TextFile;
  Ligne: string;
  Valeurs: TArray<string>;
  MemTotal, MemFree, MemAvailable: Int64;
begin
  Result := 0;
  MemTotal := 0;
  MemFree := 0;
  MemAvailable := 0;

  if not FileExists('/proc/meminfo') then
    Exit;

  try
    AssignFile(Fichier, '/proc/meminfo');
    Reset(Fichier);
    try
      while not Eof(Fichier) do
      begin
        ReadLn(Fichier, Ligne);

        if Ligne.StartsWith('MemTotal:') then
        begin
          Valeurs := Ligne.Split([' ', ':'], TStringSplitOptions.ExcludeEmpty);
          MemTotal := StrToInt64Def(Valeurs[1], 0);
        end
        else if Ligne.StartsWith('MemAvailable:') then
        begin
          Valeurs := Ligne.Split([' ', ':'], TStringSplitOptions.ExcludeEmpty);
          MemAvailable := StrToInt64Def(Valeurs[1], 0);
          Break;  // On a tout ce qu'il faut
        end;
      end;

      if MemTotal > 0 then
        Result := ((MemTotal - MemAvailable) / MemTotal) * 100;
    finally
      CloseFile(Fichier);
    end;
  except
    // Ignorer les erreurs
  end;
end;

function TFormMonitor.ObtenirUtilisationDisque: Single;
var
  TotalBytes, FreeBytes: Int64;
begin
  Result := 0;

  try
    // Obtenir l'espace disque du home
    TotalBytes := TDirectory.GetDiskSpace(TPath.GetHomePath);
    FreeBytes := TDirectory.GetDiskFreeSpace(TPath.GetHomePath);

    if TotalBytes > 0 then
      Result := ((TotalBytes - FreeBytes) / TotalBytes) * 100;
  except
    // Ignorer les erreurs
  end;
end;

{$ENDIF}

procedure TFormMonitor.TimerUpdateTimer(Sender: TObject);
{$IFDEF LINUX}
var
  CPU, Mem, Disk: Single;
{$ENDIF}
begin
  {$IFDEF LINUX}
  // Mettre √† jour CPU
  CPU := ObtenirUtilisationCPU;
  ProgressBarCPU.Value := CPU;
  LabelCPUValeur.Text := Format('%.1f%%', [CPU]);

  // Mettre √† jour M√©moire
  Mem := ObtenirUtilisationMemoire;
  ProgressBarMemoire.Value := Mem;
  LabelMemoireValeur.Text := Format('%.1f%%', [Mem]);

  // Mettre √† jour Disque
  Disk := ObtenirUtilisationDisque;
  ProgressBarDisque.Value := Disk;
  LabelDisqueValeur.Text := Format('%.1f%%', [Disk]);
  {$ENDIF}
end;

end.
```

### Fonctionnalit√©s

‚úÖ **Monitoring temps r√©el** : CPU, m√©moire, disque
‚úÖ **Lecture /proc** : Utilise les fichiers syst√®me Linux
‚úÖ **Informations syst√®me** : Noyau, architecture
‚úÖ **Mise √† jour auto** : Toutes les 2 secondes
‚úÖ **Interface visuelle** : Barres de progression color√©es

## 5. Application de lancement rapide

### Objectif

Lanceur d'applications avec raccourcis personnalisables.

### Concepts cl√©s

```pascal
unit QuickLauncher;

interface

uses
  System.SysUtils, System.Types, System.UITypes, System.Classes,
  System.IOUtils, System.JSON,
  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,
  FMX.StdCtrls, FMX.Layouts, FMX.Objects, FMX.ListBox, FMX.Edit,
  FMX.Controls.Presentation,
  {$IFDEF LINUX}
  Posix.Stdlib,
  {$ENDIF}
  FMX.Grid.Style, FMX.ScrollBox, FMX.Grid;

type
  TApplication = record
    Nom: string;
    Commande: string;
    Icone: string;
    Categorie: string;
  end;

  TFormLauncher = class(TForm)
    LayoutPrincipal: TLayout;
    FlowLayoutApps: TFlowLayout;
    EditRecherche: TEdit;
    ButtonAjouter: TButton;
    procedure FormCreate(Sender: TObject);
    procedure EditRechercheChange(Sender: TObject);
    procedure ButtonAjouterClick(Sender: TObject);
  private
    FApplications: TArray<TApplication>;
    procedure ChargerApplications;
    procedure SauvegarderApplications;
    procedure AfficherApplications(const Filtre: string = '');
    procedure CreerBoutonApp(const App: TApplication);
    procedure LancerApplication(const Commande: string);
    function CheminFichierConfig: string;
  public
    { D√©clarations publiques }
  end;

var
  FormLauncher: TFormLauncher;

implementation

{$R *.fmx}

procedure TFormLauncher.FormCreate(Sender: TObject);
begin
  Caption := 'Lanceur Rapide';

  // Configuration du FlowLayout
  FlowLayoutApps.Align := TAlignLayout.Client;
  FlowLayoutApps.HorizontalGap := 10;
  FlowLayoutApps.VerticalGap := 10;
  FlowLayoutApps.Padding.Rect := TRectF.Create(10, 10, 10, 10);

  ChargerApplications;
  AfficherApplications;
end;

function TFormLauncher.CheminFichierConfig: string;
begin
  {$IFDEF LINUX}
  Result := TPath.Combine(
    TPath.GetHomePath,
    '.config', 'QuickLauncher', 'apps.json'
  );
  {$ELSE}
  Result := TPath.Combine(
    TPath.GetDocumentsPath,
    'QuickLauncher', 'apps.json'
  );
  {$ENDIF}
end;

procedure TFormLauncher.ChargerApplications;
var
  JSON: TJSONArray;
  JSONApp: TJSONObject;
  App: TApplication;
  i: Integer;
  Contenu: string;
begin
  SetLength(FApplications, 0);

  // Cr√©er le r√©pertoire si n√©cessaire
  ForceDirectories(TPath.GetDirectoryName(CheminFichierConfig));

  // Charger ou cr√©er applications par d√©faut
  if FileExists(CheminFichierConfig) then
  begin
    try
      Contenu := TFile.ReadAllText(CheminFichierConfig);
      JSON := TJSONObject.ParseJSONValue(Contenu) as TJSONArray;
      try
        for i := 0 to JSON.Count - 1 do
        begin
          JSONApp := JSON.Items[i] as TJSONObject;

          App.Nom := JSONApp.GetValue<string>('nom');
          App.Commande := JSONApp.GetValue<string>('commande');
          App.Icone := JSONApp.GetValue<string>('icone', '');
          App.Categorie := JSONApp.GetValue<string>('categorie', 'Autres');

          SetLength(FApplications, Length(FApplications) + 1);
          FApplications[High(FApplications)] := App;
        end;
      finally
        JSON.Free;
      end;
    except
      // En cas d'erreur, cr√©er applications par d√©faut
    end;
  end;

  // Si pas d'applications, cr√©er des exemples par d√©faut
  if Length(FApplications) = 0 then
  begin
    {$IFDEF LINUX}
    // Applications Linux courantes
    App.Nom := 'Terminal';
    App.Commande := 'gnome-terminal';
    App.Categorie := 'Syst√®me';
    SetLength(FApplications, Length(FApplications) + 1);
    FApplications[High(FApplications)] := App;

    App.Nom := 'Fichiers';
    App.Commande := 'nautilus';
    App.Categorie := 'Syst√®me';
    SetLength(FApplications, Length(FApplications) + 1);
    FApplications[High(FApplications)] := App;

    App.Nom := 'Firefox';
    App.Commande := 'firefox';
    App.Categorie := 'Internet';
    SetLength(FApplications, Length(FApplications) + 1);
    FApplications[High(FApplications)] := App;

    SauvegarderApplications;
    {$ENDIF}
  end;
end;

procedure TFormLauncher.SauvegarderApplications;
var
  JSON: TJSONArray;
  JSONApp: TJSONObject;
  App: TApplication;
begin
  JSON := TJSONArray.Create;
  try
    for App in FApplications do
    begin
      JSONApp := TJSONObject.Create;
      JSONApp.AddPair('nom', App.Nom);
      JSONApp.AddPair('commande', App.Commande);
      JSONApp.AddPair('icone', App.Icone);
      JSONApp.AddPair('categorie', App.Categorie);
      JSON.AddElement(JSONApp);
    end;

    TFile.WriteAllText(CheminFichierConfig, JSON.ToString);
  finally
    JSON.Free;
  end;
end;

procedure TFormLauncher.AfficherApplications(const Filtre: string);
var
  App: TApplication;
begin
  FlowLayoutApps.BeginUpdate;
  try
    // Vider le layout
    while FlowLayoutApps.ChildrenCount > 0 do
      FlowLayoutApps.Children[0].Free;

    // Ajouter les applications filtr√©es
    for App in FApplications do
    begin
      if Filtre.IsEmpty or
         App.Nom.ToLower.Contains(Filtre.ToLower) or
         App.Categorie.ToLower.Contains(Filtre.ToLower) then
      begin
        CreerBoutonApp(App);
      end;
    end;
  finally
    FlowLayoutApps.EndUpdate;
  end;
end;

procedure TFormLauncher.CreerBoutonApp(const App: TApplication);
var
  Layout: TLayout;
  Rect: TRectangle;
  Label1, Label2: TLabel;
begin
  // Cr√©er un layout pour l'application
  Layout := TLayout.Create(FlowLayoutApps);
  Layout.Parent := FlowLayoutApps;
  Layout.Width := 120;
  Layout.Height := 100;
  Layout.TagString := App.Commande;

  // Rectangle de fond
  Rect := TRectangle.Create(Layout);
  Rect.Parent := Layout;
  Rect.Align := TAlignLayout.Client;
  Rect.Fill.Color := $FF2196F3;
  Rect.Stroke.Color := $FF1976D2;
  Rect.Corners := [TCorner.TopLeft, TCorner.TopRight, TCorner.BottomLeft, TCorner.BottomRight];
  Rect.XRadius := 8;
  Rect.YRadius := 8;
  Rect.Cursor := crHandPoint;

  // Nom de l'application
  Label1 := TLabel.Create(Layout);
  Label1.Parent := Layout;
  Label1.Align := TAlignLayout.Top;
  Label1.Height := 40;
  Label1.Text := App.Nom;
  Label1.TextSettings.Font.Size := 14;
  Label1.TextSettings.FontColor := TAlphaColors.White;
  Label1.TextSettings.HorzAlign := TTextAlign.Center;
  Label1.TextSettings.VertAlign := TTextAlign.Center;
  Label1.Margins.Top := 20;

  // Cat√©gorie
  Label2 := TLabel.Create(Layout);
  Label2.Parent := Layout;
  Label2.Align := TAlignLayout.Bottom;
  Label2.Height := 20;
  Label2.Text := App.Categorie;
  Label2.TextSettings.Font.Size := 10;
  Label2.TextSettings.FontColor := $FFBBDEFB;
  Label2.TextSettings.HorzAlign := TTextAlign.Center;
  Label2.Margins.Bottom := 10;

  // √âv√©nement clic
  Rect.OnClick := procedure(Sender: TObject)
  begin
    LancerApplication(Layout.TagString);
  end;
end;

procedure TFormLauncher.LancerApplication(const Commande: string);
begin
  {$IFDEF LINUX}
  // Lancer en arri√®re-plan
  system(PAnsiChar(AnsiString(Commande + ' &')));
  {$ELSE}
  ShowMessage('Lancement : ' + Commande);
  {$ENDIF}
end;

procedure TFormLauncher.EditRechercheChange(Sender: TObject);
begin
  AfficherApplications(EditRecherche.Text);
end;

procedure TFormLauncher.ButtonAjouterClick(Sender: TObject);
var
  Nom, Commande, Categorie: string;
  App: TApplication;
begin
  // Dialogue simple pour ajouter une application
  if InputQuery('Nouvelle application', ['Nom', 'Commande', 'Cat√©gorie'],
                [Nom, Commande, Categorie]) then
  begin
    if not Nom.IsEmpty and not Commande.IsEmpty then
    begin
      App.Nom := Nom;
      App.Commande := Commande;
      App.Categorie := Categorie;
      App.Icone := '';

      SetLength(FApplications, Length(FApplications) + 1);
      FApplications[High(FApplications)] := App;

      SauvegarderApplications;
      AfficherApplications;
    end;
  end;
end;

end.
```

### Fonctionnalit√©s

‚úÖ **Grille d'applications** : Layout adaptatif
‚úÖ **Recherche** : Filtrage en temps r√©el
‚úÖ **Cat√©gories** : Organisation
‚úÖ **Personnalisable** : Ajout d'applications
‚úÖ **Persistance** : Configuration JSON
‚úÖ **Lancement** : Ex√©cution des commandes Linux

## 6. Bonnes pratiques pour applications Linux

### Interface

**1. Respecter les standards GTK/GNOME/KDE**
```pascal
// Suivre les conventions de nommage des menus
MainMenu.Items.Add('_Fichier');  // Underscore pour raccourci Alt
MainMenu.Items.Add('_√âdition');
MainMenu.Items.Add('_Affichage');
```

**2. Fournir des raccourcis clavier**
```pascal
// Raccourcis standards
ActionSave.ShortCut := scCtrl + Ord('S');
ActionQuit.ShortCut := scCtrl + Ord('Q');
ActionNew.ShortCut := scCtrl + Ord('N');
```

**3. Respecter le th√®me syst√®me**
```pascal
// FireMonkey s'adapte automatiquement au th√®me GTK
// Pas besoin de forcer les couleurs
```

### Stockage des donn√©es

**1. Utiliser les r√©pertoires standards**
```pascal
{$IFDEF LINUX}
// Configuration
CheminConfig := TPath.Combine(
  TPath.GetHomePath, '.config', 'MonApp'
);

// Donn√©es
CheminDonnees := TPath.Combine(
  TPath.GetHomePath, '.local', 'share', 'MonApp'
);

// Cache
CheminCache := TPath.Combine(
  TPath.GetHomePath, '.cache', 'MonApp'
);
{$ENDIF}
```

**2. Ne jamais n√©cessiter root**
```pascal
// ‚ùå MAUVAIS : √âcrire dans /etc/ ou /opt/
// ‚úÖ BON : √âcrire dans le home de l'utilisateur
```

### Int√©gration

**1. Cr√©er un fichier .desktop**
```ini
[Desktop Entry]
Version=1.0
Type=Application
Name=Mon Application
Exec=/opt/monapp/monapp
Icon=/opt/monapp/icon.png
Categories=Utility;
```

**2. Supporter les arguments ligne de commande**
```pascal
if ParamCount > 0 then
begin
  if ParamStr(1) = '--version' then
  begin
    WriteLn('MonApp version 1.0');
    Halt;
  end
  else if ParamStr(1) = '--help' then
  begin
    WriteLn('Usage: monapp [options]');
    WriteLn('Options:');
    WriteLn('  --version    Affiche la version');
    WriteLn('  --help       Affiche cette aide');
    Halt;
  end;
end;
```

## Conclusion

Le d√©veloppement d'applications graphiques Linux avec FireMonkey offre de nombreuses possibilit√©s. Les points cl√©s √† retenir :

üíª **FireMonkey sur Linux** : M√™me framework, applications natives Linux

üíª **GTK3** : Rendu natif et int√©gration syst√®me

üíª **Conventions Linux** : Respecter les standards et attentes des utilisateurs

üíª **R√©pertoires standards** : .config, .local/share, .cache

üíª **Ligne de commande** : Toujours une option appr√©ci√©e

üíª **Fichier .desktop** : Int√©gration au menu d'applications

üíª **Performance** : Applications compil√©es natives

üíª **D√©ploiement** : Multiple formats (.deb, AppImage, Flatpak)

Avec FMXLinux, vous pouvez cr√©er des applications Linux professionnelles et modernes tout en partageant votre code avec vos applications Windows, macOS, iOS et Android. C'est le v√©ritable d√©veloppement multi-plateforme avec Delphi.

‚è≠Ô∏è [Am√©liorations FireMonkey de Delphi 13](/05-developpement-multi-plateforme-avec-firemonkey/11-ameliorations-firemonkey-delphi-13.md)
