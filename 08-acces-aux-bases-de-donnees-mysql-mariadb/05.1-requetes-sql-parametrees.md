üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.5.1 Requ√™tes SQL et param√©tr√©es

## Introduction

Maintenant que vous savez √©tablir une connexion √† MySQL/MariaDB, il est temps d'apprendre √† communiquer avec la base de donn√©es en utilisant le **SQL** (Structured Query Language). Dans ce chapitre, nous allons d√©couvrir comment lire, ajouter, modifier et supprimer des donn√©es de mani√®re s√©curis√©e.

## Qu'est-ce que le SQL ?

**SQL** (prononc√© "essekiuel" ou "siquel") est un langage standardis√© pour communiquer avec les bases de donn√©es relationnelles. C'est comme un langage universel que comprennent MySQL, PostgreSQL, SQL Server, Oracle et la plupart des bases de donn√©es.

### Les 4 op√©rations principales

En SQL, on parle souvent de **CRUD** :

| Op√©ration | Signification | Commande SQL |
|-----------|---------------|--------------|
| **C**reate | Cr√©er/Ajouter | `INSERT` |
| **R**ead | Lire/Consulter | `SELECT` |
| **U**pdate | Modifier/Mettre √† jour | `UPDATE` |
| **D**elete | Supprimer | `DELETE` |

## Pr√©paration : Cr√©er une table de test

Avant de commencer, cr√©ons une table simple pour nos exemples. Utilisez HeidiSQL ou un autre outil pour ex√©cuter ce SQL :

```sql
-- Cr√©er une table clients
CREATE TABLE clients (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    prenom VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE,
    telephone VARCHAR(20),
    date_inscription DATE,
    actif BOOLEAN DEFAULT TRUE
);

-- Ins√©rer quelques donn√©es de test
INSERT INTO clients (nom, prenom, email, telephone, date_inscription) VALUES
('Dupont', 'Jean', 'jean.dupont@email.fr', '0601020304', '2024-01-15'),
('Martin', 'Sophie', 'sophie.martin@email.fr', '0605060708', '2024-02-20'),
('Bernard', 'Luc', 'luc.bernard@email.fr', '0609101112', '2024-03-10');
```

## Le composant TFDQuery

**TFDQuery** est votre outil principal pour ex√©cuter des requ√™tes SQL dans Delphi.

### Ajout du composant

1. Dans votre formulaire, ajoutez un **TFDQuery** (onglet FireDAC)
2. Nommez-le : `FDQueryClients`
3. D√©finissez sa propri√©t√© `Connection` : `FDConnection1`

### Les deux m√©thodes principales

| M√©thode | Usage | Type de requ√™te |
|---------|-------|-----------------|
| `Open` | Ouvre et ex√©cute une requ√™te | `SELECT` (lecture) |
| `ExecSQL` | Ex√©cute une commande | `INSERT`, `UPDATE`, `DELETE` |

**R√®gle simple :**
- Si vous voulez **lire** des donn√©es ‚Üí utilisez `Open`
- Si vous voulez **modifier** la base ‚Üí utilisez `ExecSQL`

## Requ√™tes SELECT : Lire des donn√©es

### SELECT basique

Commen√ßons par lire tous les clients :

```pascal
procedure TFormMain.LireTousLesClients;
begin
  // D√©finir la requ√™te SQL
  FDQueryClients.SQL.Text := 'SELECT * FROM clients';

  try
    // Ex√©cuter la requ√™te (ouvre le dataset)
    FDQueryClients.Open;

    // Afficher le nombre de r√©sultats
    ShowMessage('Nombre de clients : ' + IntToStr(FDQueryClients.RecordCount));

  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  end;
end;
```

**Explications :**

- `SQL.Text` : contient la requ√™te SQL √† ex√©cuter
- `SELECT *` : s√©lectionne toutes les colonnes
- `FROM clients` : dans la table "clients"
- `Open` : ex√©cute le SELECT et charge les r√©sultats
- `RecordCount` : nombre d'enregistrements retourn√©s

### Parcourir les r√©sultats

Une fois la requ√™te ouverte, vous pouvez parcourir les r√©sultats :

```pascal
procedure TFormMain.AfficherClients;
begin
  FDQueryClients.SQL.Text := 'SELECT * FROM clients';
  FDQueryClients.Open;

  memoResultats.Clear;

  // Parcourir tous les enregistrements
  FDQueryClients.First;  // Aller au premier
  while not FDQueryClients.Eof do  // Tant qu'on n'est pas √† la fin
  begin
    // Lire les champs
    memoResultats.Lines.Add(
      'ID: ' + FDQueryClients.FieldByName('id').AsString + ' - ' +
      FDQueryClients.FieldByName('prenom').AsString + ' ' +
      FDQueryClients.FieldByName('nom').AsString + ' (' +
      FDQueryClients.FieldByName('email').AsString + ')'
    );

    FDQueryClients.Next;  // Passer √† l'enregistrement suivant
  end;

  FDQueryClients.Close;  // Important : fermer le dataset
end;
```

**M√©thodes de navigation :**

| M√©thode | Description |
|---------|-------------|
| `First` | Va au premier enregistrement |
| `Last` | Va au dernier enregistrement |
| `Next` | Enregistrement suivant |
| `Prior` | Enregistrement pr√©c√©dent |
| `Eof` | True si fin du dataset (End Of File) |
| `Bof` | True si d√©but du dataset (Begin Of File) |

### Acc√©der aux champs

Il existe plusieurs fa√ßons d'acc√©der aux valeurs des champs :

```pascal
// M√©thode 1 : FieldByName (recommand√©e)
Nom := FDQueryClients.FieldByName('nom').AsString;
ID := FDQueryClients.FieldByName('id').AsInteger;
DateInscription := FDQueryClients.FieldByName('date_inscription').AsDateTime;

// M√©thode 2 : Notation crochets (syntaxe courte)
Nom := FDQueryClients['nom'];
Email := FDQueryClients['email'];

// M√©thode 3 : Par index (moins lisible, √† √©viter)
Nom := FDQueryClients.Fields[1].AsString;
```

**Types de conversion :**

| M√©thode | Type Delphi | Usage |
|---------|-------------|-------|
| `AsString` | String | Texte |
| `AsInteger` | Integer | Nombres entiers |
| `AsFloat` | Double | Nombres d√©cimaux |
| `AsDateTime` | TDateTime | Dates et heures |
| `AsBoolean` | Boolean | Vrai/Faux |
| `AsCurrency` | Currency | Valeurs mon√©taires |

### SELECT avec conditions

Filtrer les r√©sultats avec `WHERE` :

```pascal
// Clients dont le nom commence par 'M'
FDQueryClients.SQL.Text := 'SELECT * FROM clients WHERE nom LIKE ''M%''';
FDQueryClients.Open;

// Clients inscrits apr√®s une certaine date
FDQueryClients.SQL.Text := 'SELECT * FROM clients WHERE date_inscription > ''2024-02-01''';
FDQueryClients.Open;

// Clients actifs uniquement
FDQueryClients.SQL.Text := 'SELECT * FROM clients WHERE actif = TRUE';
FDQueryClients.Open;
```

**Note importante sur les apostrophes :**
En SQL, les cha√Ænes de caract√®res sont entour√©es de guillemets simples (`'`). En Pascal, pour √©crire un guillemet simple dans une cha√Æne, on le double : `''`

### SELECT avec tri (ORDER BY)

Trier les r√©sultats :

```pascal
// Trier par nom, ordre alphab√©tique
FDQueryClients.SQL.Text := 'SELECT * FROM clients ORDER BY nom ASC';

// Trier par date d'inscription, plus r√©cents d'abord
FDQueryClients.SQL.Text := 'SELECT * FROM clients ORDER BY date_inscription DESC';

// Tri sur plusieurs colonnes
FDQueryClients.SQL.Text := 'SELECT * FROM clients ORDER BY nom ASC, prenom ASC';
```

- `ASC` : ordre croissant (A‚ÜíZ, 1‚Üí9, ancien‚Üír√©cent)
- `DESC` : ordre d√©croissant (Z‚ÜíA, 9‚Üí1, r√©cent‚Üíancien)

### SELECT avec limite

Limiter le nombre de r√©sultats :

```pascal
// Les 10 premiers clients
FDQueryClients.SQL.Text := 'SELECT * FROM clients LIMIT 10';

// Les 5 clients les plus r√©cents
FDQueryClients.SQL.Text :=
  'SELECT * FROM clients ORDER BY date_inscription DESC LIMIT 5';
```

## ‚ö†Ô∏è Le danger des requ√™tes non param√©tr√©es

### Exemple DANGEREUX (√† ne JAMAIS faire)

```pascal
// ‚ùå CODE DANGEREUX - VULN√âRABLE AUX INJECTIONS SQL ‚ùå
procedure TFormMain.RechercherClientDangereux(const NomClient: string);
begin
  // Concat√©nation directe de la variable dans le SQL
  FDQueryClients.SQL.Text :=
    'SELECT * FROM clients WHERE nom = ''' + NomClient + '''';
  FDQueryClients.Open;
end;
```

### Pourquoi c'est dangereux ?

Imaginons qu'un utilisateur malveillant entre ceci dans un champ de recherche :

```
Martin' OR '1'='1
```

La requ√™te SQL devient :

```sql
SELECT * FROM clients WHERE nom = 'Martin' OR '1'='1'
```

R√©sultat : `'1'='1'` est toujours vrai, donc **TOUS** les clients sont retourn√©s, contournant la s√©curit√© !

**Pire encore**, un attaquant pourrait entrer :

```
Martin'; DROP TABLE clients; --
```

Ce qui donnerait :

```sql
SELECT * FROM clients WHERE nom = 'Martin'; DROP TABLE clients; --'
```

R√©sultat : **Votre table clients est SUPPRIM√âE** ! üò±

### La solution : Les requ√™tes param√©tr√©es

## Requ√™tes SQL param√©tr√©es (S√âCURIS√âES)

Les **param√®tres** sont des espaces r√©serv√©s dans votre SQL qui seront remplac√©s de mani√®re s√©curis√©e par FireDAC.

### Syntaxe des param√®tres

En FireDAC, les param√®tres commencent par **deux points** `:` :

```sql
SELECT * FROM clients WHERE nom = :NomParam
```

### Exemple complet et S√âCURIS√â

```pascal
procedure TFormMain.RechercherClientSecurise(const NomClient: string);
begin
  // 1. D√©finir la requ√™te avec param√®tre
  FDQueryClients.SQL.Text := 'SELECT * FROM clients WHERE nom = :NomClient';

  // 2. Assigner la valeur au param√®tre
  FDQueryClients.ParamByName('NomClient').AsString := NomClient;

  // 3. Ex√©cuter
  FDQueryClients.Open;
end;
```

**Comment √ßa fonctionne ?**

FireDAC √©chappe automatiquement les caract√®res sp√©ciaux et emp√™che les injections SQL. M√™me si l'utilisateur entre `Martin' OR '1'='1`, cela sera trait√© comme une simple cha√Æne de caract√®res, pas comme du code SQL.

### Param√®tres avec diff√©rents types

```pascal
procedure TFormMain.RechercheAvancee;
begin
  FDQueryClients.SQL.Text :=
    'SELECT * FROM clients ' +
    'WHERE nom LIKE :Nom ' +
    'AND date_inscription >= :DateDebut ' +
    'AND actif = :Actif';

  // Param√®tre texte (avec joker %)
  FDQueryClients.ParamByName('Nom').AsString := 'M%';

  // Param√®tre date
  FDQueryClients.ParamByName('DateDebut').AsDate := StrToDate('01/01/2024');

  // Param√®tre bool√©en
  FDQueryClients.ParamByName('Actif').AsBoolean := True;

  FDQueryClients.Open;
end;
```

### Param√®tres IN (plusieurs valeurs)

Pour rechercher plusieurs valeurs :

```pascal
procedure TFormMain.RechercherPlusieursNoms;
begin
  // M√©thode simple avec IN
  FDQueryClients.SQL.Text :=
    'SELECT * FROM clients WHERE nom IN (:Nom1, :Nom2, :Nom3)';

  FDQueryClients.ParamByName('Nom1').AsString := 'Dupont';
  FDQueryClients.ParamByName('Nom2').AsString := 'Martin';
  FDQueryClients.ParamByName('Nom3').AsString := 'Bernard';

  FDQueryClients.Open;
end;
```

### R√©utilisation d'une requ√™te avec diff√©rents param√®tres

```pascal
procedure TFormMain.RechercherParID(const ClientID: Integer);
begin
  // Pr√©parer la requ√™te (une seule fois)
  FDQueryClients.SQL.Text := 'SELECT * FROM clients WHERE id = :ID';

  // Ex√©cution 1
  FDQueryClients.ParamByName('ID').AsInteger := 1;
  FDQueryClients.Open;
  // ... traiter les r√©sultats
  FDQueryClients.Close;

  // Ex√©cution 2 (m√™me requ√™te, param√®tre diff√©rent)
  FDQueryClients.ParamByName('ID').AsInteger := 2;
  FDQueryClients.Open;
  // ... traiter les r√©sultats
  FDQueryClients.Close;
end;
```

## Requ√™tes INSERT : Ajouter des donn√©es

### INSERT basique

```pascal
procedure TFormMain.AjouterClient;
begin
  FDQueryClients.SQL.Text :=
    'INSERT INTO clients (nom, prenom, email, telephone, date_inscription) ' +
    'VALUES (:Nom, :Prenom, :Email, :Tel, :DateInscription)';

  // Assigner les valeurs
  FDQueryClients.ParamByName('Nom').AsString := 'Durand';
  FDQueryClients.ParamByName('Prenom').AsString := 'Marie';
  FDQueryClients.ParamByName('Email').AsString := 'marie.durand@email.fr';
  FDQueryClients.ParamByName('Tel').AsString := '0612131415';
  FDQueryClients.ParamByName('DateInscription').AsDate := Date;  // Date du jour

  try
    // Ex√©cuter l'insertion
    FDQueryClients.ExecSQL;
    ShowMessage('Client ajout√© avec succ√®s !');
  except
    on E: Exception do
      ShowMessage('Erreur lors de l''ajout : ' + E.Message);
  end;
end;
```

**Points importants :**

- Pour INSERT/UPDATE/DELETE, utilisez `ExecSQL`, pas `Open`
- Les param√®tres prot√®gent contre les injections SQL
- `Date` est une fonction Delphi qui retourne la date du jour

### R√©cup√©rer l'ID auto-g√©n√©r√©

Apr√®s un INSERT, vous voulez souvent conna√Ætre l'ID du nouvel enregistrement :

```pascal
procedure TFormMain.AjouterClientAvecID;
var
  NouvelID: Integer;
begin
  FDQueryClients.SQL.Text :=
    'INSERT INTO clients (nom, prenom, email) ' +
    'VALUES (:Nom, :Prenom, :Email)';

  FDQueryClients.ParamByName('Nom').AsString := 'Petit';
  FDQueryClients.ParamByName('Prenom').AsString := 'Claire';
  FDQueryClients.ParamByName('Email').AsString := 'claire.petit@email.fr';

  FDQueryClients.ExecSQL;

  // R√©cup√©rer l'ID auto-g√©n√©r√©
  NouvelID := FDConnection1.GetLastAutoGenValue('clients');

  ShowMessage('Client ajout√© avec l''ID : ' + IntToStr(NouvelID));
end;
```

### INSERT avec valeurs NULL

```pascal
// Pour ins√©rer NULL dans un champ optionnel
FDQueryClients.SQL.Text :=
  'INSERT INTO clients (nom, prenom, email, telephone) ' +
  'VALUES (:Nom, :Prenom, :Email, :Tel)';

FDQueryClients.ParamByName('Nom').AsString := 'Roux';
FDQueryClients.ParamByName('Prenom').AsString := 'Paul';
FDQueryClients.ParamByName('Email').AsString := 'paul.roux@email.fr';

// D√©finir un param√®tre comme NULL
FDQueryClients.ParamByName('Tel').Clear;  // Ou .Value := Null;

FDQueryClients.ExecSQL;
```

## Requ√™tes UPDATE : Modifier des donn√©es

### UPDATE simple

```pascal
procedure TFormMain.ModifierEmail(const ClientID: Integer; const NouvelEmail: string);
begin
  FDQueryClients.SQL.Text :=
    'UPDATE clients SET email = :Email WHERE id = :ID';

  FDQueryClients.ParamByName('Email').AsString := NouvelEmail;
  FDQueryClients.ParamByName('ID').AsInteger := ClientID;

  try
    FDQueryClients.ExecSQL;

    // V√©rifier le nombre de lignes affect√©es
    if FDQueryClients.RowsAffected > 0 then
      ShowMessage('Email modifi√© avec succ√®s')
    else
      ShowMessage('Aucun client trouv√© avec cet ID');
  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  end;
end;
```

**Propri√©t√© importante :**
- `RowsAffected` : nombre de lignes modifi√©es par la derni√®re op√©ration

### UPDATE de plusieurs champs

```pascal
procedure TFormMain.ModifierClient(const ClientID: Integer);
begin
  FDQueryClients.SQL.Text :=
    'UPDATE clients SET ' +
    '  nom = :Nom, ' +
    '  prenom = :Prenom, ' +
    '  email = :Email, ' +
    '  telephone = :Tel ' +
    'WHERE id = :ID';

  FDQueryClients.ParamByName('Nom').AsString := editNom.Text;
  FDQueryClients.ParamByName('Prenom').AsString := editPrenom.Text;
  FDQueryClients.ParamByName('Email').AsString := editEmail.Text;
  FDQueryClients.ParamByName('Tel').AsString := editTelephone.Text;
  FDQueryClients.ParamByName('ID').AsInteger := ClientID;

  FDQueryClients.ExecSQL;

  ShowMessage(IntToStr(FDQueryClients.RowsAffected) + ' client(s) modifi√©(s)');
end;
```

### UPDATE avec condition complexe

```pascal
// Mettre √† jour tous les clients inactifs depuis une certaine date
FDQueryClients.SQL.Text :=
  'UPDATE clients SET actif = FALSE ' +
  'WHERE date_inscription < :DateLimite AND actif = TRUE';

FDQueryClients.ParamByName('DateLimite').AsDate := EncodeDate(2023, 1, 1);
FDQueryClients.ExecSQL;

ShowMessage(IntToStr(FDQueryClients.RowsAffected) + ' clients d√©sactiv√©s');
```

## Requ√™tes DELETE : Supprimer des donn√©es

### DELETE simple

```pascal
procedure TFormMain.SupprimerClient(const ClientID: Integer);
begin
  // Demander confirmation
  if MessageDlg('√ätes-vous s√ªr de vouloir supprimer ce client ?',
                mtConfirmation, [mbYes, mbNo], 0) = mrYes then
  begin
    FDQueryClients.SQL.Text := 'DELETE FROM clients WHERE id = :ID';
    FDQueryClients.ParamByName('ID').AsInteger := ClientID;

    try
      FDQueryClients.ExecSQL;

      if FDQueryClients.RowsAffected > 0 then
        ShowMessage('Client supprim√©')
      else
        ShowMessage('Client non trouv√©');
    except
      on E: Exception do
        ShowMessage('Erreur : ' + E.Message);
    end;
  end;
end;
```

**‚ö†Ô∏è Attention avec DELETE :**
- **Toujours** demander confirmation √† l'utilisateur
- **Toujours** utiliser un WHERE pour √©viter de supprimer toute la table
- Consid√©rez une "suppression logique" (mettre `actif = FALSE`) plut√¥t qu'une suppression physique

### DELETE avec condition

```pascal
// Supprimer tous les clients inactifs
FDQueryClients.SQL.Text := 'DELETE FROM clients WHERE actif = FALSE';

if MessageDlg('Supprimer tous les clients inactifs ?',
              mtConfirmation, [mbYes, mbNo], 0) = mrYes then
begin
  FDQueryClients.ExecSQL;
  ShowMessage(IntToStr(FDQueryClients.RowsAffected) + ' clients supprim√©s');
end;
```

### Suppression logique (recommand√©e)

Au lieu de supprimer physiquement, marquez comme inactif :

```pascal
procedure TFormMain.DesactiverClient(const ClientID: Integer);
begin
  // Marquer comme inactif au lieu de supprimer
  FDQueryClients.SQL.Text :=
    'UPDATE clients SET actif = FALSE WHERE id = :ID';

  FDQueryClients.ParamByName('ID').AsInteger := ClientID;
  FDQueryClients.ExecSQL;

  ShowMessage('Client d√©sactiv√©');
end;
```

**Avantages :**
- Conserve l'historique
- R√©versible
- Respecte l'int√©grit√© r√©f√©rentielle

## Utilisation pratique : M√©thode avec Try...Finally

Une bonne pratique consiste √† toujours fermer les requ√™tes :

```pascal
procedure TFormMain.RechercherEtAfficher;
begin
  FDQueryClients.SQL.Text := 'SELECT * FROM clients WHERE actif = TRUE';

  try
    FDQueryClients.Open;

    // Traiter les r√©sultats
    while not FDQueryClients.Eof do
    begin
      // ...
      FDQueryClients.Next;
    end;

  finally
    FDQueryClients.Close;  // Toujours fermer
  end;
end;
```

## Gestion des erreurs courantes

### Erreur : Duplicate entry

```pascal
try
  FDQueryClients.SQL.Text :=
    'INSERT INTO clients (nom, prenom, email) VALUES (:N, :P, :E)';
  FDQueryClients.ParamByName('N').AsString := 'Test';
  FDQueryClients.ParamByName('P').AsString := 'Test';
  FDQueryClients.ParamByName('E').AsString := 'test@test.fr';
  FDQueryClients.ExecSQL;
except
  on E: Exception do
  begin
    if Pos('Duplicate entry', E.Message) > 0 then
      ShowMessage('Cet email existe d√©j√† !')
    else
      ShowMessage('Erreur : ' + E.Message);
  end;
end;
```

### V√©rifier l'existence avant INSERT

```pascal
function TFormMain.EmailExiste(const Email: string): Boolean;
begin
  FDQueryClients.SQL.Text := 'SELECT COUNT(*) AS nb FROM clients WHERE email = :Email';
  FDQueryClients.ParamByName('Email').AsString := Email;
  FDQueryClients.Open;
  try
    Result := FDQueryClients.FieldByName('nb').AsInteger > 0;
  finally
    FDQueryClients.Close;
  end;
end;

procedure TFormMain.AjouterSiUnique;
begin
  if EmailExiste('nouveau@email.fr') then
    ShowMessage('Email d√©j√† utilis√©')
  else
  begin
    // Ins√©rer...
  end;
end;
```

## Requ√™tes pr√©par√©es pour les performances

Pour des requ√™tes ex√©cut√©es plusieurs fois, utilisez `Prepare` :

```pascal
procedure TFormMain.InsertionsMassives;
var
  i: Integer;
begin
  FDQueryClients.SQL.Text :=
    'INSERT INTO clients (nom, prenom, email) VALUES (:N, :P, :E)';

  // Pr√©parer la requ√™te une seule fois
  FDQueryClients.Prepare;

  try
    for i := 1 to 100 do
    begin
      FDQueryClients.ParamByName('N').AsString := 'Nom' + IntToStr(i);
      FDQueryClients.ParamByName('P').AsString := 'Prenom' + IntToStr(i);
      FDQueryClients.ParamByName('E').AsString := 'email' + IntToStr(i) + '@test.fr';
      FDQueryClients.ExecSQL;
    end;
  finally
    FDQueryClients.Unprepare;
  end;

  ShowMessage('100 clients ajout√©s');
end;
```

## Bonnes pratiques de s√©curit√©

### ‚úÖ √Ä FAIRE ABSOLUMENT

1. **Toujours utiliser des param√®tres** pour les valeurs dynamiques
   ```pascal
   // ‚úÖ BON
   FDQuery.SQL.Text := 'SELECT * FROM clients WHERE nom = :Nom';
   FDQuery.ParamByName('Nom').AsString := Valeur;
   ```

2. **Valider les donn√©es** avant insertion
   ```pascal
   if Trim(editEmail.Text) = '' then
   begin
     ShowMessage('Email requis');
     Exit;
   end;
   ```

3. **G√©rer les exceptions** pour chaque op√©ration SQL
   ```pascal
   try
     FDQuery.ExecSQL;
   except
     on E: Exception do
       ShowMessage('Erreur : ' + E.Message);
   end;
   ```

4. **Fermer les requ√™tes** apr√®s usage
   ```pascal
   try
     FDQuery.Open;
     // ...
   finally
     FDQuery.Close;
   end;
   ```

### ‚ùå √Ä NE JAMAIS FAIRE

1. **Concat√©ner des valeurs dans le SQL**
   ```pascal
   // ‚ùå DANGEREUX - INJECTION SQL
   SQL := 'SELECT * FROM clients WHERE nom = ''' + editNom.Text + '''';
   ```

2. **Ignorer les erreurs**
   ```pascal
   // ‚ùå MAUVAIS
   try
     FDQuery.ExecSQL;
   except
     // Rien faire
   end;
   ```

3. **DELETE ou UPDATE sans WHERE**
   ```pascal
   // ‚ùå DANGEREUX - Supprime TOUT
   FDQuery.SQL.Text := 'DELETE FROM clients';
   ```

## Astuces et raccourcis

### SQL sur plusieurs lignes

```pascal
// Plus lisible avec TStringList
FDQueryClients.SQL.Clear;
FDQueryClients.SQL.Add('SELECT nom, prenom, email');
FDQueryClients.SQL.Add('FROM clients');
FDQueryClients.SQL.Add('WHERE actif = :Actif');
FDQueryClients.SQL.Add('ORDER BY nom');

// Ou avec un tableau de cha√Ænes
FDQueryClients.SQL.Text :=
  'SELECT nom, prenom, email ' +
  'FROM clients ' +
  'WHERE actif = :Actif ' +
  'ORDER BY nom';
```

### D√©boguer une requ√™te

```pascal
// Afficher la requ√™te finale avec les param√®tres
ShowMessage(FDQueryClients.SQL.Text);
ShowMessage('Param√®tre Nom : ' + FDQueryClients.ParamByName('Nom').AsString);
```

### V√©rifier si un dataset est vide

```pascal
FDQueryClients.Open;
if FDQueryClients.IsEmpty then
  ShowMessage('Aucun r√©sultat')
else
  ShowMessage(IntToStr(FDQueryClients.RecordCount) + ' r√©sultat(s)');
```

## R√©sum√©

### Commandes SQL principales

| Commande | Usage | M√©thode Delphi |
|----------|-------|----------------|
| `SELECT` | Lire des donn√©es | `Open` |
| `INSERT` | Ajouter des donn√©es | `ExecSQL` |
| `UPDATE` | Modifier des donn√©es | `ExecSQL` |
| `DELETE` | Supprimer des donn√©es | `ExecSQL` |

### Syntaxe des param√®tres

```pascal
// D√©finir le param√®tre dans le SQL
SQL.Text := 'SELECT * FROM clients WHERE id = :MonParametre';

// Assigner une valeur
ParamByName('MonParametre').AsString := 'valeur';
ParamByName('MonParametre').AsInteger := 123;
ParamByName('MonParametre').AsDate := Date;
```

### Points cl√©s √† retenir

‚úÖ **Les param√®tres prot√®gent contre les injections SQL** - TOUJOURS les utiliser

‚úÖ **Open pour SELECT, ExecSQL pour le reste**

‚úÖ **Toujours fermer** les datasets apr√®s usage

‚úÖ **RowsAffected** indique le nombre de lignes modifi√©es

‚úÖ **Valider les donn√©es** avant de les envoyer √† la base

‚úÖ **G√©rer les erreurs** avec try...except

## Prochaines √©tapes

Vous savez maintenant :
- Ex√©cuter des requ√™tes SELECT pour lire des donn√©es
- Utiliser des param√®tres de mani√®re s√©curis√©e
- Ins√©rer, modifier et supprimer des donn√©es
- G√©rer les erreurs courantes

Dans la section suivante, nous verrons comment effectuer des op√©rations CRUD compl√®tes dans une application r√©elle avec une interface utilisateur riche !

‚è≠Ô∏è [CRUD : Create, Read, Update, Delete](/08-acces-aux-bases-de-donnees-mysql-mariadb/05.2-crud-create-read-update-delete.md)
