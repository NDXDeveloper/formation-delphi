# 8.5.1 Requ√™tes SQL et param√©tr√©es

üîù Retour √† la [Table des mati√®res](/SOMMAIRE.md)

Dans cette section, nous allons approfondir l'utilisation des requ√™tes SQL dans Delphi, en mettant l'accent sur les requ√™tes param√©tr√©es qui sont essentielles pour d√©velopper des applications s√©curis√©es et performantes.

## Introduction aux requ√™tes SQL dans Delphi

Une requ√™te SQL est une instruction permettant d'interagir avec une base de donn√©es pour r√©cup√©rer, ajouter, modifier ou supprimer des donn√©es. Dans Delphi, le composant `TFDQuery` est l'outil principal pour ex√©cuter ces requ√™tes.

Voici comment utiliser une requ√™te SQL simple avec `TFDQuery` :

```delphi
procedure TForm1.ExecuterRequeteSimple;
begin
  // Supposons que FDQuery1 est d√©j√† connect√© √† votre base de donn√©es
  FDQuery1.SQL.Text := 'SELECT * FROM clients ORDER BY nom';
  FDQuery1.Open;

  // Maintenant, FDQuery1 contient les r√©sultats que vous pouvez afficher
  // dans un TDBGrid ou parcourir en code
end;
```

## Pourquoi utiliser des requ√™tes param√©tr√©es ?

Les requ√™tes param√©tr√©es offrent plusieurs avantages importants :

1. **S√©curit√©** : Elles prot√®gent contre les attaques par injection SQL
2. **Performance** : Elles permettent au moteur de base de donn√©es de r√©utiliser les plans d'ex√©cution
3. **Lisibilit√©** : Elles rendent votre code plus clair et plus facile √† maintenir
4. **Flexibilit√©** : Elles permettent d'ex√©cuter la m√™me requ√™te avec diff√©rentes valeurs

### Le danger des requ√™tes non param√©tr√©es

Voici un exemple de code **non s√©curis√©** qui illustre le risque :

```delphi
// ATTENTION : Ce code est vuln√©rable aux injections SQL - NE PAS UTILISER!
procedure TForm1.RechercherClientNonSecurise(const Nom: string);
begin
  FDQuery1.SQL.Text := 'SELECT * FROM clients WHERE nom = ''' + Nom + '''';
  FDQuery1.Open;
end;
```

Si un utilisateur malveillant entre `' OR '1'='1` comme nom, la requ√™te devient :
```sql
SELECT * FROM clients WHERE nom = '' OR '1'='1'
```

Cette requ√™te retournera tous les clients, car la condition `'1'='1'` est toujours vraie !

## Comment utiliser les requ√™tes param√©tr√©es

Delphi et FireDAC supportent plusieurs types de param√®tres. Voyons les plus courants :

### 1. Param√®tres nomm√©s (recommand√©s)

Les param√®tres nomm√©s utilisent le pr√©fixe `:` suivi d'un nom. Ils sont clairs et faciles √† utiliser :

```delphi
procedure TForm1.RechercherClientParNom(const Nom: string);
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text := 'SELECT * FROM clients WHERE nom LIKE :nom';
  FDQuery1.ParamByName('nom').AsString := '%' + Nom + '%';
  FDQuery1.Open;
end;
```

Avantages des param√®tres nomm√©s :
- Vous pouvez utiliser le m√™me param√®tre plusieurs fois dans la requ√™te
- Les noms explicites rendent le code plus lisible
- L'ordre des param√®tres n'a pas d'importance

### 2. Param√®tres par position

Les param√®tres positionnels utilisent le symbole `?` et sont d√©finis par leur index :

```delphi
procedure TForm1.RechercherClientParPosition(const Nom, Ville: string);
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text := 'SELECT * FROM clients WHERE nom LIKE ? AND ville = ?';
  FDQuery1.Params[0].AsString := '%' + Nom + '%';
  FDQuery1.Params[1].AsString := Ville;
  FDQuery1.Open;
end;
```

Ces param√®tres sont l√©g√®rement plus concis mais moins explicites que les param√®tres nomm√©s.

### 3. Param√®tres avec le type sp√©cifi√©

Pour plus de clart√© ou pour des cas sp√©cifiques, vous pouvez d√©clarer le type du param√®tre dans la requ√™te :

```delphi
procedure TForm1.RechercherClientParID(const ID: Integer);
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text := 'SELECT * FROM clients WHERE id = :id<Integer>';
  FDQuery1.ParamByName('id').AsInteger := ID;
  FDQuery1.Open;
end;
```

## Types de donn√©es des param√®tres

FireDAC g√®re automatiquement la conversion des types, mais il est important de comprendre comment les types Delphi correspondent aux types SQL :

| Type Delphi | M√©thode ParamByName | Type SQL √©quivalent |
|-------------|---------------------|---------------------|
| String      | AsString            | VARCHAR, CHAR, TEXT |
| Integer     | AsInteger           | INT, SMALLINT       |
| Double      | AsFloat             | FLOAT, DOUBLE       |
| TDateTime   | AsDateTime          | DATETIME, TIMESTAMP |
| Boolean     | AsBoolean           | TINYINT(1), BIT     |
| TBlobStream | AsBlob              | BLOB, LONGBLOB      |

Exemple avec diff√©rents types :

```delphi
procedure TForm1.AjouterClient(const Nom, Email: string; DateNaissance: TDateTime;
                              EstActif: Boolean);
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'INSERT INTO clients (nom, email, date_naissance, actif) ' +
    'VALUES (:nom, :email, :date_naissance, :actif)';

  FDQuery1.ParamByName('nom').AsString := Nom;
  FDQuery1.ParamByName('email').AsString := Email;
  FDQuery1.ParamByName('date_naissance').AsDateTime := DateNaissance;
  FDQuery1.ParamByName('actif').AsBoolean := EstActif;

  FDQuery1.ExecSQL;
end;
```

## Param√®tres NULL

Pour d√©finir un param√®tre √† NULL :

```delphi
procedure TForm1.AjouterClientAvecParamsNull(const Nom: string;
                                           DateNaissance: TDateTime);
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'INSERT INTO clients (nom, date_naissance, telephone) ' +
    'VALUES (:nom, :date_naissance, :telephone)';

  FDQuery1.ParamByName('nom').AsString := Nom;
  FDQuery1.ParamByName('date_naissance').AsDateTime := DateNaissance;

  // D√©finir un param√®tre NULL (deux m√©thodes possibles)
  FDQuery1.ParamByName('telephone').Clear;  // M√©thode 1
  // ou
  FDQuery1.ParamByName('telephone').IsNull := True;  // M√©thode 2

  FDQuery1.ExecSQL;
end;
```

## R√©cup√©rer des valeurs √† partir de param√®tres de sortie

Certaines requ√™tes, particuli√®rement avec les proc√©dures stock√©es, peuvent avoir des param√®tres de sortie. Voici comment les utiliser :

```delphi
function TForm1.InsererClientEtObtenirID(const Nom, Email: string): Integer;
begin
  FDQuery1.Close;

  // Pour MySQL, nous utilisons une approche en deux √©tapes
  FDQuery1.SQL.Text :=
    'INSERT INTO clients (nom, email) VALUES (:nom, :email)';

  FDQuery1.ParamByName('nom').AsString := Nom;
  FDQuery1.ParamByName('email').AsString := Email;

  // Utiliser une transaction pour garantir la coh√©rence
  FDConnection1.StartTransaction;
  try
    FDQuery1.ExecSQL;

    // R√©cup√©rer l'ID du dernier enregistrement ins√©r√©
    FDQuery1.SQL.Text := 'SELECT LAST_INSERT_ID() AS id';
    FDQuery1.Open;

    Result := FDQuery1.FieldByName('id').AsInteger;

    FDConnection1.Commit;
  except
    FDConnection1.Rollback;
    raise;  // Relancer l'exception pour la gestion d'erreurs
  end;
end;
```

## Param√®tres pour les requ√™tes avec des listes (IN)

Pour les requ√™tes avec une clause `IN`, il faut une approche sp√©ciale :

```delphi
procedure TForm1.RechercherClientsParVilles(const Villes: array of string);
var
  SQL: string;
  i: Integer;
begin
  // Construire la requ√™te dynamiquement
  SQL := 'SELECT * FROM clients WHERE ville IN (';

  for i := 0 to High(Villes) do
  begin
    if i > 0 then
      SQL := SQL + ', ';

    SQL := SQL + ':ville' + IntToStr(i);
  end;

  SQL := SQL + ')';

  FDQuery1.Close;
  FDQuery1.SQL.Text := SQL;

  // D√©finir chaque param√®tre
  for i := 0 to High(Villes) do
    FDQuery1.ParamByName('ville' + IntToStr(i)).AsString := Villes[i];

  FDQuery1.Open;
end;
```

Exemple d'utilisation :
```delphi
RechercherClientsParVilles(['Paris', 'Lyon', 'Marseille']);
```

## Requ√™tes pr√©par√©es pour de meilleures performances

Si vous ex√©cutez plusieurs fois la m√™me requ√™te avec des param√®tres diff√©rents, utilisez une requ√™te pr√©par√©e pour am√©liorer les performances :

```delphi
procedure TForm1.AjouterPlusieursClients(const Clients: array of TClient);
var
  i: Integer;
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'INSERT INTO clients (nom, email, telephone) ' +
    'VALUES (:nom, :email, :telephone)';

  // Pr√©parer la requ√™te une seule fois
  FDQuery1.Prepare;

  FDConnection1.StartTransaction;
  try
    for i := 0 to High(Clients) do
    begin
      // D√©finir les param√®tres pour chaque client
      FDQuery1.ParamByName('nom').AsString := Clients[i].Nom;
      FDQuery1.ParamByName('email').AsString := Clients[i].Email;

      if Clients[i].Telephone <> '' then
        FDQuery1.ParamByName('telephone').AsString := Clients[i].Telephone
      else
        FDQuery1.ParamByName('telephone').Clear;

      // Ex√©cuter la requ√™te pr√©par√©e
      FDQuery1.ExecSQL;
    end;

    FDConnection1.Commit;
  except
    FDConnection1.Rollback;
    raise;
  end;
end;
```

## Param√®tres pour les requ√™tes LIKE

Les recherches avec `LIKE` n√©cessitent souvent d'ajouter des caract√®res joker (% ou _) :

```delphi
procedure TForm1.RechercheTextuelle(const Terme: string);
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'SELECT * FROM clients ' +
    'WHERE nom LIKE :terme OR email LIKE :terme OR adresse LIKE :terme';

  // Ajouter les caract√®res joker % de chaque c√¥t√© pour une recherche partielle
  FDQuery1.ParamByName('terme').AsString := '%' + Terme + '%';

  FDQuery1.Open;
end;
```

## Exemples pratiques de requ√™tes param√©tr√©es

### Exemple 1 : Recherche multicrit√®res

```delphi
procedure TForm1.RechercheMulticriteres(const Nom, Ville: string;
                                      DateDebut, DateFin: TDateTime);
var
  SQL: string;
begin
  SQL := 'SELECT * FROM clients WHERE 1=1';  // Commence par une condition toujours vraie

  // Construire la requ√™te en fonction des crit√®res fournis
  if Nom <> '' then
    SQL := SQL + ' AND nom LIKE :nom';

  if Ville <> '' then
    SQL := SQL + ' AND ville = :ville';

  if DateDebut > 0 then
    SQL := SQL + ' AND date_creation >= :date_debut';

  if DateFin > 0 then
    SQL := SQL + ' AND date_creation <= :date_fin';

  FDQuery1.Close;
  FDQuery1.SQL.Text := SQL;

  // D√©finir uniquement les param√®tres utilis√©s dans la requ√™te
  if Nom <> '' then
    FDQuery1.ParamByName('nom').AsString := '%' + Nom + '%';

  if Ville <> '' then
    FDQuery1.ParamByName('ville').AsString := Ville;

  if DateDebut > 0 then
    FDQuery1.ParamByName('date_debut').AsDateTime := DateDebut;

  if DateFin > 0 then
    FDQuery1.ParamByName('date_fin').AsDateTime := DateFin;

  FDQuery1.Open;
end;
```

### Exemple 2 : Mise √† jour conditionnelle

```delphi
function TForm1.DesactiverClientsInactifs(const JoursInactivite: Integer): Integer;
var
  DateLimite: TDateTime;
begin
  // Calculer la date limite d'activit√©
  DateLimite := IncDay(Now, -JoursInactivite);

  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'UPDATE clients ' +
    'SET actif = 0 ' +
    'WHERE actif = 1 AND derniere_connexion < :date_limite';

  FDQuery1.ParamByName('date_limite').AsDateTime := DateLimite;
  FDQuery1.ExecSQL;

  // Retourner le nombre de clients d√©sactiv√©s
  Result := FDQuery1.RowsAffected;
end;
```

### Exemple 3 : Requ√™te avec calculs et sous-requ√™tes

```delphi
procedure TForm1.AfficherStatsClients;
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'SELECT ' +
    '  ville, ' +
    '  COUNT(*) AS nombre_clients, ' +
    '  AVG(TIMESTAMPDIFF(YEAR, date_naissance, CURDATE())) AS age_moyen, ' +
    '  (SELECT COUNT(*) FROM commandes WHERE client_id = c.id) AS nombre_commandes ' +
    'FROM clients c ' +
    'WHERE actif = :actif ' +
    'GROUP BY ville ' +
    'HAVING nombre_clients >= :min_clients ' +
    'ORDER BY nombre_clients DESC';

  FDQuery1.ParamByName('actif').AsBoolean := True;
  FDQuery1.ParamByName('min_clients').AsInteger := 5;

  FDQuery1.Open;

  // Maintenant vous pouvez afficher les r√©sultats dans un DBGrid ou autre...
end;
```

## Bonnes pratiques pour les requ√™tes param√©tr√©es

1. **Toujours utiliser des param√®tres** pour les valeurs variables dans vos requ√™tes SQL
2. **Pr√©f√©rer les param√®tres nomm√©s** (`:nom`) aux param√®tres positionnels (`?`) pour plus de clart√©
3. **Pr√©parer les requ√™tes** (`Prepare`) lorsqu'elles sont ex√©cut√©es plusieurs fois
4. **Utiliser les transactions** pour les op√©rations qui n√©cessitent plusieurs requ√™tes
5. **Valider les entr√©es utilisateur** avant de les utiliser comme param√®tres
6. **G√©rer les cas NULL** correctement avec `Clear` ou `IsNull := True`
7. **Fermer les requ√™tes** quand vous avez fini de les utiliser pour lib√©rer les ressources

## Conclusion

Les requ√™tes param√©tr√©es sont un √©l√©ment fondamental pour d√©velopper des applications de base de donn√©es s√©curis√©es et performantes avec Delphi. Elles offrent une protection contre les injections SQL, am√©liorent les performances et rendent votre code plus lisible et maintenable.

Dans la section suivante, nous explorerons en d√©tail les op√©rations CRUD (Create, Read, Update, Delete) et comment les impl√©menter efficacement dans vos applications.

---

**√Ä suivre :** 8.5.2 CRUD : Create, Read, Update, Delete

‚è≠Ô∏è [CRUD : Create, Read, Update, Delete](08-acces-aux-bases-de-donnees-mysql-mariadb/05.2-crud-create-read-update-delete.md)
