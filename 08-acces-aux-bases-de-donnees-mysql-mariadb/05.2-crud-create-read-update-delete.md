# 8.5.2 CRUD : Create, Read, Update, Delete

L'acronyme CRUD désigne les quatre opérations fondamentales pour manipuler des données dans une base de données :
- **C**reate (Créer) : Ajouter de nouvelles données
- **R**ead (Lire) : Récupérer des données existantes
- **U**pdate (Mettre à jour) : Modifier des données existantes
- **D**elete (Supprimer) : Effacer des données

Dans cette section, nous allons explorer en détail chacune de ces opérations et voir comment les implémenter efficacement dans vos applications Delphi avec MySQL/MariaDB.

## Préparation de l'environnement

Pour illustrer les opérations CRUD, nous allons créer un exemple pratique basé sur une table `produits`. Si vous n'avez pas encore cette table, voici le script SQL pour la créer :

```sql
CREATE TABLE produits (
  id INT AUTO_INCREMENT PRIMARY KEY,
  reference VARCHAR(20) NOT NULL,
  nom VARCHAR(100) NOT NULL,
  description TEXT,
  prix DECIMAL(10,2) NOT NULL,
  stock INT DEFAULT 0,
  categorie_id INT,
  date_creation DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

## C - Create : Ajouter des données

L'opération Create consiste à insérer de nouvelles données dans la base de données. En SQL, cela se fait avec l'instruction `INSERT INTO`.

### Méthode 1 : Insertion simple avec TFDQuery

```delphi
procedure TForm1.AjouterProduit(const Reference, Nom, Description: string;
                               Prix: Double; Stock: Integer; CategorieID: Integer);
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Préparer la requête d'insertion
    Query.SQL.Text :=
      'INSERT INTO produits (reference, nom, description, prix, stock, categorie_id) ' +
      'VALUES (:reference, :nom, :description, :prix, :stock, :categorie_id)';

    // Définir les paramètres
    Query.ParamByName('reference').AsString := Reference;
    Query.ParamByName('nom').AsString := Nom;
    Query.ParamByName('description').AsString := Description;
    Query.ParamByName('prix').AsFloat := Prix;
    Query.ParamByName('stock').AsInteger := Stock;

    // Gérer un paramètre potentiellement NULL
    if CategorieID > 0 then
      Query.ParamByName('categorie_id').AsInteger := CategorieID
    else
      Query.ParamByName('categorie_id').Clear;

    // Exécuter l'insertion
    Query.ExecSQL;

    ShowMessage('Produit ajouté avec succès !');
  except
    on E: Exception do
      ShowMessage('Erreur lors de l''ajout du produit : ' + E.Message);
  finally
    Query.Free;
  end;
end;
```

### Méthode 2 : Insertion avec récupération de l'ID généré

Souvent, vous voudrez récupérer l'ID auto-généré du nouvel enregistrement :

```delphi
function TForm1.AjouterProduitEtObtenirID(const Reference, Nom: string;
                                        Prix: Double): Integer;
var
  Query: TFDQuery;
begin
  Result := -1; // Valeur par défaut en cas d'échec

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Utiliser une transaction pour garantir la cohérence
    Query.Connection.StartTransaction;
    try
      // Insérer le produit
      Query.SQL.Text :=
        'INSERT INTO produits (reference, nom, prix) ' +
        'VALUES (:reference, :nom, :prix)';

      Query.ParamByName('reference').AsString := Reference;
      Query.ParamByName('nom').AsString := Nom;
      Query.ParamByName('prix').AsFloat := Prix;

      Query.ExecSQL;

      // Récupérer l'ID généré
      Query.SQL.Text := 'SELECT LAST_INSERT_ID() AS id';
      Query.Open;

      Result := Query.FieldByName('id').AsInteger;

      // Valider la transaction
      Query.Connection.Commit;
    except
      // En cas d'erreur, annuler la transaction
      Query.Connection.Rollback;
      raise; // Relancer l'exception pour la gestion en amont
    end;
  finally
    Query.Free;
  end;
end;
```

### Méthode 3 : Insertion multiple (par lots)

Pour insérer plusieurs enregistrements efficacement :

```delphi
procedure TForm1.AjouterProduitsMassifs(const Produits: array of TProduit);
var
  Query: TFDQuery;
  i: Integer;
begin
  if Length(Produits) = 0 then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Préparer la requête d'insertion
    Query.SQL.Text :=
      'INSERT INTO produits (reference, nom, prix, stock) ' +
      'VALUES (:reference, :nom, :prix, :stock)';

    // Préparer la requête pour de meilleures performances
    Query.Prepare;

    // Utiliser une transaction pour de meilleures performances
    Query.Connection.StartTransaction;
    try
      for i := 0 to High(Produits) do
      begin
        // Définir les paramètres pour chaque produit
        Query.ParamByName('reference').AsString := Produits[i].Reference;
        Query.ParamByName('nom').AsString := Produits[i].Nom;
        Query.ParamByName('prix').AsFloat := Produits[i].Prix;
        Query.ParamByName('stock').AsInteger := Produits[i].Stock;

        // Exécuter l'insertion
        Query.ExecSQL;
      end;

      // Valider toutes les insertions
      Query.Connection.Commit;

      ShowMessage(Format('%d produits ajoutés avec succès !', [Length(Produits)]));
    except
      on E: Exception do
      begin
        // Annuler toutes les insertions en cas d'erreur
        Query.Connection.Rollback;
        ShowMessage('Erreur lors de l''ajout des produits : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;
```

### Méthode 4 : Utilisation de TFDTable

`TFDTable` offre une approche plus orientée objet pour les opérations CRUD :

```delphi
procedure TForm1.AjouterProduitAvecTable(const Reference, Nom: string; Prix: Double);
var
  Table: TFDTable;
begin
  Table := TFDTable.Create(nil);
  try
    Table.Connection := FDConnection1;
    Table.TableName := 'produits';
    Table.Open;

    // Commencer l'ajout d'un nouvel enregistrement
    Table.Append;

    // Remplir les champs
    Table.FieldByName('reference').AsString := Reference;
    Table.FieldByName('nom').AsString := Nom;
    Table.FieldByName('prix').AsFloat := Prix;
    Table.FieldByName('stock').AsInteger := 0;

    // Enregistrer les modifications
    Table.Post;

    ShowMessage('Produit ajouté avec succès !');
  except
    on E: Exception do
    begin
      if Table.State in [dsInsert, dsEdit] then
        Table.Cancel; // Annuler l'opération en cours en cas d'erreur

      ShowMessage('Erreur lors de l''ajout du produit : ' + E.Message);
    end;
  finally
    Table.Free;
  end;
end;
```

## R - Read : Lire des données

L'opération Read consiste à récupérer des données de la base de données. En SQL, cela se fait avec l'instruction `SELECT`.

### Méthode 1 : Lecture simple de tous les enregistrements

```delphi
procedure TForm1.AfficherTousProduits;
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text := 'SELECT * FROM produits ORDER BY nom';
  FDQuery1.Open;

  // À ce stade, les données sont disponibles dans FDQuery1
  // et peuvent être affichées via un TDBGrid lié à un TDataSource
  // connecté à ce FDQuery1
end;
```

### Méthode 2 : Lecture avec filtrage

```delphi
procedure TForm1.RechercherProduits(const Terme: string; CategorieID: Integer);
var
  SQL: string;
begin
  // Construire la requête de base
  SQL := 'SELECT p.*, c.nom AS categorie_nom ' +
         'FROM produits p ' +
         'LEFT JOIN categories c ON p.categorie_id = c.id ' +
         'WHERE 1=1'; // Clause toujours vraie comme point de départ

  // Ajouter des conditions de filtrage selon les paramètres
  if Terme <> '' then
    SQL := SQL + ' AND (p.nom LIKE :terme OR p.reference LIKE :terme OR p.description LIKE :terme)';

  if CategorieID > 0 then
    SQL := SQL + ' AND p.categorie_id = :categorie_id';

  SQL := SQL + ' ORDER BY p.nom';

  // Configurer et exécuter la requête
  FDQuery1.Close;
  FDQuery1.SQL.Text := SQL;

  // Définir les paramètres si nécessaire
  if Terme <> '' then
    FDQuery1.ParamByName('terme').AsString := '%' + Terme + '%';

  if CategorieID > 0 then
    FDQuery1.ParamByName('categorie_id').AsInteger := CategorieID;

  FDQuery1.Open;

  // Mise à jour de l'interface
  StatusBar1.SimpleText := Format('%d produits trouvés', [FDQuery1.RecordCount]);
end;
```

### Méthode 3 : Lecture d'un enregistrement spécifique

```delphi
function TForm1.ObtenirProduit(ID: Integer): TProduit;
var
  Query: TFDQuery;
begin
  // Initialiser le résultat
  Result.ID := 0;
  Result.Reference := '';
  Result.Nom := '';
  Result.Prix := 0;
  Result.Stock := 0;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;
    Query.SQL.Text := 'SELECT * FROM produits WHERE id = :id';
    Query.ParamByName('id').AsInteger := ID;
    Query.Open;

    if not Query.IsEmpty then
    begin
      // Remplir la structure avec les données
      Result.ID := Query.FieldByName('id').AsInteger;
      Result.Reference := Query.FieldByName('reference').AsString;
      Result.Nom := Query.FieldByName('nom').AsString;
      Result.Description := Query.FieldByName('description').AsString;
      Result.Prix := Query.FieldByName('prix').AsFloat;
      Result.Stock := Query.FieldByName('stock').AsInteger;

      if not Query.FieldByName('categorie_id').IsNull then
        Result.CategorieID := Query.FieldByName('categorie_id').AsInteger;
    end;
  finally
    Query.Free;
  end;
end;
```

### Méthode 4 : Lecture avec pagination

Pour les tables volumineuses, il est souvent nécessaire de paginer les résultats :

```delphi
procedure TForm1.ChargerPageProduits(NumPage: Integer; ElementsParPage: Integer);
var
  Offset: Integer;
begin
  // Calculer l'offset (décalage) pour la pagination
  Offset := (NumPage - 1) * ElementsParPage;

  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'SELECT * FROM produits ORDER BY nom LIMIT :limit OFFSET :offset';

  FDQuery1.ParamByName('limit').AsInteger := ElementsParPage;
  FDQuery1.ParamByName('offset').AsInteger := Offset;

  FDQuery1.Open;

  // Mettre à jour les informations de pagination
  LabelPagination.Caption := Format('Page %d sur %d',
    [NumPage, Ceil(CompteTotalProduits / ElementsParPage)]);
end;

function TForm1.CompteTotalProduits: Integer;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;
    Query.SQL.Text := 'SELECT COUNT(*) AS total FROM produits';
    Query.Open;

    Result := Query.FieldByName('total').AsInteger;
  finally
    Query.Free;
  end;
end;
```

### Méthode 5 : Lecture avec agrégation

Pour obtenir des statistiques et des résumés :

```delphi
procedure TForm1.AfficherStatistiquesProduits;
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'SELECT ' +
    '  c.nom AS categorie, ' +
    '  COUNT(*) AS nombre_produits, ' +
    '  MIN(p.prix) AS prix_min, ' +
    '  MAX(p.prix) AS prix_max, ' +
    '  AVG(p.prix) AS prix_moyen, ' +
    '  SUM(p.stock) AS stock_total ' +
    'FROM produits p ' +
    'LEFT JOIN categories c ON p.categorie_id = c.id ' +
    'GROUP BY p.categorie_id ' +
    'ORDER BY nombre_produits DESC';

  FDQuery1.Open;

  // Maintenant, FDQuery1 contient les statistiques par catégorie
  // que vous pouvez afficher ou traiter...
end;
```

## U - Update : Mettre à jour des données

L'opération Update consiste à modifier des données existantes dans la base de données. En SQL, cela se fait avec l'instruction `UPDATE`.

### Méthode 1 : Mise à jour simple avec TFDQuery

```delphi
procedure TForm1.ModifierProduit(ID: Integer; const Nom, Description: string;
                                Prix: Double; Stock: Integer);
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Préparer la requête de mise à jour
    Query.SQL.Text :=
      'UPDATE produits SET ' +
      'nom = :nom, description = :description, prix = :prix, stock = :stock ' +
      'WHERE id = :id';

    // Définir les paramètres
    Query.ParamByName('nom').AsString := Nom;
    Query.ParamByName('description').AsString := Description;
    Query.ParamByName('prix').AsFloat := Prix;
    Query.ParamByName('stock').AsInteger := Stock;
    Query.ParamByName('id').AsInteger := ID;

    // Exécuter la mise à jour
    Query.ExecSQL;

    if Query.RowsAffected > 0 then
      ShowMessage('Produit modifié avec succès !')
    else
      ShowMessage('Aucun produit n''a été modifié. Vérifiez l''ID.');
  except
    on E: Exception do
      ShowMessage('Erreur lors de la modification du produit : ' + E.Message);
  finally
    Query.Free;
  end;
end;
```

### Méthode 2 : Mise à jour conditionnelle

```delphi
function TForm1.AugmenterPrixProduits(CategorieID: Integer;
                                    PourcentageAugmentation: Double): Integer;
var
  Query: TFDQuery;
begin
  Result := 0; // Nombre de produits mis à jour

  if (CategorieID <= 0) or (PourcentageAugmentation <= 0) then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Mise à jour avec calcul
    Query.SQL.Text :=
      'UPDATE produits ' +
      'SET prix = prix * (1 + :pourcentage / 100) ' +
      'WHERE categorie_id = :categorie_id';

    Query.ParamByName('pourcentage').AsFloat := PourcentageAugmentation;
    Query.ParamByName('categorie_id').AsInteger := CategorieID;

    Query.ExecSQL;

    Result := Query.RowsAffected;
  finally
    Query.Free;
  end;
end;
```

### Méthode 3 : Mise à jour avec TFDTable

```delphi
procedure TForm1.ModifierProduitAvecTable(ID: Integer; NouveauStock: Integer);
var
  Table: TFDTable;
begin
  Table := TFDTable.Create(nil);
  try
    Table.Connection := FDConnection1;
    Table.TableName := 'produits';
    Table.IndexFieldNames := 'id'; // Définir un index pour la recherche
    Table.Open;

    // Rechercher l'enregistrement à modifier
    if Table.FindKey([ID]) then
    begin
      // Commencer l'édition
      Table.Edit;

      // Modifier le champ stock
      Table.FieldByName('stock').AsInteger := NouveauStock;

      // Enregistrer les modifications
      Table.Post;

      ShowMessage('Stock du produit mis à jour avec succès !');
    end
    else
      ShowMessage('Produit non trouvé. Vérifiez l''ID.');
  except
    on E: Exception do
    begin
      if Table.State in [dsEdit, dsInsert] then
        Table.Cancel; // Annuler l'opération en cours

      ShowMessage('Erreur lors de la mise à jour : ' + E.Message);
    end;
  finally
    Table.Free;
  end;
end;
```

### Méthode 4 : Mise à jour d'un champ unique

```delphi
function TForm1.DecrementStock(ProduitID: Integer; Quantite: Integer): Boolean;
var
  Query: TFDQuery;
  StockActuel: Integer;
begin
  Result := False;

  if (ProduitID <= 0) or (Quantite <= 0) then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Vérifier le stock actuel
    Query.SQL.Text := 'SELECT stock FROM produits WHERE id = :id';
    Query.ParamByName('id').AsInteger := ProduitID;
    Query.Open;

    if Query.IsEmpty then
      Exit; // Produit non trouvé

    StockActuel := Query.FieldByName('stock').AsInteger;

    if StockActuel < Quantite then
      Exit; // Stock insuffisant

    // Mettre à jour le stock
    Query.Close;
    Query.SQL.Text :=
      'UPDATE produits ' +
      'SET stock = stock - :quantite ' +
      'WHERE id = :id AND stock >= :quantite';

    Query.ParamByName('quantite').AsInteger := Quantite;
    Query.ParamByName('id').AsInteger := ProduitID;

    Query.ExecSQL;

    Result := Query.RowsAffected > 0;
  finally
    Query.Free;
  end;
end;
```

## D - Delete : Supprimer des données

L'opération Delete consiste à supprimer des données de la base de données. En SQL, cela se fait avec l'instruction `DELETE`.

### Méthode 1 : Suppression simple avec TFDQuery

```delphi
function TForm1.SupprimerProduit(ID: Integer): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  // Demander confirmation à l'utilisateur
  if MessageDlg(Format('Êtes-vous sûr de vouloir supprimer le produit ID %d ?', [ID]),
     mtConfirmation, [mbYes, mbNo], 0) <> mrYes then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Préparer la requête de suppression
    Query.SQL.Text := 'DELETE FROM produits WHERE id = :id';
    Query.ParamByName('id').AsInteger := ID;

    // Exécuter la suppression
    Query.ExecSQL;

    Result := Query.RowsAffected > 0;

    if Result then
      ShowMessage('Produit supprimé avec succès !')
    else
      ShowMessage('Aucun produit avec cet ID n''a été trouvé.');
  except
    on E: Exception do
      ShowMessage('Erreur lors de la suppression du produit : ' + E.Message);
  finally
    Query.Free;
  end;
end;
```

### Méthode 2 : Suppression conditionnelle

```delphi
function TForm1.SupprimerProduitsObsoletes(JoursInactivite: Integer): Integer;
var
  Query: TFDQuery;
  DateLimite: TDateTime;
begin
  Result := 0; // Nombre de produits supprimés

  // Calculer la date limite
  DateLimite := IncDay(Now, -JoursInactivite);

  // Demander confirmation
  if MessageDlg('Cette opération va supprimer tous les produits sans stock ' +
                'qui n''ont pas été mis à jour depuis plus de ' +
                IntToStr(JoursInactivite) + ' jours. Continuer ?',
     mtWarning, [mbYes, mbNo], 0) <> mrYes then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Supprimer les produits obsolètes
    Query.SQL.Text :=
      'DELETE FROM produits ' +
      'WHERE stock = 0 AND date_modification < :date_limite';

    Query.ParamByName('date_limite').AsDateTime := DateLimite;
    Query.ExecSQL;

    Result := Query.RowsAffected;
  finally
    Query.Free;
  end;
end;
```

### Méthode 3 : Suppression avec TFDTable

```delphi
procedure TForm1.SupprimerProduitAvecTable(ID: Integer);
var
  Table: TFDTable;
begin
  Table := TFDTable.Create(nil);
  try
    Table.Connection := FDConnection1;
    Table.TableName := 'produits';
    Table.IndexFieldNames := 'id';
    Table.Open;

    // Rechercher l'enregistrement à supprimer
    if Table.FindKey([ID]) then
    begin
      // Supprimer l'enregistrement
      Table.Delete;

      ShowMessage('Produit supprimé avec succès !');
    end
    else
      ShowMessage('Produit non trouvé. Vérifiez l''ID.');
  except
    on E: Exception do
      ShowMessage('Erreur lors de la suppression : ' + E.Message);
  finally
    Table.Free;
  end;
end;
```

### Méthode 4 : Suppression logique (sans effacer les données)

Dans certains cas, il est préférable de marquer les enregistrements comme supprimés plutôt que de les effacer réellement :

```delphi
function TForm1.DesactiverProduit(ID: Integer): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Mise à jour du statut au lieu de suppression
    Query.SQL.Text :=
      'UPDATE produits ' +
      'SET actif = 0, date_modification = NOW() ' +
      'WHERE id = :id';

    Query.ParamByName('id').AsInteger := ID;
    Query.ExecSQL;

    Result := Query.RowsAffected > 0;
  finally
    Query.Free;
  end;
end;
```

## Implémentation pratique : Formulaire de gestion des produits

Voyons maintenant comment combiner ces opérations CRUD dans un formulaire complet de gestion des produits.

```delphi
unit UFormProduits;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, FireDAC.Stan.Intf,
  FireDAC.Stan.Option, FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf,
  FireDAC.Stan.Def, FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys,
  FireDAC.Phys.MySQL, FireDAC.Phys.MySQLDef, FireDAC.VCLUI.Wait, FireDAC.Stan.Param,
  FireDAC.DatS, FireDAC.DApt.Intf, FireDAC.DApt, Data.DB, FireDAC.Comp.DataSet,
  FireDAC.Comp.Client, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Grids, Vcl.DBGrids,
  Vcl.ComCtrls;

type
  TProduit = record
    ID: Integer;
    Reference: string;
    Nom: string;
    Description: string;
    Prix: Double;
    Stock: Integer;
    CategorieID: Integer;
  end;

  TFormProduits = class(TForm)
    FDConnection1: TFDConnection;
    FDQuery1: TFDQuery;
    DataSource1: TDataSource;
    PageControl1: TPageControl;
    TabSheetListe: TTabSheet;
    TabSheetDetail: TTabSheet;
    PanelRecherche: TPanel;
    LabelRecherche: TLabel;
    EditRecherche: TEdit;
    ButtonRechercher: TButton;
    DBGrid1: TDBGrid;
    EditReference: TEdit;
    EditNom: TEdit;
    MemoDescription: TMemo;
    EditPrix: TEdit;
    EditStock: TEdit;
    ComboBoxCategorie: TComboBox;
    LabelReference: TLabel;
    LabelNom: TLabel;
    LabelDescription: TLabel;
    LabelPrix: TLabel;
    LabelStock: TLabel;
    LabelCategorie: TLabel;
    ButtonEnregistrer: TButton;
    ButtonAnnuler: TButton;
    PanelActions: TPanel;
    ButtonNouveau: TButton;
    ButtonModifier: TButton;
    ButtonSupprimer: TButton;
    StatusBar1: TStatusBar;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonRechercherClick(Sender: TObject);
    procedure ButtonNouveauClick(Sender: TObject);
    procedure ButtonModifierClick(Sender: TObject);
    procedure ButtonSupprimerClick(Sender: TObject);
    procedure ButtonEnregistrerClick(Sender: TObject);
    procedure ButtonAnnulerClick(Sender: TObject);
    procedure DBGrid1DblClick(Sender: TObject);
  private
    FProduitID: Integer;
    FModeEdition: Boolean;

    procedure ChargerCategories;
    procedure ChargerProduits;
    procedure ChargerProduit(ID: Integer);
    procedure EffacerFormulaire;
    function ValidationFormulaire: Boolean;
    procedure ModeAjout;
    procedure ModeModification(ID: Integer);
    procedure ModeConsultation;
  public
    { Public declarations }
  end;

var
  FormProduits: TFormProduits;

implementation

{$R *.dfm}

procedure TFormProduits.FormCreate(Sender: TObject);
begin
  // Initialiser la connexion à la base de données
  FDConnection1.DriverName := 'MySQL';
  FDConnection1.Params.Clear;
  FDConnection1.Params.Add('Server=localhost');
  FDConnection1.Params.Add('Database=ma_base');
  FDConnection1.Params.Add('User_Name=mon_utilisateur');
  FDConnection1.Params.Add('Password=mon_mot_de_passe');

  try
    FDConnection1.Connected := True;

    // Charger les données initiales
    ChargerCategories;
    ChargerProduits;

    // Configurer l'interface
    DataSource1.DataSet := FDQuery1;
    PageControl1.ActivePage := TabSheetListe;
    ModeConsultation;

    StatusBar1.SimpleText := 'Prêt';
  except
    on E: Exception do
    begin
      ShowMessage('Erreur de connexion : ' + E.Message);
      StatusBar1.SimpleText := 'Non connecté';
    end;
  end;
end;

procedure TFormProduits.FormDestroy(Sender: TObject);
begin
  if FDConnection1.Connected then
    FDConnection1.Connected := False;
end;

procedure TFormProduits.ChargerCategories;
var
  Query: TFDQuery;
begin
  ComboBoxCategorie.Items.Clear;
  ComboBoxCategorie.Items.AddObject('(Aucune)', TObject(0));

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;
    Query.SQL.Text := 'SELECT id, nom FROM categories ORDER BY nom';
    Query.Open;

    while not Query.Eof do
    begin
      // Ajouter chaque catégorie avec son ID stocké dans l'objet
      ComboBoxCategorie.Items.AddObject(
        Query.FieldByName('nom').AsString,
        TObject(Query.FieldByName('id').AsInteger)
      );

      Query.Next;
    end;

    // Sélectionner la première option par défaut
    ComboBoxCategorie.ItemIndex := 0;
  finally
    Query.Free;
  end;
end;

procedure TFormProduits.ChargerProduits;
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'SELECT p.*, c.nom AS categorie_nom ' +
    'FROM produits p ' +
    'LEFT JOIN categories c ON p.categorie_id = c.id ' +
    'ORDER BY p.nom';
  FDQuery1.Open;

  StatusBar1.SimpleText := Format('%d produits trouvés', [FDQuery1.RecordCount]);
end;

procedure TFormProduits.ButtonRechercherClick(Sender: TObject);
var
  Recherche: string;
begin
  Recherche := Trim(EditRecherche.Text);

  FDQuery1.Close;

  if Recherche = '' then
  begin
    // Si aucun terme de recherche, afficher tous les produits
    FDQuery1.SQL.Text :=
      'SELECT p.*, c.nom AS categorie_nom ' +
      'FROM produits p ' +
      'LEFT JOIN categories c ON p.categorie_id = c.id ' +
      'ORDER BY p.nom';
  end
  else
  begin
    // Recherche sur plusieurs champs
    FDQuery1.SQL.Text :=
      'SELECT p.*, c.nom AS categorie_nom ' +
      'FROM produits p ' +
      'LEFT JOIN categories c ON p.categorie_id = c.id ' +
      'WHERE p.reference LIKE :recherche OR p.nom LIKE :recherche OR p.description LIKE :recherche ' +
      'ORDER BY p.nom';

    FDQuery1.ParamByName('recherche').AsString := '%' + Recherche + '%';
  end;

  FDQuery1.Open;

  StatusBar1.SimpleText := Format('%d produits trouvés', [FDQuery1.RecordCount]);
end;

procedure TFormProduits.ButtonNouveauClick(Sender: TObject);
begin
  ModeAjout;
end;

procedure TFormProduits.ButtonModifierClick(Sender: TObject);
begin
  if FDQuery1.IsEmpty then
  begin
    ShowMessage('Veuillez sélectionner un produit à modifier.');
    Exit;
  end;

  ModeModification(FDQuery1.FieldByName('id').AsInteger);
end;

procedure TFormProduits.ButtonSupprimerClick(Sender: TObject);
var
  ID: Integer;
  Query: TFDQuery;
begin
  if FDQuery1.IsEmpty then
  begin
    ShowMessage('Veuillez sélectionner un produit à supprimer.');
    Exit;
  end;

  // Récupérer l'ID du produit sélectionné
  ID := FDQuery1.FieldByName('id').AsInteger;

  // Demander confirmation
  if MessageDlg(Format('Êtes-vous sûr de vouloir supprimer le produit "%s" ?',
     [FDQuery1.FieldByName('nom').AsString]),
     mtConfirmation, [mbYes, mbNo], 0) <> mrYes then
    Exit;

  // Exécuter la suppression
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    Query.SQL.Text := 'DELETE FROM produits WHERE id = :id';
    Query.ParamByName('id').AsInteger := ID;

    Query.ExecSQL;

    if Query.RowsAffected > 0 then
    begin
      ShowMessage('Produit supprimé avec succès !');

      // Rafraîchir la liste
      ChargerProduits;
    end
    else
      ShowMessage('Erreur : Aucun produit n''a été supprimé.');
  except
    on E: Exception do
      ShowMessage('Erreur lors de la suppression : ' + E.Message);
  finally
    Query.Free;
  end;
end;

procedure TFormProduits.DBGrid1DblClick(Sender: TObject);
begin
  if not FDQuery1.IsEmpty then
    ModeModification(FDQuery1.FieldByName('id').AsInteger);
end;

procedure TFormProduits.ButtonEnregistrerClick(Sender: TObject);
var
  Query: TFDQuery;
  CategorieID: Integer;
begin
  // Valider les données du formulaire
  if not ValidationFormulaire then
    Exit;

  // Récupérer l'ID de la catégorie sélectionnée
  if ComboBoxCategorie.ItemIndex > 0 then
    CategorieID := Integer(ComboBoxCategorie.Items.Objects[ComboBoxCategorie.ItemIndex])
  else
    CategorieID := 0;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    if FModeEdition and (FProduitID > 0) then
    begin
      // Mode modification
      Query.SQL.Text :=
        'UPDATE produits SET ' +
        'reference = :reference, ' +
        'nom = :nom, ' +
        'description = :description, ' +
        'prix = :prix, ' +
        'stock = :stock, ' +
        'categorie_id = :categorie_id ' +
        'WHERE id = :id';

      Query.ParamByName('id').AsInteger := FProduitID;
    end
    else
    begin
      // Mode ajout
      Query.SQL.Text :=
        'INSERT INTO produits ' +
        '(reference, nom, description, prix, stock, categorie_id) ' +
        'VALUES (:reference, :nom, :description, :prix, :stock, :categorie_id)';
    end;

    // Définir les paramètres communs
    Query.ParamByName('reference').AsString := Trim(EditReference.Text);
    Query.ParamByName('nom').AsString := Trim(EditNom.Text);
    Query.ParamByName('description').AsString := Trim(MemoDescription.Text);
    Query.ParamByName('prix').AsFloat := StrToFloatDef(EditPrix.Text, 0);
    Query.ParamByName('stock').AsInteger := StrToIntDef(EditStock.Text, 0);

    // Gérer la catégorie (potentiellement NULL)
    if CategorieID > 0 then
      Query.ParamByName('categorie_id').AsInteger := CategorieID
    else
      Query.ParamByName('categorie_id').Clear;

    // Exécuter la requête
    Query.ExecSQL;

    if FModeEdition and (FProduitID > 0) then
      ShowMessage('Produit modifié avec succès !')
    else
      ShowMessage('Produit ajouté avec succès !');

    // Revenir au mode consultation
    ModeConsultation;

    // Rafraîchir la liste des produits
    ChargerProduits;
  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  finally
    Query.Free;
  end;
end;

procedure TFormProduits.ButtonAnnulerClick(Sender: TObject);
begin
  // Annuler les modifications et revenir au mode consultation
  ModeConsultation;
end;

procedure TFormProduits.ChargerProduit(ID: Integer);
var
  Query: TFDQuery;
  i: Integer;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    Query.SQL.Text := 'SELECT * FROM produits WHERE id = :id';
    Query.ParamByName('id').AsInteger := ID;
    Query.Open;

    if not Query.IsEmpty then
    begin
      // Remplir les champs du formulaire
      EditReference.Text := Query.FieldByName('reference').AsString;
      EditNom.Text := Query.FieldByName('nom').AsString;
      MemoDescription.Text := Query.FieldByName('description').AsString;
      EditPrix.Text := FormatFloat('0.00', Query.FieldByName('prix').AsFloat);
      EditStock.Text := Query.FieldByName('stock').AsString;

      // Sélectionner la catégorie dans la combobox
      ComboBoxCategorie.ItemIndex := 0; // Par défaut "(Aucune)"

      if not Query.FieldByName('categorie_id').IsNull then
      begin
        var CategorieID := Query.FieldByName('categorie_id').AsInteger;

        // Rechercher la catégorie dans la liste
        for i := 0 to ComboBoxCategorie.Items.Count - 1 do
        begin
          if Integer(ComboBoxCategorie.Items.Objects[i]) = CategorieID then
          begin
            ComboBoxCategorie.ItemIndex := i;
            Break;
          end;
        end;
      end;

      // Stocker l'ID du produit pour la mise à jour
      FProduitID := ID;
    end;
  finally
    Query.Free;
  end;
end;

procedure TFormProduits.EffacerFormulaire;
begin
  EditReference.Text := '';
  EditNom.Text := '';
  MemoDescription.Text := '';
  EditPrix.Text := '0.00';
  EditStock.Text := '0';
  ComboBoxCategorie.ItemIndex := 0; // "(Aucune)"

  FProduitID := 0;
end;

function TFormProduits.ValidationFormulaire: Boolean;
begin
  Result := False;

  // Validation du champ Référence
  if Trim(EditReference.Text) = '' then
  begin
    ShowMessage('La référence du produit est obligatoire.');
    EditReference.SetFocus;
    Exit;
  end;

  // Validation du champ Nom
  if Trim(EditNom.Text) = '' then
  begin
    ShowMessage('Le nom du produit est obligatoire.');
    EditNom.SetFocus;
    Exit;
  end;

  // Validation du champ Prix
  if StrToFloatDef(EditPrix.Text, -1) < 0 then
  begin
    ShowMessage('Le prix doit être un nombre positif.');
    EditPrix.SetFocus;
    Exit;
  end;

  // Validation du champ Stock
  if StrToIntDef(EditStock.Text, -1) < 0 then
  begin
    ShowMessage('Le stock doit être un nombre entier positif.');
    EditStock.SetFocus;
    Exit;
  end;

  Result := True;
end;

procedure TFormProduits.ModeAjout;
begin
  // Préparer le formulaire pour un nouvel enregistrement
  EffacerFormulaire;

  // Activer le mode édition
  FModeEdition := True;

  // Configurer l'interface
  PageControl1.ActivePage := TabSheetDetail;
  EditReference.Enabled := True;
  EditNom.Enabled := True;
  MemoDescription.Enabled := True;
  EditPrix.Enabled := True;
  EditStock.Enabled := True;
  ComboBoxCategorie.Enabled := True;

  ButtonEnregistrer.Visible := True;
  ButtonAnnuler.Visible := True;

  // Positionner le curseur
  EditReference.SetFocus;

  StatusBar1.SimpleText := 'Ajout d''un nouveau produit';
end;

procedure TFormProduits.ModeModification(ID: Integer);
begin
  // Charger les données du produit
  ChargerProduit(ID);

  // Activer le mode édition
  FModeEdition := True;

  // Configurer l'interface
  PageControl1.ActivePage := TabSheetDetail;
  EditReference.Enabled := True;
  EditNom.Enabled := True;
  MemoDescription.Enabled := True;
  EditPrix.Enabled := True;
  EditStock.Enabled := True;
  ComboBoxCategorie.Enabled := True;

  ButtonEnregistrer.Visible := True;
  ButtonAnnuler.Visible := True;

  // Positionner le curseur
  EditNom.SetFocus;

  StatusBar1.SimpleText := Format('Modification du produit ID=%d', [ID]);
end;

procedure TFormProduits.ModeConsultation;
begin
  // Désactiver le mode édition
  FModeEdition := False;

  // Configurer l'interface
  PageControl1.ActivePage := TabSheetListe;

  ButtonEnregistrer.Visible := False;
  ButtonAnnuler.Visible := False;

  StatusBar1.SimpleText := Format('%d produits trouvés', [FDQuery1.RecordCount]);
end;
```

## Optimisation des opérations CRUD

Maintenant que nous avons vu les bases des opérations CRUD, voici quelques conseils pour optimiser vos applications :

### 1. Utiliser les transactions

Les transactions garantissent l'intégrité des données, surtout pour les opérations multiples :

```delphi
procedure TFormProduits.MettreAJourStockEtPrix(ID: Integer; NouveauStock: Integer; NouveauPrix: Double);
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Démarrer une transaction
    Query.Connection.StartTransaction;
    try
      // Mise à jour du stock
      Query.SQL.Text := 'UPDATE produits SET stock = :stock WHERE id = :id';
      Query.ParamByName('stock').AsInteger := NouveauStock;
      Query.ParamByName('id').AsInteger := ID;
      Query.ExecSQL;

      // Mise à jour du prix
      Query.SQL.Text := 'UPDATE produits SET prix = :prix WHERE id = :id';
      Query.ParamByName('prix').AsFloat := NouveauPrix;
      Query.ParamByName('id').AsInteger := ID;
      Query.ExecSQL;

      // Si tout s'est bien passé, valider la transaction
      Query.Connection.Commit;

      ShowMessage('Stock et prix mis à jour avec succès !');
    except
      on E: Exception do
      begin
        // En cas d'erreur, annuler toutes les modifications
        Query.Connection.Rollback;
        ShowMessage('Erreur lors de la mise à jour : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;
```

### 2. Optimiser les requêtes pour de grandes quantités de données

Pour les grandes quantités de données, utilisez des techniques comme :

#### a. Chargement par lots (batching)

```delphi
procedure TFormProduits.ImporterProduits(const Fichier: string);
var
  Liste: TStringList;
  i, BatchSize, LotActuel: Integer;
  Query: TFDQuery;
begin
  Liste := TStringList.Create;
  try
    Liste.LoadFromFile(Fichier);

    if Liste.Count <= 1 then // Vérifier s'il y a des données (en excluant l'en-tête)
      Exit;

    Query := TFDQuery.Create(nil);
    try
      Query.Connection := FDConnection1;
      Query.SQL.Text :=
        'INSERT INTO produits (reference, nom, prix, stock) ' +
        'VALUES (:reference, :nom, :prix, :stock)';

      // Configurer les options de mise en cache pour de meilleures performances
      Query.ResourceOptions.DirectExecute := False;

      // Créer un dataset en mode batch pour l'insertion
      Query.Params.ArraySize := 0;

      BatchSize := 100; // Nombre d'enregistrements par lot
      LotActuel := 0;

      // Démarrer une transaction
      Query.Connection.StartTransaction;
      try
        // Ignorer l'en-tête (première ligne)
        for i := 1 to Liste.Count - 1 do
        begin
          var Elements := Liste[i].Split([';']);

          if Length(Elements) >= 4 then
          begin
            // Augmenter la taille du lot si nécessaire
            if Query.Params.ArraySize <= LotActuel then
              Query.Params.ArraySize := Query.Params.ArraySize + BatchSize;

            // Remplir les paramètres pour cet enregistrement
            Query.ParamByName('reference').AsStrings[LotActuel] := Elements[0];
            Query.ParamByName('nom').AsStrings[LotActuel] := Elements[1];
            Query.ParamByName('prix').AsFloats[LotActuel] := StrToFloatDef(Elements[2], 0);
            Query.ParamByName('stock').AsIntegers[LotActuel] := StrToIntDef(Elements[3], 0);

            Inc(LotActuel);

            // Si le lot est plein, exécuter l'insertion
            if LotActuel >= BatchSize then
            begin
              Query.Execute(LotActuel, 0);
              LotActuel := 0;
            end;
          end;
        end;

        // Exécuter le dernier lot s'il reste des enregistrements
        if LotActuel > 0 then
          Query.Execute(LotActuel, 0);

        // Valider la transaction
        Query.Connection.Commit;

        ShowMessage(Format('%d produits importés avec succès !', [Liste.Count - 1]));
      except
        on E: Exception do
        begin
          Query.Connection.Rollback;
          ShowMessage('Erreur lors de l''importation : ' + E.Message);
        end;
      end;
    finally
      Query.Free;
    end;
  finally
    Liste.Free;
  end;
end;
```

#### b. Paginer les résultats

```delphi
procedure TFormProduits.ChargerPageProduits(NumPage, ElementsParPage: Integer);
begin
  // Calculer l'offset pour la pagination
  var Offset := (NumPage - 1) * ElementsParPage;

  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'SELECT p.*, c.nom AS categorie_nom ' +
    'FROM produits p ' +
    'LEFT JOIN categories c ON p.categorie_id = c.id ' +
    'ORDER BY p.nom ' +
    'LIMIT :limit OFFSET :offset';

  FDQuery1.ParamByName('limit').AsInteger := ElementsParPage;
  FDQuery1.ParamByName('offset').AsInteger := Offset;

  FDQuery1.Open;

  // Mettre à jour les informations de pagination
  StatusBar1.SimpleText := Format('Page %d - Affichage des produits %d à %d',
    [NumPage, Offset + 1, Offset + FDQuery1.RecordCount]);
end;
```

#### c. Minimiser les données récupérées

```delphi
procedure TFormProduits.ChargerListeMinimale;
begin
  FDQuery1.Close;

  // Sélectionner uniquement les colonnes nécessaires pour la liste
  FDQuery1.SQL.Text :=
    'SELECT id, reference, nom, prix, stock ' +
    'FROM produits ' +
    'ORDER BY nom';

  FDQuery1.Open;
end;
```

### 3. Réutiliser les objets de requête

Pour de meilleures performances, réutilisez les objets de requête plutôt que de les créer et détruire fréquemment :

```delphi
// Ajouter une variable privée à la classe
private
  FQueryUtilitaire: TFDQuery;

// Initialiser dans FormCreate
procedure TFormProduits.FormCreate(Sender: TObject);
begin
  // Autres initialisations...

  // Créer la requête utilitaire une seule fois
  FQueryUtilitaire := TFDQuery.Create(Self);
  FQueryUtilitaire.Connection := FDConnection1;
end;

// Utiliser dans différentes méthodes
procedure TFormProduits.MettreAJourStock(ID, NouveauStock: Integer);
begin
  FQueryUtilitaire.Close;
  FQueryUtilitaire.SQL.Text := 'UPDATE produits SET stock = :stock WHERE id = :id';
  FQueryUtilitaire.ParamByName('stock').AsInteger := NouveauStock;
  FQueryUtilitaire.ParamByName('id').AsInteger := ID;
  FQueryUtilitaire.ExecSQL;
end;

// Libérer dans FormDestroy
procedure TFormProduits.FormDestroy(Sender: TObject);
begin
  FQueryUtilitaire.Free;

  // Autres libérations...
end;
```

### 4. Gérer les erreurs de contraintes

Les erreurs de clé étrangère et d'unicité sont courantes. Voici comment les gérer proprement :

```delphi
function TFormProduits.AjouterProduitSecurise(const Reference, Nom: string; Prix: Double): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Vérifier si la référence existe déjà
    Query.SQL.Text := 'SELECT COUNT(*) FROM produits WHERE reference = :reference';
    Query.ParamByName('reference').AsString := Reference;
    Query.Open;

    if Query.Fields[0].AsInteger > 0 then
    begin
      ShowMessage('Un produit avec cette référence existe déjà.');
      Exit;
    end;

    // Insérer le produit
    try
      Query.SQL.Text :=
        'INSERT INTO produits (reference, nom, prix) ' +
        'VALUES (:reference, :nom, :prix)';

      Query.ParamByName('reference').AsString := Reference;
      Query.ParamByName('nom').AsString := Nom;
      Query.ParamByName('prix').AsFloat := Prix;

      Query.ExecSQL;

      Result := True;
    except
      on E: Exception do
      begin
        // Analyser l'erreur pour donner un message plus précis
        if Pos('Duplicate', E.Message) > 0 then
          ShowMessage('Un produit avec cette référence existe déjà.')
        else if Pos('foreign key', E.Message) > 0 then
          ShowMessage('La catégorie spécifiée n''existe pas.')
        else
          ShowMessage('Erreur lors de l''ajout : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;
```

## Résumé des bonnes pratiques pour les opérations CRUD

Pour terminer cette section, voici un récapitulatif des bonnes pratiques à suivre :

1. **Toujours utiliser des requêtes paramétrées** pour éviter les injections SQL
2. **Encapsuler les opérations CRUD** dans des méthodes ou classes dédiées
3. **Utiliser des transactions** pour les opérations qui modifient plusieurs tables ou enregistrements
4. **Valider les données** avant de les envoyer à la base de données
5. **Gérer les erreurs** spécifiquement selon leur type
6. **Optimiser les requêtes** pour les grandes quantités de données
7. **Réutiliser les objets de requête** pour de meilleures performances
8. **Limiter les données récupérées** aux colonnes nécessaires
9. **Paginer les résultats** pour les grandes tables
10. **Documenter** clairement les contraintes et dépendances entre tables

En suivant ces principes, vos applications seront plus robustes, plus performantes et plus faciles à maintenir.

Dans la prochaine section, nous explorerons les transactions et l'intégrité des données plus en détail.

---

**À suivre :** 8.5.3 Transactions et intégrité des données
