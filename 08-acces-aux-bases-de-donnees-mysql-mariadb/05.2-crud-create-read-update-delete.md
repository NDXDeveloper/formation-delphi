# 8.5.2 CRUD : Create, Read, Update, Delete

üîù Retour √† la [Table des mati√®res](/SOMMAIRE.md)

L'acronyme CRUD d√©signe les quatre op√©rations fondamentales pour manipuler des donn√©es dans une base de donn√©es :
- **C**reate (Cr√©er) : Ajouter de nouvelles donn√©es
- **R**ead (Lire) : R√©cup√©rer des donn√©es existantes
- **U**pdate (Mettre √† jour) : Modifier des donn√©es existantes
- **D**elete (Supprimer) : Effacer des donn√©es

Dans cette section, nous allons explorer en d√©tail chacune de ces op√©rations et voir comment les impl√©menter efficacement dans vos applications Delphi avec MySQL/MariaDB.

## Pr√©paration de l'environnement

Pour illustrer les op√©rations CRUD, nous allons cr√©er un exemple pratique bas√© sur une table `produits`. Si vous n'avez pas encore cette table, voici le script SQL pour la cr√©er :

```sql
CREATE TABLE produits (
  id INT AUTO_INCREMENT PRIMARY KEY,
  reference VARCHAR(20) NOT NULL,
  nom VARCHAR(100) NOT NULL,
  description TEXT,
  prix DECIMAL(10,2) NOT NULL,
  stock INT DEFAULT 0,
  categorie_id INT,
  date_creation DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

## C - Create : Ajouter des donn√©es

L'op√©ration Create consiste √† ins√©rer de nouvelles donn√©es dans la base de donn√©es. En SQL, cela se fait avec l'instruction `INSERT INTO`.

### M√©thode 1 : Insertion simple avec TFDQuery

```delphi
procedure TForm1.AjouterProduit(const Reference, Nom, Description: string;
                               Prix: Double; Stock: Integer; CategorieID: Integer);
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Pr√©parer la requ√™te d'insertion
    Query.SQL.Text :=
      'INSERT INTO produits (reference, nom, description, prix, stock, categorie_id) ' +
      'VALUES (:reference, :nom, :description, :prix, :stock, :categorie_id)';

    // D√©finir les param√®tres
    Query.ParamByName('reference').AsString := Reference;
    Query.ParamByName('nom').AsString := Nom;
    Query.ParamByName('description').AsString := Description;
    Query.ParamByName('prix').AsFloat := Prix;
    Query.ParamByName('stock').AsInteger := Stock;

    // G√©rer un param√®tre potentiellement NULL
    if CategorieID > 0 then
      Query.ParamByName('categorie_id').AsInteger := CategorieID
    else
      Query.ParamByName('categorie_id').Clear;

    // Ex√©cuter l'insertion
    Query.ExecSQL;

    ShowMessage('Produit ajout√© avec succ√®s !');
  except
    on E: Exception do
      ShowMessage('Erreur lors de l''ajout du produit : ' + E.Message);
  finally
    Query.Free;
  end;
end;
```

### M√©thode 2 : Insertion avec r√©cup√©ration de l'ID g√©n√©r√©

Souvent, vous voudrez r√©cup√©rer l'ID auto-g√©n√©r√© du nouvel enregistrement :

```delphi
function TForm1.AjouterProduitEtObtenirID(const Reference, Nom: string;
                                        Prix: Double): Integer;
var
  Query: TFDQuery;
begin
  Result := -1; // Valeur par d√©faut en cas d'√©chec

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Utiliser une transaction pour garantir la coh√©rence
    Query.Connection.StartTransaction;
    try
      // Ins√©rer le produit
      Query.SQL.Text :=
        'INSERT INTO produits (reference, nom, prix) ' +
        'VALUES (:reference, :nom, :prix)';

      Query.ParamByName('reference').AsString := Reference;
      Query.ParamByName('nom').AsString := Nom;
      Query.ParamByName('prix').AsFloat := Prix;

      Query.ExecSQL;

      // R√©cup√©rer l'ID g√©n√©r√©
      Query.SQL.Text := 'SELECT LAST_INSERT_ID() AS id';
      Query.Open;

      Result := Query.FieldByName('id').AsInteger;

      // Valider la transaction
      Query.Connection.Commit;
    except
      // En cas d'erreur, annuler la transaction
      Query.Connection.Rollback;
      raise; // Relancer l'exception pour la gestion en amont
    end;
  finally
    Query.Free;
  end;
end;
```

### M√©thode 3 : Insertion multiple (par lots)

Pour ins√©rer plusieurs enregistrements efficacement :

```delphi
procedure TForm1.AjouterProduitsMassifs(const Produits: array of TProduit);
var
  Query: TFDQuery;
  i: Integer;
begin
  if Length(Produits) = 0 then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Pr√©parer la requ√™te d'insertion
    Query.SQL.Text :=
      'INSERT INTO produits (reference, nom, prix, stock) ' +
      'VALUES (:reference, :nom, :prix, :stock)';

    // Pr√©parer la requ√™te pour de meilleures performances
    Query.Prepare;

    // Utiliser une transaction pour de meilleures performances
    Query.Connection.StartTransaction;
    try
      for i := 0 to High(Produits) do
      begin
        // D√©finir les param√®tres pour chaque produit
        Query.ParamByName('reference').AsString := Produits[i].Reference;
        Query.ParamByName('nom').AsString := Produits[i].Nom;
        Query.ParamByName('prix').AsFloat := Produits[i].Prix;
        Query.ParamByName('stock').AsInteger := Produits[i].Stock;

        // Ex√©cuter l'insertion
        Query.ExecSQL;
      end;

      // Valider toutes les insertions
      Query.Connection.Commit;

      ShowMessage(Format('%d produits ajout√©s avec succ√®s !', [Length(Produits)]));
    except
      on E: Exception do
      begin
        // Annuler toutes les insertions en cas d'erreur
        Query.Connection.Rollback;
        ShowMessage('Erreur lors de l''ajout des produits : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;
```

### M√©thode 4 : Utilisation de TFDTable

`TFDTable` offre une approche plus orient√©e objet pour les op√©rations CRUD :

```delphi
procedure TForm1.AjouterProduitAvecTable(const Reference, Nom: string; Prix: Double);
var
  Table: TFDTable;
begin
  Table := TFDTable.Create(nil);
  try
    Table.Connection := FDConnection1;
    Table.TableName := 'produits';
    Table.Open;

    // Commencer l'ajout d'un nouvel enregistrement
    Table.Append;

    // Remplir les champs
    Table.FieldByName('reference').AsString := Reference;
    Table.FieldByName('nom').AsString := Nom;
    Table.FieldByName('prix').AsFloat := Prix;
    Table.FieldByName('stock').AsInteger := 0;

    // Enregistrer les modifications
    Table.Post;

    ShowMessage('Produit ajout√© avec succ√®s !');
  except
    on E: Exception do
    begin
      if Table.State in [dsInsert, dsEdit] then
        Table.Cancel; // Annuler l'op√©ration en cours en cas d'erreur

      ShowMessage('Erreur lors de l''ajout du produit : ' + E.Message);
    end;
  finally
    Table.Free;
  end;
end;
```

## R - Read : Lire des donn√©es

L'op√©ration Read consiste √† r√©cup√©rer des donn√©es de la base de donn√©es. En SQL, cela se fait avec l'instruction `SELECT`.

### M√©thode 1 : Lecture simple de tous les enregistrements

```delphi
procedure TForm1.AfficherTousProduits;
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text := 'SELECT * FROM produits ORDER BY nom';
  FDQuery1.Open;

  // √Ä ce stade, les donn√©es sont disponibles dans FDQuery1
  // et peuvent √™tre affich√©es via un TDBGrid li√© √† un TDataSource
  // connect√© √† ce FDQuery1
end;
```

### M√©thode 2 : Lecture avec filtrage

```delphi
procedure TForm1.RechercherProduits(const Terme: string; CategorieID: Integer);
var
  SQL: string;
begin
  // Construire la requ√™te de base
  SQL := 'SELECT p.*, c.nom AS categorie_nom ' +
         'FROM produits p ' +
         'LEFT JOIN categories c ON p.categorie_id = c.id ' +
         'WHERE 1=1'; // Clause toujours vraie comme point de d√©part

  // Ajouter des conditions de filtrage selon les param√®tres
  if Terme <> '' then
    SQL := SQL + ' AND (p.nom LIKE :terme OR p.reference LIKE :terme OR p.description LIKE :terme)';

  if CategorieID > 0 then
    SQL := SQL + ' AND p.categorie_id = :categorie_id';

  SQL := SQL + ' ORDER BY p.nom';

  // Configurer et ex√©cuter la requ√™te
  FDQuery1.Close;
  FDQuery1.SQL.Text := SQL;

  // D√©finir les param√®tres si n√©cessaire
  if Terme <> '' then
    FDQuery1.ParamByName('terme').AsString := '%' + Terme + '%';

  if CategorieID > 0 then
    FDQuery1.ParamByName('categorie_id').AsInteger := CategorieID;

  FDQuery1.Open;

  // Mise √† jour de l'interface
  StatusBar1.SimpleText := Format('%d produits trouv√©s', [FDQuery1.RecordCount]);
end;
```

### M√©thode 3 : Lecture d'un enregistrement sp√©cifique

```delphi
function TForm1.ObtenirProduit(ID: Integer): TProduit;
var
  Query: TFDQuery;
begin
  // Initialiser le r√©sultat
  Result.ID := 0;
  Result.Reference := '';
  Result.Nom := '';
  Result.Prix := 0;
  Result.Stock := 0;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;
    Query.SQL.Text := 'SELECT * FROM produits WHERE id = :id';
    Query.ParamByName('id').AsInteger := ID;
    Query.Open;

    if not Query.IsEmpty then
    begin
      // Remplir la structure avec les donn√©es
      Result.ID := Query.FieldByName('id').AsInteger;
      Result.Reference := Query.FieldByName('reference').AsString;
      Result.Nom := Query.FieldByName('nom').AsString;
      Result.Description := Query.FieldByName('description').AsString;
      Result.Prix := Query.FieldByName('prix').AsFloat;
      Result.Stock := Query.FieldByName('stock').AsInteger;

      if not Query.FieldByName('categorie_id').IsNull then
        Result.CategorieID := Query.FieldByName('categorie_id').AsInteger;
    end;
  finally
    Query.Free;
  end;
end;
```

### M√©thode 4 : Lecture avec pagination

Pour les tables volumineuses, il est souvent n√©cessaire de paginer les r√©sultats :

```delphi
procedure TForm1.ChargerPageProduits(NumPage: Integer; ElementsParPage: Integer);
var
  Offset: Integer;
begin
  // Calculer l'offset (d√©calage) pour la pagination
  Offset := (NumPage - 1) * ElementsParPage;

  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'SELECT * FROM produits ORDER BY nom LIMIT :limit OFFSET :offset';

  FDQuery1.ParamByName('limit').AsInteger := ElementsParPage;
  FDQuery1.ParamByName('offset').AsInteger := Offset;

  FDQuery1.Open;

  // Mettre √† jour les informations de pagination
  LabelPagination.Caption := Format('Page %d sur %d',
    [NumPage, Ceil(CompteTotalProduits / ElementsParPage)]);
end;

function TForm1.CompteTotalProduits: Integer;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;
    Query.SQL.Text := 'SELECT COUNT(*) AS total FROM produits';
    Query.Open;

    Result := Query.FieldByName('total').AsInteger;
  finally
    Query.Free;
  end;
end;
```

### M√©thode 5 : Lecture avec agr√©gation

Pour obtenir des statistiques et des r√©sum√©s :

```delphi
procedure TForm1.AfficherStatistiquesProduits;
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'SELECT ' +
    '  c.nom AS categorie, ' +
    '  COUNT(*) AS nombre_produits, ' +
    '  MIN(p.prix) AS prix_min, ' +
    '  MAX(p.prix) AS prix_max, ' +
    '  AVG(p.prix) AS prix_moyen, ' +
    '  SUM(p.stock) AS stock_total ' +
    'FROM produits p ' +
    'LEFT JOIN categories c ON p.categorie_id = c.id ' +
    'GROUP BY p.categorie_id ' +
    'ORDER BY nombre_produits DESC';

  FDQuery1.Open;

  // Maintenant, FDQuery1 contient les statistiques par cat√©gorie
  // que vous pouvez afficher ou traiter...
end;
```

## U - Update : Mettre √† jour des donn√©es

L'op√©ration Update consiste √† modifier des donn√©es existantes dans la base de donn√©es. En SQL, cela se fait avec l'instruction `UPDATE`.

### M√©thode 1 : Mise √† jour simple avec TFDQuery

```delphi
procedure TForm1.ModifierProduit(ID: Integer; const Nom, Description: string;
                                Prix: Double; Stock: Integer);
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Pr√©parer la requ√™te de mise √† jour
    Query.SQL.Text :=
      'UPDATE produits SET ' +
      'nom = :nom, description = :description, prix = :prix, stock = :stock ' +
      'WHERE id = :id';

    // D√©finir les param√®tres
    Query.ParamByName('nom').AsString := Nom;
    Query.ParamByName('description').AsString := Description;
    Query.ParamByName('prix').AsFloat := Prix;
    Query.ParamByName('stock').AsInteger := Stock;
    Query.ParamByName('id').AsInteger := ID;

    // Ex√©cuter la mise √† jour
    Query.ExecSQL;

    if Query.RowsAffected > 0 then
      ShowMessage('Produit modifi√© avec succ√®s !')
    else
      ShowMessage('Aucun produit n''a √©t√© modifi√©. V√©rifiez l''ID.');
  except
    on E: Exception do
      ShowMessage('Erreur lors de la modification du produit : ' + E.Message);
  finally
    Query.Free;
  end;
end;
```

### M√©thode 2 : Mise √† jour conditionnelle

```delphi
function TForm1.AugmenterPrixProduits(CategorieID: Integer;
                                    PourcentageAugmentation: Double): Integer;
var
  Query: TFDQuery;
begin
  Result := 0; // Nombre de produits mis √† jour

  if (CategorieID <= 0) or (PourcentageAugmentation <= 0) then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Mise √† jour avec calcul
    Query.SQL.Text :=
      'UPDATE produits ' +
      'SET prix = prix * (1 + :pourcentage / 100) ' +
      'WHERE categorie_id = :categorie_id';

    Query.ParamByName('pourcentage').AsFloat := PourcentageAugmentation;
    Query.ParamByName('categorie_id').AsInteger := CategorieID;

    Query.ExecSQL;

    Result := Query.RowsAffected;
  finally
    Query.Free;
  end;
end;
```

### M√©thode 3 : Mise √† jour avec TFDTable

```delphi
procedure TForm1.ModifierProduitAvecTable(ID: Integer; NouveauStock: Integer);
var
  Table: TFDTable;
begin
  Table := TFDTable.Create(nil);
  try
    Table.Connection := FDConnection1;
    Table.TableName := 'produits';
    Table.IndexFieldNames := 'id'; // D√©finir un index pour la recherche
    Table.Open;

    // Rechercher l'enregistrement √† modifier
    if Table.FindKey([ID]) then
    begin
      // Commencer l'√©dition
      Table.Edit;

      // Modifier le champ stock
      Table.FieldByName('stock').AsInteger := NouveauStock;

      // Enregistrer les modifications
      Table.Post;

      ShowMessage('Stock du produit mis √† jour avec succ√®s !');
    end
    else
      ShowMessage('Produit non trouv√©. V√©rifiez l''ID.');
  except
    on E: Exception do
    begin
      if Table.State in [dsEdit, dsInsert] then
        Table.Cancel; // Annuler l'op√©ration en cours

      ShowMessage('Erreur lors de la mise √† jour : ' + E.Message);
    end;
  finally
    Table.Free;
  end;
end;
```

### M√©thode 4 : Mise √† jour d'un champ unique

```delphi
function TForm1.DecrementStock(ProduitID: Integer; Quantite: Integer): Boolean;
var
  Query: TFDQuery;
  StockActuel: Integer;
begin
  Result := False;

  if (ProduitID <= 0) or (Quantite <= 0) then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // V√©rifier le stock actuel
    Query.SQL.Text := 'SELECT stock FROM produits WHERE id = :id';
    Query.ParamByName('id').AsInteger := ProduitID;
    Query.Open;

    if Query.IsEmpty then
      Exit; // Produit non trouv√©

    StockActuel := Query.FieldByName('stock').AsInteger;

    if StockActuel < Quantite then
      Exit; // Stock insuffisant

    // Mettre √† jour le stock
    Query.Close;
    Query.SQL.Text :=
      'UPDATE produits ' +
      'SET stock = stock - :quantite ' +
      'WHERE id = :id AND stock >= :quantite';

    Query.ParamByName('quantite').AsInteger := Quantite;
    Query.ParamByName('id').AsInteger := ProduitID;

    Query.ExecSQL;

    Result := Query.RowsAffected > 0;
  finally
    Query.Free;
  end;
end;
```

## D - Delete : Supprimer des donn√©es

L'op√©ration Delete consiste √† supprimer des donn√©es de la base de donn√©es. En SQL, cela se fait avec l'instruction `DELETE`.

### M√©thode 1 : Suppression simple avec TFDQuery

```delphi
function TForm1.SupprimerProduit(ID: Integer): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  // Demander confirmation √† l'utilisateur
  if MessageDlg(Format('√ätes-vous s√ªr de vouloir supprimer le produit ID %d ?', [ID]),
     mtConfirmation, [mbYes, mbNo], 0) <> mrYes then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Pr√©parer la requ√™te de suppression
    Query.SQL.Text := 'DELETE FROM produits WHERE id = :id';
    Query.ParamByName('id').AsInteger := ID;

    // Ex√©cuter la suppression
    Query.ExecSQL;

    Result := Query.RowsAffected > 0;

    if Result then
      ShowMessage('Produit supprim√© avec succ√®s !')
    else
      ShowMessage('Aucun produit avec cet ID n''a √©t√© trouv√©.');
  except
    on E: Exception do
      ShowMessage('Erreur lors de la suppression du produit : ' + E.Message);
  finally
    Query.Free;
  end;
end;
```

### M√©thode 2 : Suppression conditionnelle

```delphi
function TForm1.SupprimerProduitsObsoletes(JoursInactivite: Integer): Integer;
var
  Query: TFDQuery;
  DateLimite: TDateTime;
begin
  Result := 0; // Nombre de produits supprim√©s

  // Calculer la date limite
  DateLimite := IncDay(Now, -JoursInactivite);

  // Demander confirmation
  if MessageDlg('Cette op√©ration va supprimer tous les produits sans stock ' +
                'qui n''ont pas √©t√© mis √† jour depuis plus de ' +
                IntToStr(JoursInactivite) + ' jours. Continuer ?',
     mtWarning, [mbYes, mbNo], 0) <> mrYes then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Supprimer les produits obsol√®tes
    Query.SQL.Text :=
      'DELETE FROM produits ' +
      'WHERE stock = 0 AND date_modification < :date_limite';

    Query.ParamByName('date_limite').AsDateTime := DateLimite;
    Query.ExecSQL;

    Result := Query.RowsAffected;
  finally
    Query.Free;
  end;
end;
```

### M√©thode 3 : Suppression avec TFDTable

```delphi
procedure TForm1.SupprimerProduitAvecTable(ID: Integer);
var
  Table: TFDTable;
begin
  Table := TFDTable.Create(nil);
  try
    Table.Connection := FDConnection1;
    Table.TableName := 'produits';
    Table.IndexFieldNames := 'id';
    Table.Open;

    // Rechercher l'enregistrement √† supprimer
    if Table.FindKey([ID]) then
    begin
      // Supprimer l'enregistrement
      Table.Delete;

      ShowMessage('Produit supprim√© avec succ√®s !');
    end
    else
      ShowMessage('Produit non trouv√©. V√©rifiez l''ID.');
  except
    on E: Exception do
      ShowMessage('Erreur lors de la suppression : ' + E.Message);
  finally
    Table.Free;
  end;
end;
```

### M√©thode 4 : Suppression logique (sans effacer les donn√©es)

Dans certains cas, il est pr√©f√©rable de marquer les enregistrements comme supprim√©s plut√¥t que de les effacer r√©ellement :

```delphi
function TForm1.DesactiverProduit(ID: Integer): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // Mise √† jour du statut au lieu de suppression
    Query.SQL.Text :=
      'UPDATE produits ' +
      'SET actif = 0, date_modification = NOW() ' +
      'WHERE id = :id';

    Query.ParamByName('id').AsInteger := ID;
    Query.ExecSQL;

    Result := Query.RowsAffected > 0;
  finally
    Query.Free;
  end;
end;
```

## Impl√©mentation pratique : Formulaire de gestion des produits

Voyons maintenant comment combiner ces op√©rations CRUD dans un formulaire complet de gestion des produits.

```delphi
unit UFormProduits;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, FireDAC.Stan.Intf,
  FireDAC.Stan.Option, FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf,
  FireDAC.Stan.Def, FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys,
  FireDAC.Phys.MySQL, FireDAC.Phys.MySQLDef, FireDAC.VCLUI.Wait, FireDAC.Stan.Param,
  FireDAC.DatS, FireDAC.DApt.Intf, FireDAC.DApt, Data.DB, FireDAC.Comp.DataSet,
  FireDAC.Comp.Client, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Grids, Vcl.DBGrids,
  Vcl.ComCtrls;

type
  TProduit = record
    ID: Integer;
    Reference: string;
    Nom: string;
    Description: string;
    Prix: Double;
    Stock: Integer;
    CategorieID: Integer;
  end;

  TFormProduits = class(TForm)
    FDConnection1: TFDConnection;
    FDQuery1: TFDQuery;
    DataSource1: TDataSource;
    PageControl1: TPageControl;
    TabSheetListe: TTabSheet;
    TabSheetDetail: TTabSheet;
    PanelRecherche: TPanel;
    LabelRecherche: TLabel;
    EditRecherche: TEdit;
    ButtonRechercher: TButton;
    DBGrid1: TDBGrid;
    EditReference: TEdit;
    EditNom: TEdit;
    MemoDescription: TMemo;
    EditPrix: TEdit;
    EditStock: TEdit;
    ComboBoxCategorie: TComboBox;
    LabelReference: TLabel;
    LabelNom: TLabel;
    LabelDescription: TLabel;
    LabelPrix: TLabel;
    LabelStock: TLabel;
    LabelCategorie: TLabel;
    ButtonEnregistrer: TButton;
    ButtonAnnuler: TButton;
    PanelActions: TPanel;
    ButtonNouveau: TButton;
    ButtonModifier: TButton;
    ButtonSupprimer: TButton;
    StatusBar1: TStatusBar;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonRechercherClick(Sender: TObject);
    procedure ButtonNouveauClick(Sender: TObject);
    procedure ButtonModifierClick(Sender: TObject);
    procedure ButtonSupprimerClick(Sender: TObject);
    procedure ButtonEnregistrerClick(Sender: TObject);
    procedure ButtonAnnulerClick(Sender: TObject);
    procedure DBGrid1DblClick(Sender: TObject);
  private
    FProduitID: Integer;
    FModeEdition: Boolean;

    procedure ChargerCategories;
    procedure ChargerProduits;
    procedure ChargerProduit(ID: Integer);
    procedure EffacerFormulaire;
    function ValidationFormulaire: Boolean;
    procedure ModeAjout;
    procedure ModeModification(ID: Integer);
    procedure ModeConsultation;
  public
    { Public declarations }
  end;

var
  FormProduits: TFormProduits;

implementation

{$R *.dfm}

procedure TFormProduits.FormCreate(Sender: TObject);
begin
  // Initialiser la connexion √† la base de donn√©es
  FDConnection1.DriverName := 'MySQL';
  FDConnection1.Params.Clear;
  FDConnection1.Params.Add('Server=localhost');
  FDConnection1.Params.Add('Database=ma_base');
  FDConnection1.Params.Add('User_Name=mon_utilisateur');
  FDConnection1.Params.Add('Password=mon_mot_de_passe');

  try
    FDConnection1.Connected := True;

    // Charger les donn√©es initiales
    ChargerCategories;
    ChargerProduits;

    // Configurer l'interface
    DataSource1.DataSet := FDQuery1;
    PageControl1.ActivePage := TabSheetListe;
    ModeConsultation;

    StatusBar1.SimpleText := 'Pr√™t';
  except
    on E: Exception do
    begin
      ShowMessage('Erreur de connexion : ' + E.Message);
      StatusBar1.SimpleText := 'Non connect√©';
    end;
  end;
end;

procedure TFormProduits.FormDestroy(Sender: TObject);
begin
  if FDConnection1.Connected then
    FDConnection1.Connected := False;
end;

procedure TFormProduits.ChargerCategories;
var
  Query: TFDQuery;
begin
  ComboBoxCategorie.Items.Clear;
  ComboBoxCategorie.Items.AddObject('(Aucune)', TObject(0));

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;
    Query.SQL.Text := 'SELECT id, nom FROM categories ORDER BY nom';
    Query.Open;

    while not Query.Eof do
    begin
      // Ajouter chaque cat√©gorie avec son ID stock√© dans l'objet
      ComboBoxCategorie.Items.AddObject(
        Query.FieldByName('nom').AsString,
        TObject(Query.FieldByName('id').AsInteger)
      );

      Query.Next;
    end;

    // S√©lectionner la premi√®re option par d√©faut
    ComboBoxCategorie.ItemIndex := 0;
  finally
    Query.Free;
  end;
end;

procedure TFormProduits.ChargerProduits;
begin
  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'SELECT p.*, c.nom AS categorie_nom ' +
    'FROM produits p ' +
    'LEFT JOIN categories c ON p.categorie_id = c.id ' +
    'ORDER BY p.nom';
  FDQuery1.Open;

  StatusBar1.SimpleText := Format('%d produits trouv√©s', [FDQuery1.RecordCount]);
end;

procedure TFormProduits.ButtonRechercherClick(Sender: TObject);
var
  Recherche: string;
begin
  Recherche := Trim(EditRecherche.Text);

  FDQuery1.Close;

  if Recherche = '' then
  begin
    // Si aucun terme de recherche, afficher tous les produits
    FDQuery1.SQL.Text :=
      'SELECT p.*, c.nom AS categorie_nom ' +
      'FROM produits p ' +
      'LEFT JOIN categories c ON p.categorie_id = c.id ' +
      'ORDER BY p.nom';
  end
  else
  begin
    // Recherche sur plusieurs champs
    FDQuery1.SQL.Text :=
      'SELECT p.*, c.nom AS categorie_nom ' +
      'FROM produits p ' +
      'LEFT JOIN categories c ON p.categorie_id = c.id ' +
      'WHERE p.reference LIKE :recherche OR p.nom LIKE :recherche OR p.description LIKE :recherche ' +
      'ORDER BY p.nom';

    FDQuery1.ParamByName('recherche').AsString := '%' + Recherche + '%';
  end;

  FDQuery1.Open;

  StatusBar1.SimpleText := Format('%d produits trouv√©s', [FDQuery1.RecordCount]);
end;

procedure TFormProduits.ButtonNouveauClick(Sender: TObject);
begin
  ModeAjout;
end;

procedure TFormProduits.ButtonModifierClick(Sender: TObject);
begin
  if FDQuery1.IsEmpty then
  begin
    ShowMessage('Veuillez s√©lectionner un produit √† modifier.');
    Exit;
  end;

  ModeModification(FDQuery1.FieldByName('id').AsInteger);
end;

procedure TFormProduits.ButtonSupprimerClick(Sender: TObject);
var
  ID: Integer;
  Query: TFDQuery;
begin
  if FDQuery1.IsEmpty then
  begin
    ShowMessage('Veuillez s√©lectionner un produit √† supprimer.');
    Exit;
  end;

  // R√©cup√©rer l'ID du produit s√©lectionn√©
  ID := FDQuery1.FieldByName('id').AsInteger;

  // Demander confirmation
  if MessageDlg(Format('√ätes-vous s√ªr de vouloir supprimer le produit "%s" ?',
     [FDQuery1.FieldByName('nom').AsString]),
     mtConfirmation, [mbYes, mbNo], 0) <> mrYes then
    Exit;

  // Ex√©cuter la suppression
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    Query.SQL.Text := 'DELETE FROM produits WHERE id = :id';
    Query.ParamByName('id').AsInteger := ID;

    Query.ExecSQL;

    if Query.RowsAffected > 0 then
    begin
      ShowMessage('Produit supprim√© avec succ√®s !');

      // Rafra√Æchir la liste
      ChargerProduits;
    end
    else
      ShowMessage('Erreur : Aucun produit n''a √©t√© supprim√©.');
  except
    on E: Exception do
      ShowMessage('Erreur lors de la suppression : ' + E.Message);
  finally
    Query.Free;
  end;
end;

procedure TFormProduits.DBGrid1DblClick(Sender: TObject);
begin
  if not FDQuery1.IsEmpty then
    ModeModification(FDQuery1.FieldByName('id').AsInteger);
end;

procedure TFormProduits.ButtonEnregistrerClick(Sender: TObject);
var
  Query: TFDQuery;
  CategorieID: Integer;
begin
  // Valider les donn√©es du formulaire
  if not ValidationFormulaire then
    Exit;

  // R√©cup√©rer l'ID de la cat√©gorie s√©lectionn√©e
  if ComboBoxCategorie.ItemIndex > 0 then
    CategorieID := Integer(ComboBoxCategorie.Items.Objects[ComboBoxCategorie.ItemIndex])
  else
    CategorieID := 0;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    if FModeEdition and (FProduitID > 0) then
    begin
      // Mode modification
      Query.SQL.Text :=
        'UPDATE produits SET ' +
        'reference = :reference, ' +
        'nom = :nom, ' +
        'description = :description, ' +
        'prix = :prix, ' +
        'stock = :stock, ' +
        'categorie_id = :categorie_id ' +
        'WHERE id = :id';

      Query.ParamByName('id').AsInteger := FProduitID;
    end
    else
    begin
      // Mode ajout
      Query.SQL.Text :=
        'INSERT INTO produits ' +
        '(reference, nom, description, prix, stock, categorie_id) ' +
        'VALUES (:reference, :nom, :description, :prix, :stock, :categorie_id)';
    end;

    // D√©finir les param√®tres communs
    Query.ParamByName('reference').AsString := Trim(EditReference.Text);
    Query.ParamByName('nom').AsString := Trim(EditNom.Text);
    Query.ParamByName('description').AsString := Trim(MemoDescription.Text);
    Query.ParamByName('prix').AsFloat := StrToFloatDef(EditPrix.Text, 0);
    Query.ParamByName('stock').AsInteger := StrToIntDef(EditStock.Text, 0);

    // G√©rer la cat√©gorie (potentiellement NULL)
    if CategorieID > 0 then
      Query.ParamByName('categorie_id').AsInteger := CategorieID
    else
      Query.ParamByName('categorie_id').Clear;

    // Ex√©cuter la requ√™te
    Query.ExecSQL;

    if FModeEdition and (FProduitID > 0) then
      ShowMessage('Produit modifi√© avec succ√®s !')
    else
      ShowMessage('Produit ajout√© avec succ√®s !');

    // Revenir au mode consultation
    ModeConsultation;

    // Rafra√Æchir la liste des produits
    ChargerProduits;
  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  finally
    Query.Free;
  end;
end;

procedure TFormProduits.ButtonAnnulerClick(Sender: TObject);
begin
  // Annuler les modifications et revenir au mode consultation
  ModeConsultation;
end;

procedure TFormProduits.ChargerProduit(ID: Integer);
var
  Query: TFDQuery;
  i: Integer;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    Query.SQL.Text := 'SELECT * FROM produits WHERE id = :id';
    Query.ParamByName('id').AsInteger := ID;
    Query.Open;

    if not Query.IsEmpty then
    begin
      // Remplir les champs du formulaire
      EditReference.Text := Query.FieldByName('reference').AsString;
      EditNom.Text := Query.FieldByName('nom').AsString;
      MemoDescription.Text := Query.FieldByName('description').AsString;
      EditPrix.Text := FormatFloat('0.00', Query.FieldByName('prix').AsFloat);
      EditStock.Text := Query.FieldByName('stock').AsString;

      // S√©lectionner la cat√©gorie dans la combobox
      ComboBoxCategorie.ItemIndex := 0; // Par d√©faut "(Aucune)"

      if not Query.FieldByName('categorie_id').IsNull then
      begin
        var CategorieID := Query.FieldByName('categorie_id').AsInteger;

        // Rechercher la cat√©gorie dans la liste
        for i := 0 to ComboBoxCategorie.Items.Count - 1 do
        begin
          if Integer(ComboBoxCategorie.Items.Objects[i]) = CategorieID then
          begin
            ComboBoxCategorie.ItemIndex := i;
            Break;
          end;
        end;
      end;

      // Stocker l'ID du produit pour la mise √† jour
      FProduitID := ID;
    end;
  finally
    Query.Free;
  end;
end;

procedure TFormProduits.EffacerFormulaire;
begin
  EditReference.Text := '';
  EditNom.Text := '';
  MemoDescription.Text := '';
  EditPrix.Text := '0.00';
  EditStock.Text := '0';
  ComboBoxCategorie.ItemIndex := 0; // "(Aucune)"

  FProduitID := 0;
end;

function TFormProduits.ValidationFormulaire: Boolean;
begin
  Result := False;

  // Validation du champ R√©f√©rence
  if Trim(EditReference.Text) = '' then
  begin
    ShowMessage('La r√©f√©rence du produit est obligatoire.');
    EditReference.SetFocus;
    Exit;
  end;

  // Validation du champ Nom
  if Trim(EditNom.Text) = '' then
  begin
    ShowMessage('Le nom du produit est obligatoire.');
    EditNom.SetFocus;
    Exit;
  end;

  // Validation du champ Prix
  if StrToFloatDef(EditPrix.Text, -1) < 0 then
  begin
    ShowMessage('Le prix doit √™tre un nombre positif.');
    EditPrix.SetFocus;
    Exit;
  end;

  // Validation du champ Stock
  if StrToIntDef(EditStock.Text, -1) < 0 then
  begin
    ShowMessage('Le stock doit √™tre un nombre entier positif.');
    EditStock.SetFocus;
    Exit;
  end;

  Result := True;
end;

procedure TFormProduits.ModeAjout;
begin
  // Pr√©parer le formulaire pour un nouvel enregistrement
  EffacerFormulaire;

  // Activer le mode √©dition
  FModeEdition := True;

  // Configurer l'interface
  PageControl1.ActivePage := TabSheetDetail;
  EditReference.Enabled := True;
  EditNom.Enabled := True;
  MemoDescription.Enabled := True;
  EditPrix.Enabled := True;
  EditStock.Enabled := True;
  ComboBoxCategorie.Enabled := True;

  ButtonEnregistrer.Visible := True;
  ButtonAnnuler.Visible := True;

  // Positionner le curseur
  EditReference.SetFocus;

  StatusBar1.SimpleText := 'Ajout d''un nouveau produit';
end;

procedure TFormProduits.ModeModification(ID: Integer);
begin
  // Charger les donn√©es du produit
  ChargerProduit(ID);

  // Activer le mode √©dition
  FModeEdition := True;

  // Configurer l'interface
  PageControl1.ActivePage := TabSheetDetail;
  EditReference.Enabled := True;
  EditNom.Enabled := True;
  MemoDescription.Enabled := True;
  EditPrix.Enabled := True;
  EditStock.Enabled := True;
  ComboBoxCategorie.Enabled := True;

  ButtonEnregistrer.Visible := True;
  ButtonAnnuler.Visible := True;

  // Positionner le curseur
  EditNom.SetFocus;

  StatusBar1.SimpleText := Format('Modification du produit ID=%d', [ID]);
end;

procedure TFormProduits.ModeConsultation;
begin
  // D√©sactiver le mode √©dition
  FModeEdition := False;

  // Configurer l'interface
  PageControl1.ActivePage := TabSheetListe;

  ButtonEnregistrer.Visible := False;
  ButtonAnnuler.Visible := False;

  StatusBar1.SimpleText := Format('%d produits trouv√©s', [FDQuery1.RecordCount]);
end;
```

## Optimisation des op√©rations CRUD

Maintenant que nous avons vu les bases des op√©rations CRUD, voici quelques conseils pour optimiser vos applications :

### 1. Utiliser les transactions

Les transactions garantissent l'int√©grit√© des donn√©es, surtout pour les op√©rations multiples :

```delphi
procedure TFormProduits.MettreAJourStockEtPrix(ID: Integer; NouveauStock: Integer; NouveauPrix: Double);
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // D√©marrer une transaction
    Query.Connection.StartTransaction;
    try
      // Mise √† jour du stock
      Query.SQL.Text := 'UPDATE produits SET stock = :stock WHERE id = :id';
      Query.ParamByName('stock').AsInteger := NouveauStock;
      Query.ParamByName('id').AsInteger := ID;
      Query.ExecSQL;

      // Mise √† jour du prix
      Query.SQL.Text := 'UPDATE produits SET prix = :prix WHERE id = :id';
      Query.ParamByName('prix').AsFloat := NouveauPrix;
      Query.ParamByName('id').AsInteger := ID;
      Query.ExecSQL;

      // Si tout s'est bien pass√©, valider la transaction
      Query.Connection.Commit;

      ShowMessage('Stock et prix mis √† jour avec succ√®s !');
    except
      on E: Exception do
      begin
        // En cas d'erreur, annuler toutes les modifications
        Query.Connection.Rollback;
        ShowMessage('Erreur lors de la mise √† jour : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;
```

### 2. Optimiser les requ√™tes pour de grandes quantit√©s de donn√©es

Pour les grandes quantit√©s de donn√©es, utilisez des techniques comme :

#### a. Chargement par lots (batching)

```delphi
procedure TFormProduits.ImporterProduits(const Fichier: string);
var
  Liste: TStringList;
  i, BatchSize, LotActuel: Integer;
  Query: TFDQuery;
begin
  Liste := TStringList.Create;
  try
    Liste.LoadFromFile(Fichier);

    if Liste.Count <= 1 then // V√©rifier s'il y a des donn√©es (en excluant l'en-t√™te)
      Exit;

    Query := TFDQuery.Create(nil);
    try
      Query.Connection := FDConnection1;
      Query.SQL.Text :=
        'INSERT INTO produits (reference, nom, prix, stock) ' +
        'VALUES (:reference, :nom, :prix, :stock)';

      // Configurer les options de mise en cache pour de meilleures performances
      Query.ResourceOptions.DirectExecute := False;

      // Cr√©er un dataset en mode batch pour l'insertion
      Query.Params.ArraySize := 0;

      BatchSize := 100; // Nombre d'enregistrements par lot
      LotActuel := 0;

      // D√©marrer une transaction
      Query.Connection.StartTransaction;
      try
        // Ignorer l'en-t√™te (premi√®re ligne)
        for i := 1 to Liste.Count - 1 do
        begin
          var Elements := Liste[i].Split([';']);

          if Length(Elements) >= 4 then
          begin
            // Augmenter la taille du lot si n√©cessaire
            if Query.Params.ArraySize <= LotActuel then
              Query.Params.ArraySize := Query.Params.ArraySize + BatchSize;

            // Remplir les param√®tres pour cet enregistrement
            Query.ParamByName('reference').AsStrings[LotActuel] := Elements[0];
            Query.ParamByName('nom').AsStrings[LotActuel] := Elements[1];
            Query.ParamByName('prix').AsFloats[LotActuel] := StrToFloatDef(Elements[2], 0);
            Query.ParamByName('stock').AsIntegers[LotActuel] := StrToIntDef(Elements[3], 0);

            Inc(LotActuel);

            // Si le lot est plein, ex√©cuter l'insertion
            if LotActuel >= BatchSize then
            begin
              Query.Execute(LotActuel, 0);
              LotActuel := 0;
            end;
          end;
        end;

        // Ex√©cuter le dernier lot s'il reste des enregistrements
        if LotActuel > 0 then
          Query.Execute(LotActuel, 0);

        // Valider la transaction
        Query.Connection.Commit;

        ShowMessage(Format('%d produits import√©s avec succ√®s !', [Liste.Count - 1]));
      except
        on E: Exception do
        begin
          Query.Connection.Rollback;
          ShowMessage('Erreur lors de l''importation : ' + E.Message);
        end;
      end;
    finally
      Query.Free;
    end;
  finally
    Liste.Free;
  end;
end;
```

#### b. Paginer les r√©sultats

```delphi
procedure TFormProduits.ChargerPageProduits(NumPage, ElementsParPage: Integer);
begin
  // Calculer l'offset pour la pagination
  var Offset := (NumPage - 1) * ElementsParPage;

  FDQuery1.Close;
  FDQuery1.SQL.Text :=
    'SELECT p.*, c.nom AS categorie_nom ' +
    'FROM produits p ' +
    'LEFT JOIN categories c ON p.categorie_id = c.id ' +
    'ORDER BY p.nom ' +
    'LIMIT :limit OFFSET :offset';

  FDQuery1.ParamByName('limit').AsInteger := ElementsParPage;
  FDQuery1.ParamByName('offset').AsInteger := Offset;

  FDQuery1.Open;

  // Mettre √† jour les informations de pagination
  StatusBar1.SimpleText := Format('Page %d - Affichage des produits %d √† %d',
    [NumPage, Offset + 1, Offset + FDQuery1.RecordCount]);
end;
```

#### c. Minimiser les donn√©es r√©cup√©r√©es

```delphi
procedure TFormProduits.ChargerListeMinimale;
begin
  FDQuery1.Close;

  // S√©lectionner uniquement les colonnes n√©cessaires pour la liste
  FDQuery1.SQL.Text :=
    'SELECT id, reference, nom, prix, stock ' +
    'FROM produits ' +
    'ORDER BY nom';

  FDQuery1.Open;
end;
```

### 3. R√©utiliser les objets de requ√™te

Pour de meilleures performances, r√©utilisez les objets de requ√™te plut√¥t que de les cr√©er et d√©truire fr√©quemment :

```delphi
// Ajouter une variable priv√©e √† la classe
private
  FQueryUtilitaire: TFDQuery;

// Initialiser dans FormCreate
procedure TFormProduits.FormCreate(Sender: TObject);
begin
  // Autres initialisations...

  // Cr√©er la requ√™te utilitaire une seule fois
  FQueryUtilitaire := TFDQuery.Create(Self);
  FQueryUtilitaire.Connection := FDConnection1;
end;

// Utiliser dans diff√©rentes m√©thodes
procedure TFormProduits.MettreAJourStock(ID, NouveauStock: Integer);
begin
  FQueryUtilitaire.Close;
  FQueryUtilitaire.SQL.Text := 'UPDATE produits SET stock = :stock WHERE id = :id';
  FQueryUtilitaire.ParamByName('stock').AsInteger := NouveauStock;
  FQueryUtilitaire.ParamByName('id').AsInteger := ID;
  FQueryUtilitaire.ExecSQL;
end;

// Lib√©rer dans FormDestroy
procedure TFormProduits.FormDestroy(Sender: TObject);
begin
  FQueryUtilitaire.Free;

  // Autres lib√©rations...
end;
```

### 4. G√©rer les erreurs de contraintes

Les erreurs de cl√© √©trang√®re et d'unicit√© sont courantes. Voici comment les g√©rer proprement :

```delphi
function TFormProduits.AjouterProduitSecurise(const Reference, Nom: string; Prix: Double): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // V√©rifier si la r√©f√©rence existe d√©j√†
    Query.SQL.Text := 'SELECT COUNT(*) FROM produits WHERE reference = :reference';
    Query.ParamByName('reference').AsString := Reference;
    Query.Open;

    if Query.Fields[0].AsInteger > 0 then
    begin
      ShowMessage('Un produit avec cette r√©f√©rence existe d√©j√†.');
      Exit;
    end;

    // Ins√©rer le produit
    try
      Query.SQL.Text :=
        'INSERT INTO produits (reference, nom, prix) ' +
        'VALUES (:reference, :nom, :prix)';

      Query.ParamByName('reference').AsString := Reference;
      Query.ParamByName('nom').AsString := Nom;
      Query.ParamByName('prix').AsFloat := Prix;

      Query.ExecSQL;

      Result := True;
    except
      on E: Exception do
      begin
        // Analyser l'erreur pour donner un message plus pr√©cis
        if Pos('Duplicate', E.Message) > 0 then
          ShowMessage('Un produit avec cette r√©f√©rence existe d√©j√†.')
        else if Pos('foreign key', E.Message) > 0 then
          ShowMessage('La cat√©gorie sp√©cifi√©e n''existe pas.')
        else
          ShowMessage('Erreur lors de l''ajout : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;
```

## R√©sum√© des bonnes pratiques pour les op√©rations CRUD

Pour terminer cette section, voici un r√©capitulatif des bonnes pratiques √† suivre :

1. **Toujours utiliser des requ√™tes param√©tr√©es** pour √©viter les injections SQL
2. **Encapsuler les op√©rations CRUD** dans des m√©thodes ou classes d√©di√©es
3. **Utiliser des transactions** pour les op√©rations qui modifient plusieurs tables ou enregistrements
4. **Valider les donn√©es** avant de les envoyer √† la base de donn√©es
5. **G√©rer les erreurs** sp√©cifiquement selon leur type
6. **Optimiser les requ√™tes** pour les grandes quantit√©s de donn√©es
7. **R√©utiliser les objets de requ√™te** pour de meilleures performances
8. **Limiter les donn√©es r√©cup√©r√©es** aux colonnes n√©cessaires
9. **Paginer les r√©sultats** pour les grandes tables
10. **Documenter** clairement les contraintes et d√©pendances entre tables

En suivant ces principes, vos applications seront plus robustes, plus performantes et plus faciles √† maintenir.

Dans la prochaine section, nous explorerons les transactions et l'int√©grit√© des donn√©es plus en d√©tail.

---

**√Ä suivre :** 8.5.3 Transactions et int√©grit√© des donn√©es

‚è≠Ô∏è [Transactions et int√©grit√© des donn√©es](/08-acces-aux-bases-de-donnees-mysql-mariadb/05.3-transactions-integrite-donnees.md)
