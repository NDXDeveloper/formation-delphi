üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.5.2 CRUD : Create, Read, Update, Delete

## Introduction

Maintenant que vous ma√Ætrisez les requ√™tes SQL et les param√®tres, il est temps de construire une **application CRUD compl√®te**. CRUD est l'acronyme des quatre op√©rations fondamentales de toute application de gestion de donn√©es : **Create** (Cr√©er), **Read** (Lire), **Update** (Mettre √† jour) et **Delete** (Supprimer).

Dans ce chapitre, nous allons cr√©er une application compl√®te de gestion de clients avec une interface utilisateur intuitive permettant d'effectuer toutes ces op√©rations.

## Qu'est-ce qu'une application CRUD ?

Une application CRUD est une interface qui permet de :

| Op√©ration | Description | Action utilisateur |
|-----------|-------------|-------------------|
| **Create** | Ajouter de nouveaux enregistrements | Cliquer sur "Nouveau", remplir un formulaire, sauvegarder |
| **Read** | Consulter et afficher les donn√©es | Voir la liste, rechercher, filtrer |
| **Update** | Modifier des enregistrements existants | S√©lectionner, modifier, sauvegarder |
| **Delete** | Supprimer des enregistrements | S√©lectionner, confirmer, supprimer |

**Exemples concrets :**
- Une liste de contacts
- Un catalogue de produits
- Un registre d'employ√©s
- Une biblioth√®que de documents

## Architecture de l'application

Nous allons cr√©er une application avec :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Gestion des Clients           [_][‚ñ°][X]‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  [Nouveau] [Modifier] [Supprimer]       ‚îÇ
‚îÇ  [Rafra√Æchir]     Recherche: [____] [üîç]‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ Grille des clients (DBGrid)         ‚îÇ ‚îÇ
‚îÇ ‚îÇ                                     ‚îÇ ‚îÇ
‚îÇ ‚îÇ ID | Nom    | Pr√©nom | Email        ‚îÇ ‚îÇ
‚îÇ ‚îÇ 1  | Dupont | Jean   | jean@...     ‚îÇ ‚îÇ
‚îÇ ‚îÇ 2  | Martin | Sophie | sophie@...   ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ D√©tails du client s√©lectionn√©           ‚îÇ
‚îÇ Nom:      [____________]                ‚îÇ
‚îÇ Pr√©nom:   [____________]                ‚îÇ
‚îÇ Email:    [____________]                ‚îÇ
‚îÇ T√©l:      [____________]                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Pr√©paration : Cr√©ation du projet

### √âtape 1 : Nouveau projet

1. Cr√©ez un nouveau projet VCL : **Fichier** ‚Üí **Nouveau** ‚Üí **Application VCL**
2. Sauvegardez :
   - Unit√© : `uFormGestionClients.pas`
   - Projet : `GestionClients.dproj`

### √âtape 2 : Configuration du formulaire

Propri√©t√©s du formulaire :
- `Name` : `FormGestionClients`
- `Caption` : `Gestion des Clients`
- `Width` : `800`
- `Height` : `600`
- `Position` : `poScreenCenter`

## Composants n√©cessaires

### Composants FireDAC (non-visuels)

Placez ces composants sur votre formulaire :

1. **TFDConnection**
   - `Name` : `FDConnection1`
   - Configurez la connexion MySQL comme vu pr√©c√©demment

2. **TFDQuery**
   - `Name` : `FDQueryClients`
   - `Connection` : `FDConnection1`

3. **TDataSource**
   - `Name` : `DataSourceClients`
   - `DataSet` : `FDQueryClients`

4. **TFDPhysMySQLDriverLink** et **TFDGUIxWaitCursor** (optionnels)

### Composants visuels

#### Barre d'outils (en haut)

Ajoutez un **TPanel** pour contenir les boutons :
- `Name` : `pnlToolbar`
- `Align` : `alTop`
- `Height` : `60`

Sur ce panel, placez des **TButton** :

1. `btnNouveau` : Caption = `Nouveau`
2. `btnModifier` : Caption = `Modifier`
3. `btnSupprimer` : Caption = `Supprimer`
4. `btnRafraichir` : Caption = `Rafra√Æchir`

Ajoutez aussi :
- Un **TEdit** (`editRecherche`) pour la recherche
- Un **TButton** (`btnRechercher`) avec Caption = `Rechercher`

#### Grille de donn√©es (centre)

Ajoutez un **TDBGrid** :
- `Name` : `DBGridClients`
- `Align` : `alClient`
- `DataSource` : `DataSourceClients`
- `Options` ‚Üí `dgRowSelect` : `True` (pour s√©lectionner toute la ligne)
- `Options` ‚Üí `dgTitles` : `True` (pour afficher les en-t√™tes)

#### Panneau de d√©tails (bas)

Ajoutez un **TPanel** :
- `Name` : `pnlDetails`
- `Align` : `alBottom`
- `Height` : `150`

Sur ce panel, placez des **TLabel** et **TDBEdit** :

```
Label1 : Caption = 'Nom :'          DBEdit1 : Name = editNom
Label2 : Caption = 'Pr√©nom :'       DBEdit2 : Name = editPrenom
Label3 : Caption = 'Email :'        DBEdit3 : Name = editEmail
Label4 : Caption = 'T√©l√©phone :'    DBEdit4 : Name = editTelephone
```

**Important :** Pour chaque **TDBEdit** :
- `DataSource` : `DataSourceClients`
- `DataField` : s√©lectionnez le champ correspondant (nom, prenom, email, telephone)

## Impl√©mentation du READ (Lecture)

### Charger les donn√©es au d√©marrage

Dans l'√©v√©nement `OnCreate` du formulaire :

```pascal
procedure TFormGestionClients.FormCreate(Sender: TObject);
begin
  // Connecter √† la base de donn√©es
  try
    FDConnection1.Connected := True;
    ChargerClients;
  except
    on E: Exception do
    begin
      ShowMessage('Erreur de connexion : ' + E.Message);
      Application.Terminate;
    end;
  end;
end;
```

### M√©thode ChargerClients

```pascal
procedure TFormGestionClients.ChargerClients;
begin
  FDQueryClients.Close;
  FDQueryClients.SQL.Text :=
    'SELECT id, nom, prenom, email, telephone, date_inscription, actif ' +
    'FROM clients ' +
    'WHERE actif = TRUE ' +
    'ORDER BY nom, prenom';

  try
    FDQueryClients.Open;

    // Optionnel : personnaliser les colonnes de la grille
    DBGridClients.Columns[0].Width := 40;   // ID
    DBGridClients.Columns[1].Width := 120;  // Nom
    DBGridClients.Columns[2].Width := 120;  // Pr√©nom
    DBGridClients.Columns[3].Width := 180;  // Email
    DBGridClients.Columns[4].Width := 100;  // T√©l√©phone

  except
    on E: Exception do
      ShowMessage('Erreur lors du chargement : ' + E.Message);
  end;
end;
```

### Bouton Rafra√Æchir

```pascal
procedure TFormGestionClients.btnRafraichirClick(Sender: TObject);
begin
  ChargerClients;
  ShowMessage('Donn√©es actualis√©es');
end;
```

### Fonction de recherche

```pascal
procedure TFormGestionClients.btnRechercherClick(Sender: TObject);
var
  Recherche: string;
begin
  Recherche := Trim(editRecherche.Text);

  FDQueryClients.Close;

  if Recherche = '' then
  begin
    // Si la recherche est vide, afficher tous les clients
    ChargerClients;
  end
  else
  begin
    // Rechercher dans nom, pr√©nom et email
    FDQueryClients.SQL.Text :=
      'SELECT id, nom, prenom, email, telephone, date_inscription, actif ' +
      'FROM clients ' +
      'WHERE actif = TRUE ' +
      '  AND (nom LIKE :Recherche ' +
      '       OR prenom LIKE :Recherche ' +
      '       OR email LIKE :Recherche) ' +
      'ORDER BY nom, prenom';

    FDQueryClients.ParamByName('Recherche').AsString := '%' + Recherche + '%';
  end;

  try
    FDQueryClients.Open;
  except
    on E: Exception do
      ShowMessage('Erreur de recherche : ' + E.Message);
  end;
end;
```

**Astuce :** Pour rechercher en temps r√©el √† chaque frappe, utilisez l'√©v√©nement `OnChange` du `editRecherche` au lieu d'un bouton.

## Impl√©mentation du CREATE (Cr√©ation)

### Formulaire de saisie

Cr√©ez un nouveau formulaire pour la saisie (ou utilisez une bo√Æte de dialogue).

**Option 1 : Nouveau formulaire d√©di√©**

1. **Fichier** ‚Üí **Nouveau** ‚Üí **Formulaire VCL**
2. Nommez-le : `uFormEditClient.pas`
3. Formulaire : `FormEditClient`

Ajoutez sur ce formulaire :
- Des **TLabel** et **TEdit** pour chaque champ
- Deux **TButton** : `btnValider` et `btnAnnuler`

```pascal
unit uFormEditClient;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,
  Vcl.StdCtrls;

type
  TFormEditClient = class(TForm)
    Label1: TLabel;
    editNom: TEdit;
    Label2: TLabel;
    editPrenom: TEdit;
    Label3: TLabel;
    editEmail: TEdit;
    Label4: TLabel;
    editTelephone: TEdit;
    btnValider: TButton;
    btnAnnuler: TButton;
    procedure btnAnnulerClick(Sender: TObject);
    procedure btnValiderClick(Sender: TObject);
  private
    { D√©clarations priv√©es }
  public
    { D√©clarations publiques }
    // Propri√©t√©s publiques pour r√©cup√©rer les valeurs
    function GetNom: string;
    function GetPrenom: string;
    function GetEmail: string;
    function GetTelephone: string;

    procedure SetNom(const Value: string);
    procedure SetPrenom(const Value: string);
    procedure SetEmail(const Value: string);
    procedure SetTelephone(const Value: string);
  end;

var
  FormEditClient: TFormEditClient;

implementation

{$R *.dfm}

procedure TFormEditClient.btnAnnulerClick(Sender: TObject);
begin
  ModalResult := mrCancel;
end;

procedure TFormEditClient.btnValiderClick(Sender: TObject);
begin
  // Validation des champs
  if Trim(editNom.Text) = '' then
  begin
    ShowMessage('Le nom est obligatoire');
    editNom.SetFocus;
    Exit;
  end;

  if Trim(editPrenom.Text) = '' then
  begin
    ShowMessage('Le pr√©nom est obligatoire');
    editPrenom.SetFocus;
    Exit;
  end;

  if Trim(editEmail.Text) = '' then
  begin
    ShowMessage('L''email est obligatoire');
    editEmail.SetFocus;
    Exit;
  end;

  // Validation basique de l'email
  if Pos('@', editEmail.Text) = 0 then
  begin
    ShowMessage('Email invalide');
    editEmail.SetFocus;
    Exit;
  end;

  ModalResult := mrOk;
end;

// Getters et Setters
function TFormEditClient.GetNom: string;
begin
  Result := Trim(editNom.Text);
end;

function TFormEditClient.GetPrenom: string;
begin
  Result := Trim(editPrenom.Text);
end;

function TFormEditClient.GetEmail: string;
begin
  Result := Trim(editEmail.Text);
end;

function TFormEditClient.GetTelephone: string;
begin
  Result := Trim(editTelephone.Text);
end;

procedure TFormEditClient.SetNom(const Value: string);
begin
  editNom.Text := Value;
end;

procedure TFormEditClient.SetPrenom(const Value: string);
begin
  editPrenom.Text := Value;
end;

procedure TFormEditClient.SetEmail(const Value: string);
begin
  editEmail.Text := Value;
end;

procedure TFormEditClient.SetTelephone(const Value: string);
begin
  editTelephone.Text := Value;
end;

end.
```

### Bouton Nouveau - Insertion

Dans le formulaire principal :

```pascal
procedure TFormGestionClients.btnNouveauClick(Sender: TObject);
var
  FormEdit: TFormEditClient;
  Query: TFDQuery;
begin
  FormEdit := TFormEditClient.Create(nil);
  try
    FormEdit.Caption := 'Nouveau client';

    // Afficher le formulaire modal
    if FormEdit.ShowModal = mrOk then
    begin
      // Cr√©er une requ√™te temporaire pour l'insertion
      Query := TFDQuery.Create(nil);
      try
        Query.Connection := FDConnection1;
        Query.SQL.Text :=
          'INSERT INTO clients (nom, prenom, email, telephone, date_inscription) ' +
          'VALUES (:Nom, :Prenom, :Email, :Tel, :DateInscription)';

        // Assigner les param√®tres
        Query.ParamByName('Nom').AsString := FormEdit.GetNom;
        Query.ParamByName('Prenom').AsString := FormEdit.GetPrenom;
        Query.ParamByName('Email').AsString := FormEdit.GetEmail;
        Query.ParamByName('Tel').AsString := FormEdit.GetTelephone;
        Query.ParamByName('DateInscription').AsDate := Date;

        try
          // Ex√©cuter l'insertion
          Query.ExecSQL;
          ShowMessage('Client ajout√© avec succ√®s');

          // Recharger la liste
          ChargerClients;
        except
          on E: Exception do
          begin
            if Pos('Duplicate entry', E.Message) > 0 then
              ShowMessage('Cet email existe d√©j√†')
            else
              ShowMessage('Erreur lors de l''ajout : ' + E.Message);
          end;
        end;

      finally
        Query.Free;
      end;
    end;

  finally
    FormEdit.Free;
  end;
end;
```

**Option 2 : Saisie directe dans la grille (plus simple)**

Vous pouvez aussi utiliser les capacit√©s d'√©dition int√©gr√©es de TDBGrid :

```pascal
procedure TFormGestionClients.btnNouveauClick(Sender: TObject);
begin
  // Passer en mode insertion
  FDQueryClients.Append;

  // Le focus se place automatiquement dans la grille
  // L'utilisateur peut saisir directement
end;
```

Mais vous devrez alors g√©rer la sauvegarde avec un bouton "Enregistrer" s√©par√©.

## Impl√©mentation du UPDATE (Modification)

### Bouton Modifier

```pascal
procedure TFormGestionClients.btnModifierClick(Sender: TObject);
var
  FormEdit: TFormEditClient;
  Query: TFDQuery;
  ClientID: Integer;
begin
  // V√©rifier qu'un client est s√©lectionn√©
  if FDQueryClients.IsEmpty then
  begin
    ShowMessage('Veuillez s√©lectionner un client √† modifier');
    Exit;
  end;

  // R√©cup√©rer l'ID du client s√©lectionn√©
  ClientID := FDQueryClients.FieldByName('id').AsInteger;

  FormEdit := TFormEditClient.Create(nil);
  try
    FormEdit.Caption := 'Modifier le client';

    // Pr√©-remplir le formulaire avec les donn√©es actuelles
    FormEdit.SetNom(FDQueryClients.FieldByName('nom').AsString);
    FormEdit.SetPrenom(FDQueryClients.FieldByName('prenom').AsString);
    FormEdit.SetEmail(FDQueryClients.FieldByName('email').AsString);
    FormEdit.SetTelephone(FDQueryClients.FieldByName('telephone').AsString);

    // Afficher le formulaire modal
    if FormEdit.ShowModal = mrOk then
    begin
      Query := TFDQuery.Create(nil);
      try
        Query.Connection := FDConnection1;
        Query.SQL.Text :=
          'UPDATE clients SET ' +
          '  nom = :Nom, ' +
          '  prenom = :Prenom, ' +
          '  email = :Email, ' +
          '  telephone = :Tel ' +
          'WHERE id = :ID';

        // Assigner les param√®tres
        Query.ParamByName('Nom').AsString := FormEdit.GetNom;
        Query.ParamByName('Prenom').AsString := FormEdit.GetPrenom;
        Query.ParamByName('Email').AsString := FormEdit.GetEmail;
        Query.ParamByName('Tel').AsString := FormEdit.GetTelephone;
        Query.ParamByName('ID').AsInteger := ClientID;

        try
          Query.ExecSQL;

          if Query.RowsAffected > 0 then
          begin
            ShowMessage('Client modifi√© avec succ√®s');
            ChargerClients;
          end
          else
            ShowMessage('Erreur : client non trouv√©');

        except
          on E: Exception do
            ShowMessage('Erreur lors de la modification : ' + E.Message);
        end;

      finally
        Query.Free;
      end;
    end;

  finally
    FormEdit.Free;
  end;
end;
```

### Modification directe avec Edit/Post

M√©thode alternative plus simple :

```pascal
procedure TFormGestionClients.btnModifierClick(Sender: TObject);
begin
  if FDQueryClients.IsEmpty then
  begin
    ShowMessage('Veuillez s√©lectionner un client');
    Exit;
  end;

  // Passer en mode √©dition
  FDQueryClients.Edit;

  // Les DBEdit sont maintenant modifiables
  // L'utilisateur peut modifier directement

  // Il faudra un bouton "Enregistrer" pour appeler :
  // FDQueryClients.Post;
end;

procedure TFormGestionClients.btnEnregistrerClick(Sender: TObject);
begin
  try
    // Valider et enregistrer les modifications
    FDQueryClients.Post;
    ShowMessage('Modifications enregistr√©es');
  except
    on E: Exception do
    begin
      FDQueryClients.Cancel;  // Annuler les modifications
      ShowMessage('Erreur : ' + E.Message);
    end;
  end;
end;
```

## Impl√©mentation du DELETE (Suppression)

### Bouton Supprimer

```pascal
procedure TFormGestionClients.btnSupprimerClick(Sender: TObject);
var
  ClientID: Integer;
  ClientNom, ClientPrenom: string;
  Query: TFDQuery;
begin
  // V√©rifier qu'un client est s√©lectionn√©
  if FDQueryClients.IsEmpty then
  begin
    ShowMessage('Veuillez s√©lectionner un client √† supprimer');
    Exit;
  end;

  // R√©cup√©rer les informations du client
  ClientID := FDQueryClients.FieldByName('id').AsInteger;
  ClientNom := FDQueryClients.FieldByName('nom').AsString;
  ClientPrenom := FDQueryClients.FieldByName('prenom').AsString;

  // Demander confirmation
  if MessageDlg(
    '√ätes-vous s√ªr de vouloir supprimer le client ' +
    ClientPrenom + ' ' + ClientNom + ' ?',
    mtConfirmation,
    [mbYes, mbNo],
    0
  ) = mrYes then
  begin
    Query := TFDQuery.Create(nil);
    try
      Query.Connection := FDConnection1;

      // Option 1 : Suppression physique (d√©finitive)
      Query.SQL.Text := 'DELETE FROM clients WHERE id = :ID';
      Query.ParamByName('ID').AsInteger := ClientID;

      try
        Query.ExecSQL;

        if Query.RowsAffected > 0 then
        begin
          ShowMessage('Client supprim√©');
          ChargerClients;
        end
        else
          ShowMessage('Erreur : client non trouv√©');

      except
        on E: Exception do
          ShowMessage('Erreur lors de la suppression : ' + E.Message);
      end;

    finally
      Query.Free;
    end;
  end;
end;
```

### Suppression logique (recommand√©e)

Plut√¥t que supprimer physiquement, marquez comme inactif :

```pascal
procedure TFormGestionClients.btnSupprimerClick(Sender: TObject);
var
  ClientID: Integer;
  Query: TFDQuery;
begin
  if FDQueryClients.IsEmpty then
  begin
    ShowMessage('Veuillez s√©lectionner un client √† supprimer');
    Exit;
  end;

  ClientID := FDQueryClients.FieldByName('id').AsInteger;

  if MessageDlg(
    'Voulez-vous d√©sactiver ce client ?',
    mtConfirmation,
    [mbYes, mbNo],
    0
  ) = mrYes then
  begin
    Query := TFDQuery.Create(nil);
    try
      Query.Connection := FDConnection1;

      // Suppression logique : marquer comme inactif
      Query.SQL.Text := 'UPDATE clients SET actif = FALSE WHERE id = :ID';
      Query.ParamByName('ID').AsInteger := ClientID;

      try
        Query.ExecSQL;
        ShowMessage('Client d√©sactiv√©');
        ChargerClients;  // Recharge la liste (le client dispara√Æt)
      except
        on E: Exception do
          ShowMessage('Erreur : ' + E.Message);
      end;

    finally
      Query.Free;
    end;
  end;
end;
```

**Avantages de la suppression logique :**
- Conservation de l'historique
- Possibilit√© de restauration
- Pas de probl√®mes d'int√©grit√© r√©f√©rentielle

## Gestion des √©tats des boutons

Activez/d√©sactivez les boutons selon le contexte :

```pascal
procedure TFormGestionClients.DBGridClientsCellClick(Column: TColumn);
begin
  // Activer les boutons quand un client est s√©lectionn√©
  btnModifier.Enabled := not FDQueryClients.IsEmpty;
  btnSupprimer.Enabled := not FDQueryClients.IsEmpty;
end;

procedure TFormGestionClients.ChargerClients;
begin
  // ... code de chargement ...

  // Mettre √† jour l'√©tat des boutons
  btnModifier.Enabled := not FDQueryClients.IsEmpty;
  btnSupprimer.Enabled := not FDQueryClients.IsEmpty;
end;
```

## Validation des donn√©es

### Fonction de validation globale

```pascal
function TFormGestionClients.ValiderClient(const Nom, Prenom, Email: string): Boolean;
begin
  Result := False;

  // Nom obligatoire
  if Trim(Nom) = '' then
  begin
    ShowMessage('Le nom est obligatoire');
    Exit;
  end;

  // Pr√©nom obligatoire
  if Trim(Prenom) = '' then
  begin
    ShowMessage('Le pr√©nom est obligatoire');
    Exit;
  end;

  // Email obligatoire et valide
  if Trim(Email) = '' then
  begin
    ShowMessage('L''email est obligatoire');
    Exit;
  end;

  if (Pos('@', Email) = 0) or (Pos('.', Email) = 0) then
  begin
    ShowMessage('Format d''email invalide');
    Exit;
  end;

  Result := True;
end;
```

### Validation de l'unicit√© de l'email

```pascal
function TFormGestionClients.EmailDejaUtilise(const Email: string; ExcluID: Integer = -1): Boolean;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    if ExcluID = -1 then
      // Pour cr√©ation : v√©rifier si l'email existe
      Query.SQL.Text := 'SELECT COUNT(*) AS nb FROM clients WHERE email = :Email'
    else
      // Pour modification : exclure le client en cours
      Query.SQL.Text :=
        'SELECT COUNT(*) AS nb FROM clients WHERE email = :Email AND id <> :ID';

    Query.ParamByName('Email').AsString := Email;

    if ExcluID <> -1 then
      Query.ParamByName('ID').AsInteger := ExcluID;

    Query.Open;
    Result := Query.FieldByName('nb').AsInteger > 0;
    Query.Close;

  finally
    Query.Free;
  end;
end;
```

Utilisation dans l'ajout :

```pascal
if EmailDejaUtilise(FormEdit.GetEmail) then
begin
  ShowMessage('Cet email est d√©j√† utilis√© par un autre client');
  Exit;
end;
```

Utilisation dans la modification :

```pascal
if EmailDejaUtilise(FormEdit.GetEmail, ClientID) then
begin
  ShowMessage('Cet email est d√©j√† utilis√©');
  Exit;
end;
```

## Am√©lioration : Utilisation d'un DataModule

Pour une meilleure organisation, cr√©ez un **DataModule** :

### Cr√©er le DataModule

1. **Fichier** ‚Üí **Nouveau** ‚Üí **Autre** ‚Üí **DataModule**
2. Nommez-le : `dmDatabase` (Data Module Database)

### D√©placer les composants

D√©placez tous les composants FireDAC du formulaire vers le DataModule :
- `FDConnection1`
- `FDQueryClients`
- `FDPhysMySQLDriverLink`
- etc.

### Avantages du DataModule

- **S√©paration des pr√©occupations** : logique de donn√©es s√©par√©e de l'interface
- **R√©utilisation** : plusieurs formulaires peuvent utiliser le m√™me DataModule
- **Organisation** : code plus propre et maintenable

### Utilisation

Dans le formulaire :

```pascal
unit uFormGestionClients;

interface

uses
  // ...
  dmDatabase;  // Ajouter le DataModule dans uses

implementation

procedure TFormGestionClients.FormCreate(Sender: TObject);
begin
  // Acc√©der au DataModule
  DataModule1.FDConnection1.Connected := True;
  ChargerClients;
end;

procedure TFormGestionClients.ChargerClients;
begin
  with DataModule1.FDQueryClients do
  begin
    Close;
    SQL.Text := 'SELECT * FROM clients WHERE actif = TRUE ORDER BY nom';
    Open;
  end;
end;
```

## Gestion des transactions

Pour des op√©rations complexes, utilisez les transactions :

```pascal
procedure TFormGestionClients.OperationComplexe;
begin
  FDConnection1.StartTransaction;
  try
    // Op√©ration 1
    Query1.ExecSQL;

    // Op√©ration 2
    Query2.ExecSQL;

    // Op√©ration 3
    Query3.ExecSQL;

    // Tout a r√©ussi : valider
    FDConnection1.Commit;
    ShowMessage('Op√©rations r√©ussies');

  except
    on E: Exception do
    begin
      // En cas d'erreur : annuler TOUTES les op√©rations
      FDConnection1.Rollback;
      ShowMessage('Erreur, toutes les op√©rations ont √©t√© annul√©es : ' + E.Message);
    end;
  end;
end;
```

**Exemple concret : Transfert entre comptes**

```pascal
procedure TransfererArgent(CompteSource, CompteDest: Integer; Montant: Currency);
begin
  FDConnection1.StartTransaction;
  try
    // D√©biter le compte source
    QueryDebit.SQL.Text := 'UPDATE comptes SET solde = solde - :Montant WHERE id = :ID';
    QueryDebit.ParamByName('Montant').AsCurrency := Montant;
    QueryDebit.ParamByName('ID').AsInteger := CompteSource;
    QueryDebit.ExecSQL;

    // Cr√©diter le compte destination
    QueryCredit.SQL.Text := 'UPDATE comptes SET solde = solde + :Montant WHERE id = :ID';
    QueryCredit.ParamByName('Montant').AsCurrency := Montant;
    QueryCredit.ParamByName('ID').AsInteger := CompteDest;
    QueryCredit.ExecSQL;

    // Tout est OK : valider
    FDConnection1.Commit;
    ShowMessage('Transfert r√©ussi');
  except
    // Erreur : tout annuler
    FDConnection1.Rollback;
    ShowMessage('Transfert annul√©');
  end;
end;
```

## Optimisations et bonnes pratiques

### 1. Utiliser CachedUpdates pour les modifications en lot

```pascal
// Activer le cache des modifications
FDQueryClients.CachedUpdates := True;

// Faire plusieurs modifications
FDQueryClients.First;
while not FDQueryClients.Eof do
begin
  FDQueryClients.Edit;
  FDQueryClients.FieldByName('statut').AsString := 'trait√©';
  FDQueryClients.Post;
  FDQueryClients.Next;
end;

// Appliquer toutes les modifications en une seule fois
FDQueryClients.ApplyUpdates;
FDQueryClients.CommitUpdates;
```

### 2. Fermer les requ√™tes quand elles ne sont pas utilis√©es

```pascal
procedure TFormGestionClients.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  // Fermer tous les datasets
  FDQueryClients.Close;

  // Fermer la connexion
  FDConnection1.Connected := False;
end;
```

### 3. G√©rer les valeurs NULL

```pascal
// V√©rifier si un champ est NULL
if FDQueryClients.FieldByName('telephone').IsNull then
  ShowMessage('Pas de t√©l√©phone')
else
  Telephone := FDQueryClients.FieldByName('telephone').AsString;

// Assigner NULL √† un param√®tre
Query.ParamByName('telephone').Clear;  // Ou .Value := Null;
```

### 4. Afficher un message pendant le chargement

```pascal
procedure TFormGestionClients.ChargerClients;
begin
  Screen.Cursor := crHourGlass;  // Curseur sablier
  try
    FDQueryClients.Close;
    FDQueryClients.SQL.Text := 'SELECT * FROM clients ORDER BY nom';
    FDQueryClients.Open;
  finally
    Screen.Cursor := crDefault;  // Curseur normal
  end;
end;
```

### 5. Pagination pour grandes tables

```pascal
procedure TFormGestionClients.ChargerClientsPage(PageNumber, PageSize: Integer);
var
  Offset: Integer;
begin
  Offset := (PageNumber - 1) * PageSize;

  FDQueryClients.SQL.Text :=
    'SELECT * FROM clients ' +
    'ORDER BY nom ' +
    'LIMIT :PageSize OFFSET :Offset';

  FDQueryClients.ParamByName('PageSize').AsInteger := PageSize;
  FDQueryClients.ParamByName('Offset').AsInteger := Offset;
  FDQueryClients.Open;
end;

// Exemple : charger la page 1 avec 50 enregistrements
ChargerClientsPage(1, 50);
```

## Gestion des erreurs globale

Centralisez la gestion des erreurs :

```pascal
procedure TFormGestionClients.GererErreurSQL(const Operation: string; E: Exception);
begin
  if Pos('Duplicate entry', E.Message) > 0 then
    ShowMessage('Cette valeur existe d√©j√† dans la base')
  else if Pos('foreign key constraint', E.Message) > 0 then
    ShowMessage('Impossible de supprimer : des donn√©es li√©es existent')
  else if Pos('Lost connection', E.Message) > 0 then
    ShowMessage('Connexion perdue avec la base de donn√©es')
  else
    ShowMessage('Erreur lors de ' + Operation + ' : ' + E.Message);

  // Logger l'erreur dans un fichier
  LogError(Operation + ': ' + E.Message);
end;

// Utilisation
try
  Query.ExecSQL;
except
  on E: Exception do
    GererErreurSQL('l''ajout du client', E);
end;
```

## Export des donn√©es

Ajouter une fonction d'export :

```pascal
procedure TFormGestionClients.btnExporterClick(Sender: TObject);
var
  SaveDialog: TSaveDialog;
  Fichier: TextFile;
begin
  SaveDialog := TSaveDialog.Create(nil);
  try
    SaveDialog.Filter := 'Fichiers CSV|*.csv';
    SaveDialog.DefaultExt := 'csv';

    if SaveDialog.Execute then
    begin
      AssignFile(Fichier, SaveDialog.FileName);
      Rewrite(Fichier);
      try
        // En-t√™tes
        WriteLn(Fichier, 'ID;Nom;Pr√©nom;Email;T√©l√©phone');

        // Donn√©es
        FDQueryClients.First;
        while not FDQueryClients.Eof do
        begin
          WriteLn(Fichier,
            FDQueryClients['id'] + ';' +
            FDQueryClients['nom'] + ';' +
            FDQueryClients['prenom'] + ';' +
            FDQueryClients['email'] + ';' +
            FDQueryClients['telephone']
          );
          FDQueryClients.Next;
        end;

        ShowMessage('Export r√©ussi');
      finally
        CloseFile(Fichier);
      end;
    end;
  finally
    SaveDialog.Free;
  end;
end;
```

## R√©sum√© des op√©rations CRUD

| Op√©ration | SQL | M√©thode FireDAC | Code cl√© |
|-----------|-----|-----------------|----------|
| **Create** | INSERT | `ExecSQL` | `Query.ExecSQL` |
| **Read** | SELECT | `Open` | `Query.Open` |
| **Update** | UPDATE | `ExecSQL` | `Query.ExecSQL` |
| **Delete** | DELETE | `ExecSQL` | `Query.ExecSQL` |

## Checklist d'une application CRUD compl√®te

‚úÖ **Interface utilisateur**
- Grille pour afficher les donn√©es
- Boutons pour chaque op√©ration CRUD
- Formulaire de saisie/√©dition
- Recherche et filtres

‚úÖ **Fonctionnalit√©s**
- Chargement des donn√©es au d√©marrage
- Rafra√Æchissement manuel
- Validation des donn√©es
- Messages de confirmation
- Gestion des erreurs

‚úÖ **S√©curit√©**
- Requ√™tes param√©tr√©es
- Validation c√¥t√© client
- Confirmation avant suppression
- Gestion des doublons

‚úÖ **Performance**
- Fermeture des requ√™tes apr√®s usage
- Utilisation efficace de la connexion
- Pagination si n√©cessaire

‚úÖ **Maintenabilit√©**
- Code organis√© en m√©thodes
- Utilisation d'un DataModule
- Gestion centralis√©e des erreurs
- Commentaires dans le code

## Prochaines √©tapes

Vous savez maintenant cr√©er une application CRUD compl√®te ! Dans les sections suivantes, nous verrons :

1. Comment utiliser des transactions pour des op√©rations complexes
2. Comment lier des donn√©es visuellement avec des grilles et des contr√¥les
3. Comment cr√©er un mod√®le en couches pour une meilleure architecture
4. Comment optimiser les performances avec FireDAC

Vous avez maintenant les bases solides pour cr√©er des applications de gestion de donn√©es professionnelles avec Delphi et MySQL/MariaDB !

‚è≠Ô∏è [Transactions et int√©grit√© des donn√©es](/08-acces-aux-bases-de-donnees-mysql-mariadb/05.3-transactions-integrite-donnees.md)
