🔝 Retour au [Sommaire](/SOMMAIRE.md)

# 8.5.2 CRUD : Create, Read, Update, Delete

## Introduction

Maintenant que vous maîtrisez les requêtes SQL et les paramètres, il est temps de construire une **application CRUD complète**. CRUD est l'acronyme des quatre opérations fondamentales de toute application de gestion de données : **Create** (Créer), **Read** (Lire), **Update** (Mettre à jour) et **Delete** (Supprimer).

Dans ce chapitre, nous allons créer une application complète de gestion de clients avec une interface utilisateur intuitive permettant d'effectuer toutes ces opérations.

## Qu'est-ce qu'une application CRUD ?

Une application CRUD est une interface qui permet de :

| Opération | Description | Action utilisateur |
|-----------|-------------|-------------------|
| **Create** | Ajouter de nouveaux enregistrements | Cliquer sur "Nouveau", remplir un formulaire, sauvegarder |
| **Read** | Consulter et afficher les données | Voir la liste, rechercher, filtrer |
| **Update** | Modifier des enregistrements existants | Sélectionner, modifier, sauvegarder |
| **Delete** | Supprimer des enregistrements | Sélectionner, confirmer, supprimer |

**Exemples concrets :**
- Une liste de contacts
- Un catalogue de produits
- Un registre d'employés
- Une bibliothèque de documents

## Architecture de l'application

Nous allons créer une application avec :

```
┌─────────────────────────────────────────┐
│  Gestion des Clients           [_][□][X]│
├─────────────────────────────────────────┤
│  [Nouveau] [Modifier] [Supprimer]       │
│  [Rafraîchir]     Recherche: [____] [🔍]│
├─────────────────────────────────────────┤
│ ┌─────────────────────────────────────┐ │
│ │ Grille des clients (DBGrid)         │ │
│ │                                     │ │
│ │ ID | Nom    | Prénom | Email        │ │
│ │ 1  | Dupont | Jean   | jean@...     │ │
│ │ 2  | Martin | Sophie | sophie@...   │ │
│ └─────────────────────────────────────┘ │
├─────────────────────────────────────────┤
│ Détails du client sélectionné           │
│ Nom:      [____________]                │
│ Prénom:   [____________]                │
│ Email:    [____________]                │
│ Tél:      [____________]                │
└─────────────────────────────────────────┘
```

## Préparation : Création du projet

### Étape 1 : Nouveau projet

1. Créez un nouveau projet VCL : **Fichier** → **Nouveau** → **Application VCL**
2. Sauvegardez :
   - Unité : `uFormGestionClients.pas`
   - Projet : `GestionClients.dproj`

### Étape 2 : Configuration du formulaire

Propriétés du formulaire :
- `Name` : `FormGestionClients`
- `Caption` : `Gestion des Clients`
- `Width` : `800`
- `Height` : `600`
- `Position` : `poScreenCenter`

## Composants nécessaires

### Composants FireDAC (non-visuels)

Placez ces composants sur votre formulaire :

1. **TFDConnection**
   - `Name` : `FDConnection1`
   - Configurez la connexion MySQL comme vu précédemment

2. **TFDQuery**
   - `Name` : `FDQueryClients`
   - `Connection` : `FDConnection1`

3. **TDataSource**
   - `Name` : `DataSourceClients`
   - `DataSet` : `FDQueryClients`

4. **TFDPhysMySQLDriverLink** et **TFDGUIxWaitCursor** (optionnels)

### Composants visuels

#### Barre d'outils (en haut)

Ajoutez un **TPanel** pour contenir les boutons :
- `Name` : `pnlToolbar`
- `Align` : `alTop`
- `Height` : `60`

Sur ce panel, placez des **TButton** :

1. `btnNouveau` : Caption = `Nouveau`
2. `btnModifier` : Caption = `Modifier`
3. `btnSupprimer` : Caption = `Supprimer`
4. `btnRafraichir` : Caption = `Rafraîchir`

Ajoutez aussi :
- Un **TEdit** (`editRecherche`) pour la recherche
- Un **TButton** (`btnRechercher`) avec Caption = `Rechercher`

#### Grille de données (centre)

Ajoutez un **TDBGrid** :
- `Name` : `DBGridClients`
- `Align` : `alClient`
- `DataSource` : `DataSourceClients`
- `Options` → `dgRowSelect` : `True` (pour sélectionner toute la ligne)
- `Options` → `dgTitles` : `True` (pour afficher les en-têtes)

#### Panneau de détails (bas)

Ajoutez un **TPanel** :
- `Name` : `pnlDetails`
- `Align` : `alBottom`
- `Height` : `150`

Sur ce panel, placez des **TLabel** et **TDBEdit** :

```
Label1 : Caption = 'Nom :'          DBEdit1 : Name = editNom
Label2 : Caption = 'Prénom :'       DBEdit2 : Name = editPrenom
Label3 : Caption = 'Email :'        DBEdit3 : Name = editEmail
Label4 : Caption = 'Téléphone :'    DBEdit4 : Name = editTelephone
```

**Important :** Pour chaque **TDBEdit** :
- `DataSource` : `DataSourceClients`
- `DataField` : sélectionnez le champ correspondant (nom, prenom, email, telephone)

## Implémentation du READ (Lecture)

### Charger les données au démarrage

Dans l'événement `OnCreate` du formulaire :

```pascal
procedure TFormGestionClients.FormCreate(Sender: TObject);
begin
  // Connecter à la base de données
  try
    FDConnection1.Connected := True;
    ChargerClients;
  except
    on E: Exception do
    begin
      ShowMessage('Erreur de connexion : ' + E.Message);
      Application.Terminate;
    end;
  end;
end;
```

### Méthode ChargerClients

```pascal
procedure TFormGestionClients.ChargerClients;
begin
  FDQueryClients.Close;
  FDQueryClients.SQL.Text :=
    'SELECT id, nom, prenom, email, telephone, date_inscription, actif ' +
    'FROM clients ' +
    'WHERE actif = TRUE ' +
    'ORDER BY nom, prenom';

  try
    FDQueryClients.Open;

    // Optionnel : personnaliser les colonnes de la grille
    DBGridClients.Columns[0].Width := 40;   // ID
    DBGridClients.Columns[1].Width := 120;  // Nom
    DBGridClients.Columns[2].Width := 120;  // Prénom
    DBGridClients.Columns[3].Width := 180;  // Email
    DBGridClients.Columns[4].Width := 100;  // Téléphone

  except
    on E: Exception do
      ShowMessage('Erreur lors du chargement : ' + E.Message);
  end;
end;
```

### Bouton Rafraîchir

```pascal
procedure TFormGestionClients.btnRafraichirClick(Sender: TObject);
begin
  ChargerClients;
  ShowMessage('Données actualisées');
end;
```

### Fonction de recherche

```pascal
procedure TFormGestionClients.btnRechercherClick(Sender: TObject);
var
  Recherche: string;
begin
  Recherche := Trim(editRecherche.Text);

  FDQueryClients.Close;

  if Recherche = '' then
  begin
    // Si la recherche est vide, afficher tous les clients
    ChargerClients;
  end
  else
  begin
    // Rechercher dans nom, prénom et email
    FDQueryClients.SQL.Text :=
      'SELECT id, nom, prenom, email, telephone, date_inscription, actif ' +
      'FROM clients ' +
      'WHERE actif = TRUE ' +
      '  AND (nom LIKE :Recherche ' +
      '       OR prenom LIKE :Recherche ' +
      '       OR email LIKE :Recherche) ' +
      'ORDER BY nom, prenom';

    FDQueryClients.ParamByName('Recherche').AsString := '%' + Recherche + '%';
  end;

  try
    FDQueryClients.Open;
  except
    on E: Exception do
      ShowMessage('Erreur de recherche : ' + E.Message);
  end;
end;
```

**Astuce :** Pour rechercher en temps réel à chaque frappe, utilisez l'événement `OnChange` du `editRecherche` au lieu d'un bouton.

## Implémentation du CREATE (Création)

### Formulaire de saisie

Créez un nouveau formulaire pour la saisie (ou utilisez une boîte de dialogue).

**Option 1 : Nouveau formulaire dédié**

1. **Fichier** → **Nouveau** → **Formulaire VCL**
2. Nommez-le : `uFormEditClient.pas`
3. Formulaire : `FormEditClient`

Ajoutez sur ce formulaire :
- Des **TLabel** et **TEdit** pour chaque champ
- Deux **TButton** : `btnValider` et `btnAnnuler`

```pascal
unit uFormEditClient;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,
  Vcl.StdCtrls;

type
  TFormEditClient = class(TForm)
    Label1: TLabel;
    editNom: TEdit;
    Label2: TLabel;
    editPrenom: TEdit;
    Label3: TLabel;
    editEmail: TEdit;
    Label4: TLabel;
    editTelephone: TEdit;
    btnValider: TButton;
    btnAnnuler: TButton;
    procedure btnAnnulerClick(Sender: TObject);
    procedure btnValiderClick(Sender: TObject);
  private
    { Déclarations privées }
  public
    { Déclarations publiques }
    // Propriétés publiques pour récupérer les valeurs
    function GetNom: string;
    function GetPrenom: string;
    function GetEmail: string;
    function GetTelephone: string;

    procedure SetNom(const Value: string);
    procedure SetPrenom(const Value: string);
    procedure SetEmail(const Value: string);
    procedure SetTelephone(const Value: string);
  end;

var
  FormEditClient: TFormEditClient;

implementation

{$R *.dfm}

procedure TFormEditClient.btnAnnulerClick(Sender: TObject);
begin
  ModalResult := mrCancel;
end;

procedure TFormEditClient.btnValiderClick(Sender: TObject);
begin
  // Validation des champs
  if Trim(editNom.Text) = '' then
  begin
    ShowMessage('Le nom est obligatoire');
    editNom.SetFocus;
    Exit;
  end;

  if Trim(editPrenom.Text) = '' then
  begin
    ShowMessage('Le prénom est obligatoire');
    editPrenom.SetFocus;
    Exit;
  end;

  if Trim(editEmail.Text) = '' then
  begin
    ShowMessage('L''email est obligatoire');
    editEmail.SetFocus;
    Exit;
  end;

  // Validation basique de l'email
  if Pos('@', editEmail.Text) = 0 then
  begin
    ShowMessage('Email invalide');
    editEmail.SetFocus;
    Exit;
  end;

  ModalResult := mrOk;
end;

// Getters et Setters
function TFormEditClient.GetNom: string;
begin
  Result := Trim(editNom.Text);
end;

function TFormEditClient.GetPrenom: string;
begin
  Result := Trim(editPrenom.Text);
end;

function TFormEditClient.GetEmail: string;
begin
  Result := Trim(editEmail.Text);
end;

function TFormEditClient.GetTelephone: string;
begin
  Result := Trim(editTelephone.Text);
end;

procedure TFormEditClient.SetNom(const Value: string);
begin
  editNom.Text := Value;
end;

procedure TFormEditClient.SetPrenom(const Value: string);
begin
  editPrenom.Text := Value;
end;

procedure TFormEditClient.SetEmail(const Value: string);
begin
  editEmail.Text := Value;
end;

procedure TFormEditClient.SetTelephone(const Value: string);
begin
  editTelephone.Text := Value;
end;

end.
```

### Bouton Nouveau - Insertion

Dans le formulaire principal :

```pascal
procedure TFormGestionClients.btnNouveauClick(Sender: TObject);
var
  FormEdit: TFormEditClient;
  Query: TFDQuery;
begin
  FormEdit := TFormEditClient.Create(nil);
  try
    FormEdit.Caption := 'Nouveau client';

    // Afficher le formulaire modal
    if FormEdit.ShowModal = mrOk then
    begin
      // Créer une requête temporaire pour l'insertion
      Query := TFDQuery.Create(nil);
      try
        Query.Connection := FDConnection1;
        Query.SQL.Text :=
          'INSERT INTO clients (nom, prenom, email, telephone, date_inscription) ' +
          'VALUES (:Nom, :Prenom, :Email, :Tel, :DateInscription)';

        // Assigner les paramètres
        Query.ParamByName('Nom').AsString := FormEdit.GetNom;
        Query.ParamByName('Prenom').AsString := FormEdit.GetPrenom;
        Query.ParamByName('Email').AsString := FormEdit.GetEmail;
        Query.ParamByName('Tel').AsString := FormEdit.GetTelephone;
        Query.ParamByName('DateInscription').AsDate := Date;

        try
          // Exécuter l'insertion
          Query.ExecSQL;
          ShowMessage('Client ajouté avec succès');

          // Recharger la liste
          ChargerClients;
        except
          on E: Exception do
          begin
            if Pos('Duplicate entry', E.Message) > 0 then
              ShowMessage('Cet email existe déjà')
            else
              ShowMessage('Erreur lors de l''ajout : ' + E.Message);
          end;
        end;

      finally
        Query.Free;
      end;
    end;

  finally
    FormEdit.Free;
  end;
end;
```

**Option 2 : Saisie directe dans la grille (plus simple)**

Vous pouvez aussi utiliser les capacités d'édition intégrées de TDBGrid :

```pascal
procedure TFormGestionClients.btnNouveauClick(Sender: TObject);
begin
  // Passer en mode insertion
  FDQueryClients.Append;

  // Le focus se place automatiquement dans la grille
  // L'utilisateur peut saisir directement
end;
```

Mais vous devrez alors gérer la sauvegarde avec un bouton "Enregistrer" séparé.

## Implémentation du UPDATE (Modification)

### Bouton Modifier

```pascal
procedure TFormGestionClients.btnModifierClick(Sender: TObject);
var
  FormEdit: TFormEditClient;
  Query: TFDQuery;
  ClientID: Integer;
begin
  // Vérifier qu'un client est sélectionné
  if FDQueryClients.IsEmpty then
  begin
    ShowMessage('Veuillez sélectionner un client à modifier');
    Exit;
  end;

  // Récupérer l'ID du client sélectionné
  ClientID := FDQueryClients.FieldByName('id').AsInteger;

  FormEdit := TFormEditClient.Create(nil);
  try
    FormEdit.Caption := 'Modifier le client';

    // Pré-remplir le formulaire avec les données actuelles
    FormEdit.SetNom(FDQueryClients.FieldByName('nom').AsString);
    FormEdit.SetPrenom(FDQueryClients.FieldByName('prenom').AsString);
    FormEdit.SetEmail(FDQueryClients.FieldByName('email').AsString);
    FormEdit.SetTelephone(FDQueryClients.FieldByName('telephone').AsString);

    // Afficher le formulaire modal
    if FormEdit.ShowModal = mrOk then
    begin
      Query := TFDQuery.Create(nil);
      try
        Query.Connection := FDConnection1;
        Query.SQL.Text :=
          'UPDATE clients SET ' +
          '  nom = :Nom, ' +
          '  prenom = :Prenom, ' +
          '  email = :Email, ' +
          '  telephone = :Tel ' +
          'WHERE id = :ID';

        // Assigner les paramètres
        Query.ParamByName('Nom').AsString := FormEdit.GetNom;
        Query.ParamByName('Prenom').AsString := FormEdit.GetPrenom;
        Query.ParamByName('Email').AsString := FormEdit.GetEmail;
        Query.ParamByName('Tel').AsString := FormEdit.GetTelephone;
        Query.ParamByName('ID').AsInteger := ClientID;

        try
          Query.ExecSQL;

          if Query.RowsAffected > 0 then
          begin
            ShowMessage('Client modifié avec succès');
            ChargerClients;
          end
          else
            ShowMessage('Erreur : client non trouvé');

        except
          on E: Exception do
            ShowMessage('Erreur lors de la modification : ' + E.Message);
        end;

      finally
        Query.Free;
      end;
    end;

  finally
    FormEdit.Free;
  end;
end;
```

### Modification directe avec Edit/Post

Méthode alternative plus simple :

```pascal
procedure TFormGestionClients.btnModifierClick(Sender: TObject);
begin
  if FDQueryClients.IsEmpty then
  begin
    ShowMessage('Veuillez sélectionner un client');
    Exit;
  end;

  // Passer en mode édition
  FDQueryClients.Edit;

  // Les DBEdit sont maintenant modifiables
  // L'utilisateur peut modifier directement

  // Il faudra un bouton "Enregistrer" pour appeler :
  // FDQueryClients.Post;
end;

procedure TFormGestionClients.btnEnregistrerClick(Sender: TObject);
begin
  try
    // Valider et enregistrer les modifications
    FDQueryClients.Post;
    ShowMessage('Modifications enregistrées');
  except
    on E: Exception do
    begin
      FDQueryClients.Cancel;  // Annuler les modifications
      ShowMessage('Erreur : ' + E.Message);
    end;
  end;
end;
```

## Implémentation du DELETE (Suppression)

### Bouton Supprimer

```pascal
procedure TFormGestionClients.btnSupprimerClick(Sender: TObject);
var
  ClientID: Integer;
  ClientNom, ClientPrenom: string;
  Query: TFDQuery;
begin
  // Vérifier qu'un client est sélectionné
  if FDQueryClients.IsEmpty then
  begin
    ShowMessage('Veuillez sélectionner un client à supprimer');
    Exit;
  end;

  // Récupérer les informations du client
  ClientID := FDQueryClients.FieldByName('id').AsInteger;
  ClientNom := FDQueryClients.FieldByName('nom').AsString;
  ClientPrenom := FDQueryClients.FieldByName('prenom').AsString;

  // Demander confirmation
  if MessageDlg(
    'Êtes-vous sûr de vouloir supprimer le client ' +
    ClientPrenom + ' ' + ClientNom + ' ?',
    mtConfirmation,
    [mbYes, mbNo],
    0
  ) = mrYes then
  begin
    Query := TFDQuery.Create(nil);
    try
      Query.Connection := FDConnection1;

      // Option 1 : Suppression physique (définitive)
      Query.SQL.Text := 'DELETE FROM clients WHERE id = :ID';
      Query.ParamByName('ID').AsInteger := ClientID;

      try
        Query.ExecSQL;

        if Query.RowsAffected > 0 then
        begin
          ShowMessage('Client supprimé');
          ChargerClients;
        end
        else
          ShowMessage('Erreur : client non trouvé');

      except
        on E: Exception do
          ShowMessage('Erreur lors de la suppression : ' + E.Message);
      end;

    finally
      Query.Free;
    end;
  end;
end;
```

### Suppression logique (recommandée)

Plutôt que supprimer physiquement, marquez comme inactif :

```pascal
procedure TFormGestionClients.btnSupprimerClick(Sender: TObject);
var
  ClientID: Integer;
  Query: TFDQuery;
begin
  if FDQueryClients.IsEmpty then
  begin
    ShowMessage('Veuillez sélectionner un client à supprimer');
    Exit;
  end;

  ClientID := FDQueryClients.FieldByName('id').AsInteger;

  if MessageDlg(
    'Voulez-vous désactiver ce client ?',
    mtConfirmation,
    [mbYes, mbNo],
    0
  ) = mrYes then
  begin
    Query := TFDQuery.Create(nil);
    try
      Query.Connection := FDConnection1;

      // Suppression logique : marquer comme inactif
      Query.SQL.Text := 'UPDATE clients SET actif = FALSE WHERE id = :ID';
      Query.ParamByName('ID').AsInteger := ClientID;

      try
        Query.ExecSQL;
        ShowMessage('Client désactivé');
        ChargerClients;  // Recharge la liste (le client disparaît)
      except
        on E: Exception do
          ShowMessage('Erreur : ' + E.Message);
      end;

    finally
      Query.Free;
    end;
  end;
end;
```

**Avantages de la suppression logique :**
- Conservation de l'historique
- Possibilité de restauration
- Pas de problèmes d'intégrité référentielle

## Gestion des états des boutons

Activez/désactivez les boutons selon le contexte :

```pascal
procedure TFormGestionClients.DBGridClientsCellClick(Column: TColumn);
begin
  // Activer les boutons quand un client est sélectionné
  btnModifier.Enabled := not FDQueryClients.IsEmpty;
  btnSupprimer.Enabled := not FDQueryClients.IsEmpty;
end;

procedure TFormGestionClients.ChargerClients;
begin
  // ... code de chargement ...

  // Mettre à jour l'état des boutons
  btnModifier.Enabled := not FDQueryClients.IsEmpty;
  btnSupprimer.Enabled := not FDQueryClients.IsEmpty;
end;
```

## Validation des données

### Fonction de validation globale

```pascal
function TFormGestionClients.ValiderClient(const Nom, Prenom, Email: string): Boolean;
begin
  Result := False;

  // Nom obligatoire
  if Trim(Nom) = '' then
  begin
    ShowMessage('Le nom est obligatoire');
    Exit;
  end;

  // Prénom obligatoire
  if Trim(Prenom) = '' then
  begin
    ShowMessage('Le prénom est obligatoire');
    Exit;
  end;

  // Email obligatoire et valide
  if Trim(Email) = '' then
  begin
    ShowMessage('L''email est obligatoire');
    Exit;
  end;

  if (Pos('@', Email) = 0) or (Pos('.', Email) = 0) then
  begin
    ShowMessage('Format d''email invalide');
    Exit;
  end;

  Result := True;
end;
```

### Validation de l'unicité de l'email

```pascal
function TFormGestionClients.EmailDejaUtilise(const Email: string; ExcluID: Integer = -1): Boolean;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    if ExcluID = -1 then
      // Pour création : vérifier si l'email existe
      Query.SQL.Text := 'SELECT COUNT(*) AS nb FROM clients WHERE email = :Email'
    else
      // Pour modification : exclure le client en cours
      Query.SQL.Text :=
        'SELECT COUNT(*) AS nb FROM clients WHERE email = :Email AND id <> :ID';

    Query.ParamByName('Email').AsString := Email;

    if ExcluID <> -1 then
      Query.ParamByName('ID').AsInteger := ExcluID;

    Query.Open;
    Result := Query.FieldByName('nb').AsInteger > 0;
    Query.Close;

  finally
    Query.Free;
  end;
end;
```

Utilisation dans l'ajout :

```pascal
if EmailDejaUtilise(FormEdit.GetEmail) then
begin
  ShowMessage('Cet email est déjà utilisé par un autre client');
  Exit;
end;
```

Utilisation dans la modification :

```pascal
if EmailDejaUtilise(FormEdit.GetEmail, ClientID) then
begin
  ShowMessage('Cet email est déjà utilisé');
  Exit;
end;
```

## Amélioration : Utilisation d'un DataModule

Pour une meilleure organisation, créez un **DataModule** :

### Créer le DataModule

1. **Fichier** → **Nouveau** → **Autre** → **DataModule**
2. Nommez-le : `dmDatabase` (Data Module Database)

### Déplacer les composants

Déplacez tous les composants FireDAC du formulaire vers le DataModule :
- `FDConnection1`
- `FDQueryClients`
- `FDPhysMySQLDriverLink`
- etc.

### Avantages du DataModule

- **Séparation des préoccupations** : logique de données séparée de l'interface
- **Réutilisation** : plusieurs formulaires peuvent utiliser le même DataModule
- **Organisation** : code plus propre et maintenable

### Utilisation

Dans le formulaire :

```pascal
unit uFormGestionClients;

interface

uses
  // ...
  dmDatabase;  // Ajouter le DataModule dans uses

implementation

procedure TFormGestionClients.FormCreate(Sender: TObject);
begin
  // Accéder au DataModule
  DataModule1.FDConnection1.Connected := True;
  ChargerClients;
end;

procedure TFormGestionClients.ChargerClients;
begin
  with DataModule1.FDQueryClients do
  begin
    Close;
    SQL.Text := 'SELECT * FROM clients WHERE actif = TRUE ORDER BY nom';
    Open;
  end;
end;
```

## Gestion des transactions

Pour des opérations complexes, utilisez les transactions :

```pascal
procedure TFormGestionClients.OperationComplexe;
begin
  FDConnection1.StartTransaction;
  try
    // Opération 1
    Query1.ExecSQL;

    // Opération 2
    Query2.ExecSQL;

    // Opération 3
    Query3.ExecSQL;

    // Tout a réussi : valider
    FDConnection1.Commit;
    ShowMessage('Opérations réussies');

  except
    on E: Exception do
    begin
      // En cas d'erreur : annuler TOUTES les opérations
      FDConnection1.Rollback;
      ShowMessage('Erreur, toutes les opérations ont été annulées : ' + E.Message);
    end;
  end;
end;
```

**Exemple concret : Transfert entre comptes**

```pascal
procedure TransfererArgent(CompteSource, CompteDest: Integer; Montant: Currency);
begin
  FDConnection1.StartTransaction;
  try
    // Débiter le compte source
    QueryDebit.SQL.Text := 'UPDATE comptes SET solde = solde - :Montant WHERE id = :ID';
    QueryDebit.ParamByName('Montant').AsCurrency := Montant;
    QueryDebit.ParamByName('ID').AsInteger := CompteSource;
    QueryDebit.ExecSQL;

    // Créditer le compte destination
    QueryCredit.SQL.Text := 'UPDATE comptes SET solde = solde + :Montant WHERE id = :ID';
    QueryCredit.ParamByName('Montant').AsCurrency := Montant;
    QueryCredit.ParamByName('ID').AsInteger := CompteDest;
    QueryCredit.ExecSQL;

    // Tout est OK : valider
    FDConnection1.Commit;
    ShowMessage('Transfert réussi');
  except
    // Erreur : tout annuler
    FDConnection1.Rollback;
    ShowMessage('Transfert annulé');
  end;
end;
```

## Optimisations et bonnes pratiques

### 1. Utiliser CachedUpdates pour les modifications en lot

```pascal
// Activer le cache des modifications
FDQueryClients.CachedUpdates := True;

// Faire plusieurs modifications
FDQueryClients.First;
while not FDQueryClients.Eof do
begin
  FDQueryClients.Edit;
  FDQueryClients.FieldByName('statut').AsString := 'traité';
  FDQueryClients.Post;
  FDQueryClients.Next;
end;

// Appliquer toutes les modifications en une seule fois
FDQueryClients.ApplyUpdates;
FDQueryClients.CommitUpdates;
```

### 2. Fermer les requêtes quand elles ne sont pas utilisées

```pascal
procedure TFormGestionClients.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  // Fermer tous les datasets
  FDQueryClients.Close;

  // Fermer la connexion
  FDConnection1.Connected := False;
end;
```

### 3. Gérer les valeurs NULL

```pascal
// Vérifier si un champ est NULL
if FDQueryClients.FieldByName('telephone').IsNull then
  ShowMessage('Pas de téléphone')
else
  Telephone := FDQueryClients.FieldByName('telephone').AsString;

// Assigner NULL à un paramètre
Query.ParamByName('telephone').Clear;  // Ou .Value := Null;
```

### 4. Afficher un message pendant le chargement

```pascal
procedure TFormGestionClients.ChargerClients;
begin
  Screen.Cursor := crHourGlass;  // Curseur sablier
  try
    FDQueryClients.Close;
    FDQueryClients.SQL.Text := 'SELECT * FROM clients ORDER BY nom';
    FDQueryClients.Open;
  finally
    Screen.Cursor := crDefault;  // Curseur normal
  end;
end;
```

### 5. Pagination pour grandes tables

```pascal
procedure TFormGestionClients.ChargerClientsPage(PageNumber, PageSize: Integer);
var
  Offset: Integer;
begin
  Offset := (PageNumber - 1) * PageSize;

  FDQueryClients.SQL.Text :=
    'SELECT * FROM clients ' +
    'ORDER BY nom ' +
    'LIMIT :PageSize OFFSET :Offset';

  FDQueryClients.ParamByName('PageSize').AsInteger := PageSize;
  FDQueryClients.ParamByName('Offset').AsInteger := Offset;
  FDQueryClients.Open;
end;

// Exemple : charger la page 1 avec 50 enregistrements
ChargerClientsPage(1, 50);
```

## Gestion des erreurs globale

Centralisez la gestion des erreurs :

```pascal
procedure TFormGestionClients.GererErreurSQL(const Operation: string; E: Exception);
begin
  if Pos('Duplicate entry', E.Message) > 0 then
    ShowMessage('Cette valeur existe déjà dans la base')
  else if Pos('foreign key constraint', E.Message) > 0 then
    ShowMessage('Impossible de supprimer : des données liées existent')
  else if Pos('Lost connection', E.Message) > 0 then
    ShowMessage('Connexion perdue avec la base de données')
  else
    ShowMessage('Erreur lors de ' + Operation + ' : ' + E.Message);

  // Logger l'erreur dans un fichier
  LogError(Operation + ': ' + E.Message);
end;

// Utilisation
try
  Query.ExecSQL;
except
  on E: Exception do
    GererErreurSQL('l''ajout du client', E);
end;
```

## Export des données

Ajouter une fonction d'export :

```pascal
procedure TFormGestionClients.btnExporterClick(Sender: TObject);
var
  SaveDialog: TSaveDialog;
  Fichier: TextFile;
begin
  SaveDialog := TSaveDialog.Create(nil);
  try
    SaveDialog.Filter := 'Fichiers CSV|*.csv';
    SaveDialog.DefaultExt := 'csv';

    if SaveDialog.Execute then
    begin
      AssignFile(Fichier, SaveDialog.FileName);
      Rewrite(Fichier);
      try
        // En-têtes
        WriteLn(Fichier, 'ID;Nom;Prénom;Email;Téléphone');

        // Données
        FDQueryClients.First;
        while not FDQueryClients.Eof do
        begin
          WriteLn(Fichier,
            FDQueryClients['id'] + ';' +
            FDQueryClients['nom'] + ';' +
            FDQueryClients['prenom'] + ';' +
            FDQueryClients['email'] + ';' +
            FDQueryClients['telephone']
          );
          FDQueryClients.Next;
        end;

        ShowMessage('Export réussi');
      finally
        CloseFile(Fichier);
      end;
    end;
  finally
    SaveDialog.Free;
  end;
end;
```

## Résumé des opérations CRUD

| Opération | SQL | Méthode FireDAC | Code clé |
|-----------|-----|-----------------|----------|
| **Create** | INSERT | `ExecSQL` | `Query.ExecSQL` |
| **Read** | SELECT | `Open` | `Query.Open` |
| **Update** | UPDATE | `ExecSQL` | `Query.ExecSQL` |
| **Delete** | DELETE | `ExecSQL` | `Query.ExecSQL` |

## Checklist d'une application CRUD complète

✅ **Interface utilisateur**
- Grille pour afficher les données
- Boutons pour chaque opération CRUD
- Formulaire de saisie/édition
- Recherche et filtres

✅ **Fonctionnalités**
- Chargement des données au démarrage
- Rafraîchissement manuel
- Validation des données
- Messages de confirmation
- Gestion des erreurs

✅ **Sécurité**
- Requêtes paramétrées
- Validation côté client
- Confirmation avant suppression
- Gestion des doublons

✅ **Performance**
- Fermeture des requêtes après usage
- Utilisation efficace de la connexion
- Pagination si nécessaire

✅ **Maintenabilité**
- Code organisé en méthodes
- Utilisation d'un DataModule
- Gestion centralisée des erreurs
- Commentaires dans le code

## Prochaines étapes

Vous savez maintenant créer une application CRUD complète ! Dans les sections suivantes, nous verrons :

1. Comment utiliser des transactions pour des opérations complexes
2. Comment lier des données visuellement avec des grilles et des contrôles
3. Comment créer un modèle en couches pour une meilleure architecture
4. Comment optimiser les performances avec FireDAC

Vous avez maintenant les bases solides pour créer des applications de gestion de données professionnelles avec Delphi et MySQL/MariaDB !

⏭️ [Transactions et intégrité des données](/08-acces-aux-bases-de-donnees-mysql-mariadb/05.3-transactions-integrite-donnees.md)
