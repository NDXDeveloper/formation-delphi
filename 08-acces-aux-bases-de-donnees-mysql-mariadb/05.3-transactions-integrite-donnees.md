üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.5.3 Transactions et int√©grit√© des donn√©es

## Introduction

Lorsque vous travaillez avec des bases de donn√©es, il est crucial de garantir que vos donn√©es restent **coh√©rentes** et **fiables**, m√™me en cas d'erreur. Les **transactions** et les m√©canismes d'**int√©grit√© des donn√©es** sont les outils qui permettent d'assurer cette fiabilit√©.

Dans ce chapitre, nous allons d√©couvrir comment prot√©ger vos donn√©es et garantir leur coh√©rence dans toutes les situations.

## Qu'est-ce qu'une transaction ?

### D√©finition simple

Une **transaction** est un ensemble d'op√©rations de base de donn√©es qui doivent **toutes r√©ussir ou toutes √©chouer ensemble**. C'est un principe du "tout ou rien".

### Analogie bancaire

Imaginez un transfert d'argent entre deux comptes bancaires :

```
Op√©ration 1 : D√©biter 100‚Ç¨ du compte A
Op√©ration 2 : Cr√©diter 100‚Ç¨ sur le compte B
```

**Sans transaction :**
- L'op√©ration 1 r√©ussit (d√©bit de 100‚Ç¨)
- L'op√©ration 2 √©choue (probl√®me r√©seau)
- R√©sultat : 100‚Ç¨ ont disparu ! üò±

**Avec transaction :**
- L'op√©ration 1 r√©ussit (d√©bit de 100‚Ç¨)
- L'op√©ration 2 √©choue (probl√®me r√©seau)
- La transaction d√©tecte l'√©chec et **annule aussi l'op√©ration 1**
- R√©sultat : Les comptes restent inchang√©s ‚úÖ

### Exemple concret en e-commerce

Lors d'une commande en ligne :

1. R√©duire le stock du produit
2. Cr√©er la commande
3. Enregistrer les articles de la commande
4. D√©biter la carte bancaire
5. Envoyer l'email de confirmation

Si l'op√©ration 4 (paiement) √©choue, toutes les autres doivent √™tre annul√©es !

## Les propri√©t√©s ACID

Les transactions respectent 4 propri√©t√©s fondamentales, r√©sum√©es par l'acronyme **ACID** :

### A - Atomicit√© (Atomicity)

**"Tout ou rien"**

La transaction est **indivisible** : soit toutes les op√©rations r√©ussissent, soit aucune n'est appliqu√©e.

```
Transaction r√©ussie :
  Op√©ration 1 ‚úì
  Op√©ration 2 ‚úì  ‚Üí COMMIT (validation)
  Op√©ration 3 ‚úì

Transaction √©chou√©e :
  Op√©ration 1 ‚úì
  Op√©ration 2 ‚úó  ‚Üí ROLLBACK (annulation de tout)
  Op√©ration 3 (non ex√©cut√©e)
```

### C - Coh√©rence (Consistency)

**"Les r√®gles sont respect√©es"**

La transaction fait passer la base de donn√©es d'un √©tat coh√©rent √† un autre √©tat coh√©rent. Les contraintes d'int√©grit√© sont toujours respect√©es.

```
Avant transaction : Total des comptes = 10 000‚Ç¨
Pendant transaction : √âtat temporaire incoh√©rent
Apr√®s transaction : Total des comptes = 10 000‚Ç¨ ‚úì
```

### I - Isolation (Isolation)

**"Chacun dans sa bulle"**

Les transactions concurrentes (qui s'ex√©cutent en m√™me temps) n'interf√®rent pas entre elles. Chaque transaction s'ex√©cute comme si elle √©tait seule.

```
Transaction A : Modifier client n¬∞1
Transaction B : Modifier client n¬∞2
‚Üí Aucun conflit

Transaction A : Lire et modifier client n¬∞1
Transaction B : Lire et modifier client n¬∞1
‚Üí Isolation assure la coh√©rence
```

### D - Durabilit√© (Durability)

**"Ce qui est fait est fait"**

Une fois qu'une transaction est valid√©e (COMMIT), ses effets sont **permanents**, m√™me en cas de panne du syst√®me.

```
Transaction COMMIT √† 10h00
Panne serveur √† 10h01
‚Üí Les donn√©es sont sauvegard√©es ‚úì
```

## Transactions dans Delphi avec FireDAC

### Les m√©thodes essentielles

FireDAC propose trois m√©thodes pour g√©rer les transactions via `TFDConnection` :

| M√©thode | Description |
|---------|-------------|
| `StartTransaction` | D√©marre une nouvelle transaction |
| `Commit` | Valide la transaction (applique d√©finitivement) |
| `Rollback` | Annule la transaction (revient en arri√®re) |

### Structure basique d'une transaction

```pascal
FDConnection1.StartTransaction;
try
  // Vos op√©rations SQL ici
  Query1.ExecSQL;
  Query2.ExecSQL;
  Query3.ExecSQL;

  // Tout s'est bien pass√© : valider
  FDConnection1.Commit;
except
  // En cas d'erreur : annuler tout
  FDConnection1.Rollback;
  raise;  // Relancer l'exception
end;
```

**Points importants :**
- Toujours mettre `StartTransaction` avant les op√©rations
- Toujours utiliser `try...except` pour capturer les erreurs
- Toujours appeler `Commit` en cas de succ√®s
- Toujours appeler `Rollback` en cas d'erreur

## Exemples pratiques

### Exemple 1 : Transfert bancaire

```pascal
procedure TFormBanque.TransfererArgent(
  CompteSource, CompteDest: Integer;
  Montant: Currency
);
var
  QueryDebit, QueryCredit: TFDQuery;
begin
  QueryDebit := TFDQuery.Create(nil);
  QueryCredit := TFDQuery.Create(nil);
  try
    QueryDebit.Connection := FDConnection1;
    QueryCredit.Connection := FDConnection1;

    // D√©marrer la transaction
    FDConnection1.StartTransaction;
    try
      // Op√©ration 1 : D√©biter le compte source
      QueryDebit.SQL.Text :=
        'UPDATE comptes SET solde = solde - :Montant WHERE id = :ID';
      QueryDebit.ParamByName('Montant').AsCurrency := Montant;
      QueryDebit.ParamByName('ID').AsInteger := CompteSource;
      QueryDebit.ExecSQL;

      // V√©rifier qu'une ligne a √©t√© modifi√©e
      if QueryDebit.RowsAffected = 0 then
        raise Exception.Create('Compte source introuvable');

      // Op√©ration 2 : Cr√©diter le compte destination
      QueryCredit.SQL.Text :=
        'UPDATE comptes SET solde = solde + :Montant WHERE id = :ID';
      QueryCredit.ParamByName('Montant').AsCurrency := Montant;
      QueryCredit.ParamByName('ID').AsInteger := CompteDest;
      QueryCredit.ExecSQL;

      // V√©rifier qu'une ligne a √©t√© modifi√©e
      if QueryCredit.RowsAffected = 0 then
        raise Exception.Create('Compte destination introuvable');

      // Tout est OK : valider la transaction
      FDConnection1.Commit;
      ShowMessage('Transfert r√©ussi de ' + CurrToStr(Montant) + '‚Ç¨');

    except
      on E: Exception do
      begin
        // Erreur : annuler toutes les op√©rations
        FDConnection1.Rollback;
        ShowMessage('Transfert annul√© : ' + E.Message);
      end;
    end;

  finally
    QueryDebit.Free;
    QueryCredit.Free;
  end;
end;
```

**Ce qui se passe :**
- Si les deux UPDATE r√©ussissent ‚Üí `Commit` ‚Üí modifications enregistr√©es ‚úì
- Si un UPDATE √©choue ‚Üí `Rollback` ‚Üí tout est annul√©, les soldes restent inchang√©s ‚úì

### Exemple 2 : Cr√©ation d'une commande compl√®te

```pascal
procedure TFormCommandes.CreerCommande(ClientID: Integer; Articles: TArray<TArticle>);
var
  QueryCommande, QueryArticle, QueryStock: TFDQuery;
  CommandeID: Integer;
  i: Integer;
begin
  QueryCommande := TFDQuery.Create(nil);
  QueryArticle := TFDQuery.Create(nil);
  QueryStock := TFDQuery.Create(nil);
  try
    QueryCommande.Connection := FDConnection1;
    QueryArticle.Connection := FDConnection1;
    QueryStock.Connection := FDConnection1;

    FDConnection1.StartTransaction;
    try
      // √âtape 1 : Cr√©er la commande
      QueryCommande.SQL.Text :=
        'INSERT INTO commandes (client_id, date_commande, statut) ' +
        'VALUES (:ClientID, NOW(), ''En cours'')';
      QueryCommande.ParamByName('ClientID').AsInteger := ClientID;
      QueryCommande.ExecSQL;

      // R√©cup√©rer l'ID de la commande cr√©√©e
      CommandeID := FDConnection1.GetLastAutoGenValue('commandes');

      // √âtape 2 : Ajouter chaque article √† la commande
      for i := 0 to Length(Articles) - 1 do
      begin
        // V√©rifier le stock disponible
        QueryStock.Close;
        QueryStock.SQL.Text :=
          'SELECT stock FROM produits WHERE id = :ProduitID';
        QueryStock.ParamByName('ProduitID').AsInteger := Articles[i].ProduitID;
        QueryStock.Open;

        if QueryStock.FieldByName('stock').AsInteger < Articles[i].Quantite then
          raise Exception.Create('Stock insuffisant pour le produit ' +
            IntToStr(Articles[i].ProduitID));

        QueryStock.Close;

        // Ins√©rer l'article de commande
        QueryArticle.SQL.Text :=
          'INSERT INTO commande_articles (commande_id, produit_id, quantite, prix_unitaire) ' +
          'VALUES (:CommandeID, :ProduitID, :Quantite, :Prix)';
        QueryArticle.ParamByName('CommandeID').AsInteger := CommandeID;
        QueryArticle.ParamByName('ProduitID').AsInteger := Articles[i].ProduitID;
        QueryArticle.ParamByName('Quantite').AsInteger := Articles[i].Quantite;
        QueryArticle.ParamByName('Prix').AsCurrency := Articles[i].Prix;
        QueryArticle.ExecSQL;

        // D√©cr√©menter le stock
        QueryStock.SQL.Text :=
          'UPDATE produits SET stock = stock - :Quantite WHERE id = :ProduitID';
        QueryStock.ParamByName('Quantite').AsInteger := Articles[i].Quantite;
        QueryStock.ParamByName('ProduitID').AsInteger := Articles[i].ProduitID;
        QueryStock.ExecSQL;
      end;

      // Tout est OK : valider
      FDConnection1.Commit;
      ShowMessage('Commande cr√©√©e avec succ√®s (n¬∞' + IntToStr(CommandeID) + ')');

    except
      on E: Exception do
      begin
        FDConnection1.Rollback;
        ShowMessage('Erreur lors de la cr√©ation de la commande : ' + E.Message);
      end;
    end;

  finally
    QueryCommande.Free;
    QueryArticle.Free;
    QueryStock.Free;
  end;
end;
```

**Avantages de la transaction ici :**
- Si un article n'a pas assez de stock : toute la commande est annul√©e
- Pas de commande "partielle" avec seulement quelques articles
- Le stock n'est d√©cr√©ment√© que si toute la commande est valid√©e

### Exemple 3 : Suppression avec cascade manuel

```pascal
procedure TFormClients.SupprimerClientComplet(ClientID: Integer);
var
  QueryCommandes, QueryArticles, QueryClient: TFDQuery;
begin
  if MessageDlg('Supprimer ce client et toutes ses commandes ?',
    mtConfirmation, [mbYes, mbNo], 0) <> mrYes then
    Exit;

  QueryCommandes := TFDQuery.Create(nil);
  QueryArticles := TFDQuery.Create(nil);
  QueryClient := TFDQuery.Create(nil);
  try
    QueryCommandes.Connection := FDConnection1;
    QueryArticles.Connection := FDConnection1;
    QueryClient.Connection := FDConnection1;

    FDConnection1.StartTransaction;
    try
      // √âtape 1 : Supprimer les articles de toutes les commandes du client
      QueryArticles.SQL.Text :=
        'DELETE FROM commande_articles ' +
        'WHERE commande_id IN (SELECT id FROM commandes WHERE client_id = :ClientID)';
      QueryArticles.ParamByName('ClientID').AsInteger := ClientID;
      QueryArticles.ExecSQL;

      // √âtape 2 : Supprimer les commandes du client
      QueryCommandes.SQL.Text := 'DELETE FROM commandes WHERE client_id = :ClientID';
      QueryCommandes.ParamByName('ClientID').AsInteger := ClientID;
      QueryCommandes.ExecSQL;

      // √âtape 3 : Supprimer le client
      QueryClient.SQL.Text := 'DELETE FROM clients WHERE id = :ClientID';
      QueryClient.ParamByName('ClientID').AsInteger := ClientID;
      QueryClient.ExecSQL;

      // Valider la transaction
      FDConnection1.Commit;
      ShowMessage('Client supprim√© avec toutes ses donn√©es');

    except
      on E: Exception do
      begin
        FDConnection1.Rollback;
        ShowMessage('Erreur : ' + E.Message);
      end;
    end;

  finally
    QueryCommandes.Free;
    QueryArticles.Free;
    QueryClient.Free;
  end;
end;
```

## V√©rifier si une transaction est en cours

```pascal
if FDConnection1.InTransaction then
  ShowMessage('Transaction en cours')
else
  ShowMessage('Pas de transaction active');
```

## Transactions imbriqu√©es (SavePoints)

FireDAC supporte les **points de sauvegarde** (SavePoints) qui permettent de cr√©er des "mini-transactions" √† l'int√©rieur d'une transaction principale.

```pascal
FDConnection1.StartTransaction;
try
  // Op√©rations principales
  Query1.ExecSQL;

  // Cr√©er un point de sauvegarde
  FDConnection1.ExecSQL('SAVEPOINT point1');

  try
    // Op√©rations secondaires
    Query2.ExecSQL;
    Query3.ExecSQL;
  except
    // Annuler uniquement jusqu'au point de sauvegarde
    FDConnection1.ExecSQL('ROLLBACK TO SAVEPOINT point1');
    // La transaction principale continue
  end;

  // Valider toute la transaction
  FDConnection1.Commit;
except
  FDConnection1.Rollback;
end;
```

**Cas d'usage :** Vous voulez essayer une op√©ration, mais si elle √©choue, continuer sans annuler tout.

## Int√©grit√© des donn√©es

### Qu'est-ce que l'int√©grit√© des donn√©es ?

L'**int√©grit√© des donn√©es** garantit que les donn√©es de votre base sont :
- **Valides** : respectent les r√®gles d√©finies
- **Coh√©rentes** : les relations entre tables sont correctes
- **Compl√®tes** : pas de donn√©es manquantes obligatoires

### Types d'int√©grit√©

#### 1. Int√©grit√© de domaine

Les valeurs d'un champ doivent respecter un domaine d√©fini.

```sql
-- Exemples de contraintes de domaine
CREATE TABLE produits (
    id INT PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,           -- Pas de NULL
    prix DECIMAL(10,2) CHECK (prix > 0), -- Prix positif
    stock INT DEFAULT 0,                 -- Valeur par d√©faut
    categorie ENUM('Alimentaire', '√âlectronique', 'V√™tement')  -- Valeurs limit√©es
);
```

#### 2. Int√©grit√© d'entit√© (Cl√© primaire)

Chaque enregistrement doit √™tre **unique** et **identifiable**.

```sql
CREATE TABLE clients (
    id INT AUTO_INCREMENT PRIMARY KEY,  -- Cl√© primaire unique
    email VARCHAR(150) UNIQUE,          -- Email unique
    -- ...
);
```

**Dans Delphi :**

```pascal
// V√©rifier l'unicit√© avant insertion
function EmailExiste(const Email: string): Boolean;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;
    Query.SQL.Text := 'SELECT COUNT(*) AS nb FROM clients WHERE email = :Email';
    Query.ParamByName('Email').AsString := Email;
    Query.Open;
    Result := Query.FieldByName('nb').AsInteger > 0;
  finally
    Query.Free;
  end;
end;

// Utilisation
if EmailExiste('test@email.fr') then
  ShowMessage('Cet email existe d√©j√†')
else
  // Ins√©rer...
```

#### 3. Int√©grit√© r√©f√©rentielle (Cl√©s √©trang√®res)

Les relations entre tables doivent √™tre coh√©rentes.

```sql
-- Table principale
CREATE TABLE clients (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100)
);

-- Table li√©e avec cl√© √©trang√®re
CREATE TABLE commandes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    client_id INT NOT NULL,
    date_commande DATE,
    FOREIGN KEY (client_id) REFERENCES clients(id)
);
```

**R√®gles d'int√©grit√© r√©f√©rentielle :**

1. **ON DELETE CASCADE** : Supprimer automatiquement les enregistrements li√©s
   ```sql
   FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE
   ```
   Si on supprime un client ‚Üí ses commandes sont automatiquement supprim√©es

2. **ON DELETE RESTRICT** : Interdire la suppression si des liens existent
   ```sql
   FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE RESTRICT
   ```
   Impossible de supprimer un client ayant des commandes

3. **ON DELETE SET NULL** : Mettre NULL dans les enregistrements li√©s
   ```sql
   FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE SET NULL
   ```
   Si on supprime un client ‚Üí client_id devient NULL dans les commandes

**Dans Delphi - G√©rer les erreurs de cl√© √©trang√®re :**

```pascal
try
  QueryDelete.SQL.Text := 'DELETE FROM clients WHERE id = :ID';
  QueryDelete.ParamByName('ID').AsInteger := ClientID;
  QueryDelete.ExecSQL;
except
  on E: Exception do
  begin
    if Pos('foreign key constraint', LowerCase(E.Message)) > 0 then
      ShowMessage('Impossible de supprimer : ce client a des commandes en cours')
    else
      ShowMessage('Erreur : ' + E.Message);
  end;
end;
```

### Contraintes CHECK

Valider des r√®gles m√©tier au niveau de la base.

```sql
CREATE TABLE employes (
    id INT PRIMARY KEY,
    nom VARCHAR(100),
    age INT CHECK (age >= 18 AND age <= 65),
    salaire DECIMAL(10,2) CHECK (salaire > 0),
    date_embauche DATE CHECK (date_embauche <= CURDATE())
);
```

**Dans Delphi - Valider avant insertion :**

```pascal
function ValiderEmploye(Age: Integer; Salaire: Currency; DateEmbauche: TDate): Boolean;
begin
  Result := False;

  if (Age < 18) or (Age > 65) then
  begin
    ShowMessage('L''√¢ge doit √™tre entre 18 et 65 ans');
    Exit;
  end;

  if Salaire <= 0 then
  begin
    ShowMessage('Le salaire doit √™tre positif');
    Exit;
  end;

  if DateEmbauche > Date then
  begin
    ShowMessage('La date d''embauche ne peut pas √™tre dans le futur');
    Exit;
  end;

  Result := True;
end;
```

## Niveaux d'isolation des transactions

MySQL/MariaDB propose plusieurs **niveaux d'isolation** qui d√©finissent comment les transactions interagissent entre elles.

### Les 4 niveaux d'isolation

| Niveau | Description | Probl√®mes √©vit√©s |
|--------|-------------|------------------|
| **READ UNCOMMITTED** | Lecture des donn√©es non valid√©es | Aucun (le moins s√ªr) |
| **READ COMMITTED** | Lecture uniquement des donn√©es valid√©es | Lecture sale |
| **REPEATABLE READ** | Les lectures sont reproductibles | Lecture non reproductible |
| **SERIALIZABLE** | Isolation totale | Lecture fant√¥me (le plus s√ªr) |

**Par d√©faut**, MySQL utilise **REPEATABLE READ**.

### D√©finir le niveau d'isolation dans Delphi

```pascal
// Pour toute la connexion
FDConnection1.TxOptions.Isolation := xiReadCommitted;

// Ou via SQL
FDConnection1.ExecSQL('SET TRANSACTION ISOLATION LEVEL READ COMMITTED');
```

### Exemple de probl√®me r√©solu par l'isolation

**Sc√©nario : Deux transactions simultan√©es**

```
Transaction A                   Transaction B
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
START TRANSACTION              START TRANSACTION
SELECT solde FROM compte
                               SELECT solde FROM compte
                               UPDATE compte SET solde = solde - 100
                               COMMIT
UPDATE compte SET solde = solde + 50
COMMIT
```

Avec **REPEATABLE READ** : Transaction A travaille sur un "snapshot" et voit toujours le m√™me solde.

## Deadlocks (Interblocages)

Un **deadlock** se produit quand deux transactions attendent l'une l'autre ind√©finiment.

### Exemple de deadlock

```
Transaction A                   Transaction B
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Verrouille la ligne 1          Verrouille la ligne 2
Attend la ligne 2 ‚è≥            Attend la ligne 1 ‚è≥
```

R√©sultat : **Blocage mutuel** !

### Comment MySQL g√®re les deadlocks

MySQL **d√©tecte automatiquement** les deadlocks et annule une des transactions.

### G√©rer les deadlocks dans Delphi

```pascal
procedure ExecuterAvecRetry(const Operation: TProc; MaxTentatives: Integer = 3);
var
  Tentative: Integer;
  Success: Boolean;
begin
  Success := False;
  Tentative := 0;

  while (not Success) and (Tentative < MaxTentatives) do
  begin
    Inc(Tentative);
    try
      Operation();
      Success := True;
    except
      on E: Exception do
      begin
        if Pos('deadlock', LowerCase(E.Message)) > 0 then
        begin
          // Attendre un peu avant de r√©essayer
          Sleep(Random(1000));
          if Tentative >= MaxTentatives then
            raise;  // Abandon apr√®s MaxTentatives
        end
        else
          raise;  // Autre erreur : relancer
      end;
    end;
  end;
end;

// Utilisation
ExecuterAvecRetry(
  procedure
  begin
    FDConnection1.StartTransaction;
    try
      // Vos op√©rations
      Query1.ExecSQL;
      Query2.ExecSQL;
      FDConnection1.Commit;
    except
      FDConnection1.Rollback;
      raise;
    end;
  end
);
```

## Bonnes pratiques pour les transactions

### ‚úÖ √Ä FAIRE

1. **Transactions courtes**
   ```pascal
   // ‚úÖ BON : Transaction rapide
   FDConnection1.StartTransaction;
   Query.ExecSQL;
   FDConnection1.Commit;
   ```

   ```pascal
   // ‚ùå MAUVAIS : Transaction longue
   FDConnection1.StartTransaction;
   ShowDialog;  // Attend l'utilisateur !
   Query.ExecSQL;
   FDConnection1.Commit;
   ```

2. **Toujours un Rollback en cas d'erreur**
   ```pascal
   FDConnection1.StartTransaction;
   try
     // Op√©rations
     FDConnection1.Commit;
   except
     FDConnection1.Rollback;  // ‚úÖ Important !
     raise;
   end;
   ```

3. **Ordre coh√©rent des op√©rations**
   ```pascal
   // Toujours acc√©der aux tables dans le m√™me ordre
   // pour √©viter les deadlocks

   // ‚úÖ Transaction A et B : d'abord clients, puis commandes
   UPDATE clients ...
   UPDATE commandes ...
   ```

4. **V√©rifier InTransaction avant de d√©marrer**
   ```pascal
   if not FDConnection1.InTransaction then
     FDConnection1.StartTransaction;
   ```

### ‚ùå √Ä √âVITER

1. **Transactions imbriqu√©es non g√©r√©es**
   ```pascal
   // ‚ùå MAUVAIS
   FDConnection1.StartTransaction;
   SomeMethod();  // Cette m√©thode appelle aussi StartTransaction !
   FDConnection1.Commit;
   ```

2. **Oublier le Commit**
   ```pascal
   // ‚ùå MAUVAIS
   FDConnection1.StartTransaction;
   Query.ExecSQL;
   // Oubli du Commit ‚Üí Verrous jamais lib√©r√©s !
   ```

3. **Transactions trop longues**
   ```pascal
   // ‚ùå MAUVAIS : Bloque la base pendant trop longtemps
   FDConnection1.StartTransaction;
   for i := 1 to 10000 do
     Query.ExecSQL;  // 10000 op√©rations !
   FDConnection1.Commit;
   ```

## Test des transactions

### Simuler une erreur pour tester le Rollback

```pascal
procedure TesterRollback;
begin
  FDConnection1.StartTransaction;
  try
    // Op√©ration 1
    Query1.SQL.Text := 'UPDATE comptes SET solde = solde - 100 WHERE id = 1';
    Query1.ExecSQL;

    // Afficher le solde temporaire (dans la transaction)
    Query2.SQL.Text := 'SELECT solde FROM comptes WHERE id = 1';
    Query2.Open;
    ShowMessage('Solde temporaire : ' + Query2.FieldByName('solde').AsString);
    Query2.Close;

    // Simuler une erreur
    raise Exception.Create('Erreur simul√©e pour tester le rollback');

    FDConnection1.Commit;  // Cette ligne ne sera jamais atteinte
  except
    on E: Exception do
    begin
      FDConnection1.Rollback;
      ShowMessage('Transaction annul√©e : ' + E.Message);
    end;
  end;

  // V√©rifier que le rollback a fonctionn√©
  Query2.SQL.Text := 'SELECT solde FROM comptes WHERE id = 1';
  Query2.Open;
  ShowMessage('Solde apr√®s rollback : ' + Query2.FieldByName('solde').AsString);
end;
```

## Logging des transactions

Pour d√©boguer, enregistrez les transactions :

```pascal
procedure LogTransaction(const Action, Details: string);
var
  F: TextFile;
begin
  AssignFile(F, 'transactions.log');
  if FileExists('transactions.log') then
    Append(F)
  else
    Rewrite(F);
  try
    WriteLn(F, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' - ' +
               Action + ' - ' + Details);
  finally
    CloseFile(F);
  end;
end;

// Utilisation
FDConnection1.StartTransaction;
LogTransaction('START', 'Transaction de transfert');
try
  Query.ExecSQL;
  FDConnection1.Commit;
  LogTransaction('COMMIT', 'Transfert r√©ussi');
except
  FDConnection1.Rollback;
  LogTransaction('ROLLBACK', 'Erreur : ' + Exception(ExceptObject).Message);
  raise;
end;
```

## Transactions automatiques vs explicites

### Mode automatique (par d√©faut)

Par d√©faut, **chaque requ√™te est automatiquement dans sa propre transaction** :

```pascal
// Commit automatique apr√®s chaque ExecSQL
Query1.ExecSQL;  // Transaction automatique : START + COMMIT
Query2.ExecSQL;  // Transaction automatique : START + COMMIT
```

### Mode explicite (recommand√© pour op√©rations multiples)

```pascal
// Transaction explicite pour grouper plusieurs op√©rations
FDConnection1.StartTransaction;
try
  Query1.ExecSQL;  // Fait partie de la m√™me transaction
  Query2.ExecSQL;  // Fait partie de la m√™me transaction
  FDConnection1.Commit;  // Un seul COMMIT pour tout
except
  FDConnection1.Rollback;
end;
```

## R√©sum√©

### Quand utiliser les transactions ?

‚úÖ **OUI - Utilisez des transactions pour :**
- Op√©rations multiples qui doivent √™tre coh√©rentes
- Transferts d'argent, de stock
- Cr√©ation de commandes complexes
- Suppressions en cascade
- Toute op√©ration o√π un √©chec partiel serait probl√©matique

‚ùå **NON - Transaction inutile pour :**
- Une seule op√©ration simple (SELECT, INSERT unique)
- Op√©rations de lecture seule
- Op√©rations ind√©pendantes

### Les 3 r√®gles d'or

1. **Atomicit√©** : Tout ou rien
2. **Rollback syst√©matique** en cas d'erreur
3. **Transactions courtes** pour √©viter les blocages

### Checklist de s√©curit√©

‚úÖ Toujours utiliser `try...except`
‚úÖ Toujours appeler `Rollback` en cas d'erreur
‚úÖ V√©rifier `RowsAffected` apr√®s chaque op√©ration
‚úÖ Valider les donn√©es avant la transaction
‚úÖ Garder les transactions courtes
‚úÖ Utiliser les contraintes de base de donn√©es
‚úÖ G√©rer les erreurs de cl√© √©trang√®re
‚úÖ Logger les transactions importantes

## Prochaines √©tapes

Vous ma√Ætrisez maintenant les transactions et l'int√©grit√© des donn√©es ! Dans les sections suivantes, nous verrons :

1. Comment utiliser DataSets et DataSources pour lier les donn√©es
2. Comment cr√©er des contr√¥les li√©s aux donn√©es
3. Comment utiliser Live Bindings
4. Comment cr√©er une architecture en couches

Avec ces connaissances, vous pouvez cr√©er des applications fiables qui garantissent la coh√©rence de vos donn√©es dans toutes les situations !

‚è≠Ô∏è [DataSets et DataSources](/08-acces-aux-bases-de-donnees-mysql-mariadb/06-datasets-et-datasources.md)
