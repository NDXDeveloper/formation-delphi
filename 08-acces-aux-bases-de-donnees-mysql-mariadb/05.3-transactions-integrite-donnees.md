# 8.5.3 Transactions et int√©grit√© des donn√©es

üîù Retour √† la [Table des mati√®res](/SOMMAIRE.md)

L'int√©grit√© des donn√©es est un aspect fondamental des applications de gestion. Les transactions sont un m√©canisme essentiel pour garantir cette int√©grit√©, en vous permettant de regrouper plusieurs op√©rations en une seule unit√© logique qui r√©ussit enti√®rement ou √©choue enti√®rement. Dans cette section, nous allons explorer comment utiliser les transactions dans Delphi avec MySQL/MariaDB.

## Comprendre les transactions

### Qu'est-ce qu'une transaction ?

Une transaction est un ensemble d'op√©rations SQL qui sont trait√©es comme une unit√© atomique, indivisible. Soit toutes les op√©rations r√©ussissent, soit aucune n'est appliqu√©e. Ce concept est souvent r√©sum√© par l'acronyme ACID :

- **A**tomicit√© : Une transaction est une unit√© indivisible - tout ou rien.
- **C**oh√©rence : Une transaction fait passer la base de donn√©es d'un √©tat coh√©rent √† un autre.
- **I**solation : Les transactions s'ex√©cutent comme si elles √©taient seules dans le syst√®me.
- **D**urabilit√© : Les modifications effectu√©es par une transaction sont permanentes.

### Exemple concret

Imaginez que vous d√©veloppez un syst√®me de gestion de stock et de facturation. Lorsqu'une vente est finalis√©e, vous devez :
1. Cr√©er une facture
2. Ajouter les d√©tails des articles vendus
3. D√©duire les quantit√©s du stock

Ces trois op√©rations doivent √™tre r√©alis√©es ensemble. Si l'une d'elles √©choue (par exemple, si le stock est insuffisant), vous ne voulez pas qu'une facture soit cr√©√©e sans les d√©tails correspondants, ou que le stock soit modifi√© sans qu'une facture soit enregistr√©e.

## Les bases des transactions dans Delphi

FireDAC rend l'utilisation des transactions tr√®s simple. Voici la structure de base :

```delphi
// D√©marrer une transaction
FDConnection1.StartTransaction;

try
  // Ex√©cuter vos op√©rations SQL ici...

  // Si tout s'est bien pass√©, valider les modifications
  FDConnection1.Commit;
except
  // En cas d'erreur, annuler toutes les modifications
  FDConnection1.Rollback;

  // Relancer l'exception ou la g√©rer
  raise;
end;
```

## Exemple simple de transaction

Voici un exemple complet qui montre comment utiliser les transactions pour g√©rer une vente :

```delphi
procedure TForm1.EnregistrerVente(ClientID: Integer; Articles: TArray<TArticleVente>);
var
  Query: TFDQuery;
  FactureID: Integer;
  i: Integer;
begin
  if Length(Articles) = 0 then
  begin
    ShowMessage('Aucun article √† enregistrer.');
    Exit;
  end;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // D√©marrer une transaction
    FDConnection1.StartTransaction;
    try
      // 1. Cr√©er la facture
      Query.SQL.Text :=
        'INSERT INTO factures (client_id, date_facture, total) ' +
        'VALUES (:client_id, NOW(), :total)';

      Query.ParamByName('client_id').AsInteger := ClientID;

      // Calculer le total
      var Total: Double := 0;
      for i := 0 to High(Articles) do
        Total := Total + Articles[i].Prix * Articles[i].Quantite;

      Query.ParamByName('total').AsFloat := Total;
      Query.ExecSQL;

      // R√©cup√©rer l'ID de la facture cr√©√©e
      Query.SQL.Text := 'SELECT LAST_INSERT_ID() AS id';
      Query.Open;
      FactureID := Query.FieldByName('id').AsInteger;
      Query.Close;

      // 2. Ajouter les d√©tails des articles
      for i := 0 to High(Articles) do
      begin
        Query.SQL.Text :=
          'INSERT INTO facture_details (facture_id, produit_id, quantite, prix_unitaire) ' +
          'VALUES (:facture_id, :produit_id, :quantite, :prix_unitaire)';

        Query.ParamByName('facture_id').AsInteger := FactureID;
        Query.ParamByName('produit_id').AsInteger := Articles[i].ProduitID;
        Query.ParamByName('quantite').AsInteger := Articles[i].Quantite;
        Query.ParamByName('prix_unitaire').AsFloat := Articles[i].Prix;

        Query.ExecSQL;

        // 3. Mettre √† jour le stock
        Query.SQL.Text :=
          'UPDATE produits ' +
          'SET stock = stock - :quantite ' +
          'WHERE id = :produit_id AND stock >= :quantite';

        Query.ParamByName('quantite').AsInteger := Articles[i].Quantite;
        Query.ParamByName('produit_id').AsInteger := Articles[i].ProduitID;

        Query.ExecSQL;

        // V√©rifier si le stock a √©t√© mis √† jour (suffisant)
        if Query.RowsAffected = 0 then
        begin
          // R√©cup√©rer le nom du produit pour le message d'erreur
          Query.SQL.Text := 'SELECT nom, stock FROM produits WHERE id = :id';
          Query.ParamByName('id').AsInteger := Articles[i].ProduitID;
          Query.Open;

          var NomProduit := Query.FieldByName('nom').AsString;
          var StockActuel := Query.FieldByName('stock').AsInteger;

          raise Exception.CreateFmt(
            'Stock insuffisant pour "%s". Stock disponible : %d, Quantit√© demand√©e : %d',
            [NomProduit, StockActuel, Articles[i].Quantite]
          );
        end;
      end;

      // Si nous arrivons ici, tout s'est bien pass√©, valider la transaction
      FDConnection1.Commit;

      ShowMessage(Format('Vente enregistr√©e avec succ√®s ! Facture n¬∞%d', [FactureID]));
    except
      on E: Exception do
      begin
        // Annuler toutes les modifications en cas d'erreur
        FDConnection1.Rollback;

        ShowMessage('Erreur lors de l''enregistrement de la vente : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;
```

Dans cet exemple :
1. Nous cr√©ons d'abord la facture principale
2. Nous ajoutons les d√©tails des articles vendus
3. Nous mettons √† jour le stock pour chaque article

Si l'une de ces √©tapes √©choue (par exemple, si le stock est insuffisant), la transaction est annul√©e et aucune modification n'est appliqu√©e.

## Transactions imbriqu√©es

MySQL ne prend pas en charge les transactions imbriqu√©es directement, mais FireDAC offre une √©mulation qui peut √™tre utile. Cependant, il faut comprendre que tous les rollbacks reviennent au d√©but de la transaction principale.

```delphi
procedure TForm1.TesterTransactionsImbriquees;
begin
  FDConnection1.StartTransaction;  // Transaction principale
  try
    FDQuery1.SQL.Text := 'INSERT INTO clients (nom) VALUES (''Client 1'')';
    FDQuery1.ExecSQL;

    FDConnection1.StartTransaction;  // Transaction "imbriqu√©e" (√©mul√©e)
    try
      FDQuery1.SQL.Text := 'INSERT INTO clients (nom) VALUES (''Client 2'')';
      FDQuery1.ExecSQL;

      // Simuler une erreur
      // raise Exception.Create('Erreur simul√©e');

      FDConnection1.Commit;  // Commit de la transaction "imbriqu√©e"
    except
      FDConnection1.Rollback;  // Rollback de la transaction "imbriqu√©e"
      // Note : Cela n'annule que les modifications de la transaction "imbriqu√©e"
      // Les modifications de la transaction principale sont toujours en attente
    end;

    FDQuery1.SQL.Text := 'INSERT INTO clients (nom) VALUES (''Client 3'')';
    FDQuery1.ExecSQL;

    FDConnection1.Commit;  // Commit de la transaction principale
  except
    FDConnection1.Rollback;  // Rollback de la transaction principale
    // Cela annule TOUTES les modifications, y compris celles des transactions "imbriqu√©es"
  end;
end;
```

## Isolation des transactions

Le niveau d'isolation d√©termine comment les transactions interagissent les unes avec les autres. MySQL propose diff√©rents niveaux d'isolation :

- **READ UNCOMMITTED** : Les transactions peuvent voir les modifications non valid√©es d'autres transactions (lecture sale).
- **READ COMMITTED** : Les transactions ne peuvent voir que les modifications valid√©es d'autres transactions.
- **REPEATABLE READ** (par d√©faut dans MySQL) : Les transactions ne peuvent voir que les modifications valid√©es d'autres transactions, et les requ√™tes donnent les m√™mes r√©sultats dans une transaction.
- **SERIALIZABLE** : Les transactions sont compl√®tement isol√©es les unes des autres.

Vous pouvez modifier le niveau d'isolation avec :

```delphi
// D√©finir le niveau d'isolation globalement
FDConnection1.TxOptions.Isolation := xiReadCommitted;

// Ou pour une transaction sp√©cifique
FDConnection1.StartTransaction;
FDConnection1.Transaction.IsolationLevel := xiSerializable;
```

## Contr√¥ler les contraintes d'int√©grit√©

Les contraintes d'int√©grit√© sont des r√®gles qui garantissent la validit√© des donn√©es. MySQL/MariaDB offre plusieurs types de contraintes :

### 1. Cl√©s primaires

Les cl√©s primaires identifient de fa√ßon unique chaque enregistrement dans une table.

```sql
CREATE TABLE clients (
  id INT AUTO_INCREMENT PRIMARY KEY,
  nom VARCHAR(100) NOT NULL
);
```

### 2. Cl√©s √©trang√®res

Les cl√©s √©trang√®res maintiennent l'int√©grit√© r√©f√©rentielle entre deux tables.

```sql
CREATE TABLE commandes (
  id INT AUTO_INCREMENT PRIMARY KEY,
  client_id INT NOT NULL,
  date_commande DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (client_id) REFERENCES clients(id)
);
```

### 3. Contraintes d'unicit√©

Les contraintes d'unicit√© garantissent qu'une valeur n'appara√Æt qu'une seule fois dans une colonne.

```sql
CREATE TABLE produits (
  id INT AUTO_INCREMENT PRIMARY KEY,
  reference VARCHAR(20) NOT NULL UNIQUE,
  nom VARCHAR(100) NOT NULL
);
```

### 4. Contraintes de v√©rification (CHECK)

√Ä partir de MySQL 8.0.16, vous pouvez utiliser les contraintes CHECK pour valider les valeurs des colonnes.

```sql
CREATE TABLE produits (
  id INT AUTO_INCREMENT PRIMARY KEY,
  nom VARCHAR(100) NOT NULL,
  prix DECIMAL(10,2) CHECK (prix >= 0),
  stock INT CHECK (stock >= 0)
);
```

## Gestion des erreurs de contraintes dans Delphi

Lorsque vous violez une contrainte, MySQL g√©n√®re une erreur. Voici comment g√©rer ces erreurs dans votre code Delphi :

```delphi
procedure TForm1.AjouterProduitAvecGestionErreurs(const Reference, Nom: string; Prix: Double);
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;
    Query.SQL.Text :=
      'INSERT INTO produits (reference, nom, prix) ' +
      'VALUES (:reference, :nom, :prix)';

    Query.ParamByName('reference').AsString := Reference;
    Query.ParamByName('nom').AsString := Nom;
    Query.ParamByName('prix').AsFloat := Prix;

    try
      Query.ExecSQL;
      ShowMessage('Produit ajout√© avec succ√®s !');
    except
      on E: Exception do
      begin
        // Analyser le message d'erreur pour d√©terminer le type de violation
        var ErrorMsg := LowerCase(E.Message);

        if Pos('duplicate', ErrorMsg) > 0 then
        begin
          if Pos('reference', ErrorMsg) > 0 then
            ShowMessage('Un produit avec cette r√©f√©rence existe d√©j√†.')
          else
            ShowMessage('Violation de contrainte d''unicit√© : ' + E.Message);
        end
        else if Pos('foreign key', ErrorMsg) > 0 then
          ShowMessage('Violation de cl√© √©trang√®re : la r√©f√©rence n''existe pas dans la table parente.')
        else if Pos('check', ErrorMsg) > 0 then
          ShowMessage('Violation de contrainte CHECK : ' + E.Message)
        else
          ShowMessage('Erreur lors de l''ajout du produit : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;
```

## Transactions et performances

Les transactions am√©liorent l'int√©grit√© des donn√©es, mais peuvent aussi impacter les performances. Voici quelques conseils :

### 1. Gardez les transactions aussi courtes que possible

Plus une transaction est longue, plus elle maintient des verrous sur les tables, ce qui peut affecter les autres utilisateurs.

```delphi
// Pr√©f√©rez ceci :
for i := 0 to 9 do
begin
  FDConnection1.StartTransaction;
  try
    // Op√©rations pour un lot de donn√©es
    FDConnection1.Commit;
  except
    FDConnection1.Rollback;
    raise;
  end;
end;

// √Ä ceci :
FDConnection1.StartTransaction;
try
  for i := 0 to 9 do
  begin
    // Op√©rations pour un lot de donn√©es
  end;
  FDConnection1.Commit;
except
  FDConnection1.Rollback;
  raise;
end;
```

### 2. Utilisez les transactions en batch pour les op√©rations multiples

Pour ins√©rer, mettre √† jour ou supprimer de nombreux enregistrements, utilisez les transactions en mode batch :

```delphi
procedure TForm1.ImporterProduitsMassifs(Produits: TArray<TProduit>);
var
  Query: TFDQuery;
  i, BatchSize, LotActuel: Integer;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;
    Query.SQL.Text :=
      'INSERT INTO produits (reference, nom, prix, stock) ' +
      'VALUES (:reference, :nom, :prix, :stock)';

    // Configurer le mode batch
    BatchSize := 100;
    Query.Params.ArraySize := BatchSize;

    FDConnection1.StartTransaction;
    try
      LotActuel := 0;

      for i := 0 to High(Produits) do
      begin
        // Remplir le batch
        Query.ParamByName('reference').AsStrings[LotActuel] := Produits[i].Reference;
        Query.ParamByName('nom').AsStrings[LotActuel] := Produits[i].Nom;
        Query.ParamByName('prix').AsFloats[LotActuel] := Produits[i].Prix;
        Query.ParamByName('stock').AsIntegers[LotActuel] := Produits[i].Stock;

        Inc(LotActuel);

        // Si le batch est plein ou c'est le dernier √©l√©ment, ex√©cuter
        if (LotActuel = BatchSize) or (i = High(Produits)) then
        begin
          if LotActuel > 0 then
          begin
            Query.Execute(LotActuel, 0);
            LotActuel := 0;
          end;
        end;
      end;

      FDConnection1.Commit;
    except
      FDConnection1.Rollback;
      raise;
    end;
  finally
    Query.Free;
  end;
end;
```

## Exemple complet : Gestion de transfert de stock

Voici un exemple plus complet qui montre comment g√©rer un transfert de stock entre deux entrep√¥ts, en utilisant des transactions pour garantir l'int√©grit√© des donn√©es :

```delphi
procedure TForm1.TransfererStock(ProduitID, QuantiteATransferer, EntrepotSourceID,
                               EntrepotDestinationID: Integer);
var
  Query: TFDQuery;
  StockDisponible: Integer;
begin
  if QuantiteATransferer <= 0 then
  begin
    ShowMessage('La quantit√© √† transf√©rer doit √™tre positive.');
    Exit;
  end;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection1;

    // V√©rifier le stock disponible dans l'entrep√¥t source
    Query.SQL.Text :=
      'SELECT stock FROM stocks_entrepot ' +
      'WHERE produit_id = :produit_id AND entrepot_id = :entrepot_id';

    Query.ParamByName('produit_id').AsInteger := ProduitID;
    Query.ParamByName('entrepot_id').AsInteger := EntrepotSourceID;
    Query.Open;

    if Query.IsEmpty then
    begin
      ShowMessage('Le produit n''existe pas dans l''entrep√¥t source.');
      Exit;
    end;

    StockDisponible := Query.FieldByName('stock').AsInteger;

    if StockDisponible < QuantiteATransferer then
    begin
      ShowMessage(Format('Stock insuffisant. Disponible : %d, Demand√© : %d',
        [StockDisponible, QuantiteATransferer]));
      Exit;
    end;

    // Tout est OK, d√©marrer une transaction pour le transfert
    FDConnection1.StartTransaction;
    try
      // 1. R√©duire le stock dans l'entrep√¥t source
      Query.SQL.Text :=
        'UPDATE stocks_entrepot ' +
        'SET stock = stock - :quantite ' +
        'WHERE produit_id = :produit_id AND entrepot_id = :entrepot_id';

      Query.ParamByName('quantite').AsInteger := QuantiteATransferer;
      Query.ParamByName('produit_id').AsInteger := ProduitID;
      Query.ParamByName('entrepot_id').AsInteger := EntrepotSourceID;

      Query.ExecSQL;

      // 2. Augmenter le stock dans l'entrep√¥t destination (ou cr√©er l'enregistrement)
      // D'abord, v√©rifier si le produit existe d√©j√† dans l'entrep√¥t destination
      Query.SQL.Text :=
        'SELECT id FROM stocks_entrepot ' +
        'WHERE produit_id = :produit_id AND entrepot_id = :entrepot_id';

      Query.ParamByName('produit_id').AsInteger := ProduitID;
      Query.ParamByName('entrepot_id').AsInteger := EntrepotDestinationID;
      Query.Open;

      if Query.IsEmpty then
      begin
        // Le produit n'existe pas encore dans cet entrep√¥t, cr√©er l'enregistrement
        Query.SQL.Text :=
          'INSERT INTO stocks_entrepot (produit_id, entrepot_id, stock) ' +
          'VALUES (:produit_id, :entrepot_id, :stock)';

        Query.ParamByName('produit_id').AsInteger := ProduitID;
        Query.ParamByName('entrepot_id').AsInteger := EntrepotDestinationID;
        Query.ParamByName('stock').AsInteger := QuantiteATransferer;
      end
      else
      begin
        // Le produit existe d√©j√†, mettre √† jour le stock
        Query.SQL.Text :=
          'UPDATE stocks_entrepot ' +
          'SET stock = stock + :quantite ' +
          'WHERE produit_id = :produit_id AND entrepot_id = :entrepot_id';

        Query.ParamByName('quantite').AsInteger := QuantiteATransferer;
        Query.ParamByName('produit_id').AsInteger := ProduitID;
        Query.ParamByName('entrepot_id').AsInteger := EntrepotDestinationID;
      end;

      Query.ExecSQL;

      // 3. Enregistrer le mouvement de stock
      Query.SQL.Text :=
        'INSERT INTO mouvements_stock ' +
        '(produit_id, entrepot_source_id, entrepot_destination_id, quantite, date_mouvement, utilisateur_id) ' +
        'VALUES (:produit_id, :source_id, :destination_id, :quantite, NOW(), :utilisateur_id)';

      Query.ParamByName('produit_id').AsInteger := ProduitID;
      Query.ParamByName('source_id').AsInteger := EntrepotSourceID;
      Query.ParamByName('destination_id').AsInteger := EntrepotDestinationID;
      Query.ParamByName('quantite').AsInteger := QuantiteATransferer;
      Query.ParamByName('utilisateur_id').AsInteger := UtilisateurConnecteID; // Supposons que cette variable existe

      Query.ExecSQL;

      // Si tout s'est bien pass√©, valider la transaction
      FDConnection1.Commit;

      ShowMessage(Format('%d unit√©s transf√©r√©es avec succ√®s !', [QuantiteATransferer]));
    except
      on E: Exception do
      begin
        // En cas d'erreur, annuler toutes les modifications
        FDConnection1.Rollback;

        ShowMessage('Erreur lors du transfert de stock : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;
```

## Bonnes pratiques pour les transactions et l'int√©grit√© des donn√©es

1. **Utilisez toujours des transactions** pour les op√©rations qui modifient plusieurs tables ou enregistrements.

2. **Validez les donn√©es avant de les soumettre** √† la base de donn√©es pour √©viter les erreurs de contraintes.

3. **Gardez les transactions aussi courtes que possible** pour minimiser les blocages.

4. **G√©rez correctement les erreurs** et assurez-vous que les transactions sont annul√©es en cas de probl√®me.

5. **Utilisez les contraintes de base de donn√©es** (cl√©s primaires, cl√©s √©trang√®res, contraintes d'unicit√©, etc.) pour garantir l'int√©grit√© des donn√©es.

6. **√âvitez de faire des op√©rations longues ou des appels r√©seau** √† l'int√©rieur d'une transaction.

7. **Testez vos transactions** avec des sc√©narios d'√©chec pour vous assurer qu'elles sont correctement annul√©es.

8. **Utilisez le niveau d'isolation appropri√©** en fonction de vos besoins de coh√©rence et de performance.

9. **Documentez les transactions complexes** pour faciliter la maintenance.

10. **Consid√©rez l'impact sur les autres utilisateurs** si votre application est multi-utilisateurs.

## Conclusion

Les transactions sont un outil puissant pour garantir l'int√©grit√© des donn√©es dans vos applications. En combinant les transactions avec les contraintes de base de donn√©es, vous pouvez cr√©er des applications robustes qui maintiennent la coh√©rence des donn√©es m√™me en cas d'erreur ou de situations impr√©vues.

Dans Delphi avec FireDAC, les transactions sont faciles √† mettre en ≈ìuvre gr√¢ce aux m√©thodes `StartTransaction`, `Commit` et `Rollback`. N'h√©sitez pas √† les utiliser d√®s que vous effectuez des op√©rations qui doivent √™tre trait√©es comme une unit√© indivisible.

---

**√Ä suivre :** 8.6 DataSets et DataSources

‚è≠Ô∏è [DataSets et DataSources](/08-acces-aux-bases-de-donnees-mysql-mariadb/06-datasets-et-datasources.md)
