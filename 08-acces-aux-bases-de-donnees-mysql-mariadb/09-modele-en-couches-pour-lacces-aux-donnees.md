üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.9 Mod√®le en couches pour l'acc√®s aux donn√©es

## Introduction

Lorsque vous cr√©ez une application de base de donn√©es, il est tentant de tout mettre dans le formulaire : la connexion, les requ√™tes, la logique m√©tier, et l'interface utilisateur. Cela fonctionne pour de petites applications, mais devient rapidement **ing√©rable** pour des projets plus importants.

Le **mod√®le en couches** (ou architecture en couches) est une approche qui **s√©pare** les diff√©rentes responsabilit√©s de votre application en modules distincts. C'est une des meilleures pratiques du d√©veloppement logiciel professionnel.

## Pourquoi s√©parer en couches ?

### Le probl√®me de l'approche monolithique

Imaginez un formulaire qui fait tout :

```pascal
// ‚ùå TOUT dans le formulaire - Architecture monolithique
procedure TFormClients.btnSauvegarderClick(Sender: TObject);
begin
  // Connexion √† la base
  FDConnection1.Params.Values['Server'] := 'localhost';
  FDConnection1.Params.Values['Database'] := 'ma_base';
  FDConnection1.Connected := True;

  // Validation m√©tier
  if Trim(editNom.Text) = '' then
    raise Exception.Create('Nom obligatoire');
  if Pos('@', editEmail.Text) = 0 then
    raise Exception.Create('Email invalide');
  if CalculerAge(DateNaissance) < 18 then
    raise Exception.Create('Le client doit √™tre majeur');

  // SQL
  FDQuery1.SQL.Text :=
    'INSERT INTO clients (nom, prenom, email, date_naissance) ' +
    'VALUES (:nom, :prenom, :email, :date)';
  FDQuery1.ParamByName('nom').AsString := editNom.Text;
  FDQuery1.ParamByName('prenom').AsString := editPrenom.Text;
  FDQuery1.ParamByName('email').AsString := editEmail.Text;
  FDQuery1.ParamByName('date').AsDate := DateNaissance;
  FDQuery1.ExecSQL;

  // Mise √† jour de l'interface
  ChargerClients;
  ShowMessage('Client sauvegard√©');
end;
```

**Probl√®mes :**
- üî¥ Code **dupliqu√©** dans chaque formulaire
- üî¥ **Difficile √† tester** (tout est li√© √† l'interface)
- üî¥ **Impossible de r√©utiliser** la logique
- üî¥ **Modification complexe** : changer la base touche tous les formulaires
- üî¥ **Maintenance cauchemardesque** pour de grandes applications

### L'approche en couches

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     COUCHE PR√âSENTATION (UI)            ‚îÇ
‚îÇ  FormClients, FormCommandes, etc.       ‚îÇ
‚îÇ  - Affichage                            ‚îÇ
‚îÇ  - Interaction utilisateur              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     COUCHE M√âTIER (Business Logic)      ‚îÇ
‚îÇ  TClientManager, TCommandeManager       ‚îÇ
‚îÇ  - R√®gles m√©tier                        ‚îÇ
‚îÇ  - Validation                           ‚îÇ
‚îÇ  - Calculs                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     COUCHE DONN√âES (Data Access)        ‚îÇ
‚îÇ  TDataModule, TClientDAO                ‚îÇ
‚îÇ  - Connexion base de donn√©es            ‚îÇ
‚îÇ  - Requ√™tes SQL                         ‚îÇ
‚îÇ  - Gestion CRUD                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     BASE DE DONN√âES                     ‚îÇ
‚îÇ  MySQL/MariaDB                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Avantages :**
- ‚úÖ Code **organis√©** et **maintenable**
- ‚úÖ Facilement **testable** (chaque couche s√©par√©ment)
- ‚úÖ **R√©utilisable** (m√™me logique dans plusieurs formulaires)
- ‚úÖ **√âvolutif** (changer une couche sans toucher les autres)
- ‚úÖ **Travail en √©quipe** facilit√© (chacun sur sa couche)

## Les trois couches principales

### 1. Couche Pr√©sentation (UI Layer)

**Responsabilit√©s :**
- Afficher les donn√©es
- G√©rer les interactions utilisateur (clics, saisies)
- Mettre √† jour l'interface

**Ce qu'elle NE fait PAS :**
- ‚ùå Validation m√©tier complexe
- ‚ùå Connexion directe √† la base
- ‚ùå Logique de calcul

**Composants :**
- Formulaires (TForm)
- Contr√¥les visuels (Button, Edit, Grid)
- DataSources et contr√¥les DB

### 2. Couche M√©tier (Business Logic Layer)

**Responsabilit√©s :**
- Impl√©menter les **r√®gles m√©tier**
- **Valider** les donn√©es
- Effectuer les **calculs** complexes
- Coordonner les op√©rations

**Ce qu'elle NE fait PAS :**
- ‚ùå Affichage (pas de ShowMessage)
- ‚ùå SQL direct
- ‚ùå Gestion de l'interface

**Composants :**
- Classes m√©tier (TClientManager, TFactureManager)
- Objets m√©tier (TClient, TCommande)
- Services (TEmailService, TReportService)

### 3. Couche Donn√©es (Data Access Layer)

**Responsabilit√©s :**
- **Connexion** √† la base de donn√©es
- Ex√©cution des **requ√™tes SQL**
- Op√©rations **CRUD**
- Gestion des **transactions**

**Ce qu'elle NE fait PAS :**
- ‚ùå Validation m√©tier
- ‚ùå Affichage
- ‚ùå Logique complexe

**Composants :**
- DataModule (TDataModule)
- Classes DAO (Data Access Object)
- Composants FireDAC

## Mise en pratique : Le DataModule

Le **DataModule** est le composant id√©al pour impl√©menter la couche d'acc√®s aux donn√©es.

### Qu'est-ce qu'un DataModule ?

Un **DataModule** est un conteneur **non-visuel** pour les composants de donn√©es. C'est comme un formulaire, mais sans interface graphique.

### Cr√©er un DataModule

#### √âtape 1 : Cr√©er le DataModule

1. **Fichier** ‚Üí **Nouveau** ‚Üí **Autre...**
2. Dans la cat√©gorie **Delphi Files**, s√©lectionnez **DataModule**
3. Nommez-le : `dmDatabase` (Data Module Database)
4. Sauvegardez : `uDmDatabase.pas`

#### √âtape 2 : Ajouter les composants FireDAC

Sur le DataModule, placez :

- **TFDConnection** : la connexion principale
- **TFDPhysMySQLDriverLink** : le pilote MySQL
- **TFDQuery** pour chaque entit√© (Clients, Commandes, etc.)
- **TDataSource** correspondants

```pascal
unit uDmDatabase;

interface

uses
  System.SysUtils, System.Classes,
  FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Error,
  FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def, FireDAC.Stan.Pool,
  FireDAC.Stan.Async, FireDAC.Phys, FireDAC.Phys.MySQL, FireDAC.Phys.MySQLDef,
  FireDAC.VCLUI.Wait, FireDAC.Comp.Client, Data.DB, FireDAC.Stan.Param,
  FireDAC.DatS, FireDAC.DApt.Intf, FireDAC.DApt, FireDAC.Comp.DataSet;

type
  TdmDatabase = class(TDataModule)
    FDConnection1: TFDConnection;
    FDPhysMySQLDriverLink1: TFDPhysMySQLDriverLink;

    // Queries
    FDQueryClients: TFDQuery;
    FDQueryCommandes: TFDQuery;
    FDQueryProduits: TFDQuery;

    // DataSources
    DataSourceClients: TDataSource;
    DataSourceCommandes: TDataSource;
    DataSourceProduits: TDataSource;

    procedure DataModuleCreate(Sender: TObject);
    procedure DataModuleDestroy(Sender: TObject);
  private
    { D√©clarations priv√©es }
    procedure ConfigurerConnexion;
  public
    { D√©clarations publiques }
    // M√©thodes d'acc√®s aux donn√©es
    procedure ConnecterBase;
    procedure DeconnecterBase;

    // Clients
    procedure ChargerClients;
    function AjouterClient(const Nom, Prenom, Email: string): Integer;
    procedure ModifierClient(ID: Integer; const Nom, Prenom, Email: string);
    procedure SupprimerClient(ID: Integer);

    // Commandes
    procedure ChargerCommandes(ClientID: Integer);
    function CreerCommande(ClientID: Integer; const Articles: TArray<Integer>): Integer;
  end;

var
  dmDatabase: TdmDatabase;

implementation

{%CLASSGROUP 'Vcl.Controls.TControl'}

{$R *.dfm}

procedure TdmDatabase.DataModuleCreate(Sender: TObject);
begin
  ConfigurerConnexion;
  ConnecterBase;
end;

procedure TdmDatabase.DataModuleDestroy(Sender: TObject);
begin
  DeconnecterBase;
end;

procedure TdmDatabase.ConfigurerConnexion;
begin
  FDConnection1.Params.Clear;
  FDConnection1.Params.Add('DriverID=MySQL');
  FDConnection1.Params.Add('Server=localhost');
  FDConnection1.Params.Add('Port=3306');
  FDConnection1.Params.Add('Database=ma_gestion');
  FDConnection1.Params.Add('User_Name=delphi_user');
  FDConnection1.Params.Add('Password=MonMotDePasse');
  FDConnection1.Params.Add('CharacterSet=utf8mb4');
  FDConnection1.LoginPrompt := False;
end;

procedure TdmDatabase.ConnecterBase;
begin
  if not FDConnection1.Connected then
    FDConnection1.Connected := True;
end;

procedure TdmDatabase.DeconnecterBase;
begin
  if FDConnection1.Connected then
    FDConnection1.Connected := False;
end;

// ‚îÄ‚îÄ‚îÄ CLIENTS ‚îÄ‚îÄ‚îÄ

procedure TdmDatabase.ChargerClients;
begin
  FDQueryClients.Close;
  FDQueryClients.SQL.Text :=
    'SELECT id, nom, prenom, email, telephone, actif ' +
    'FROM clients ' +
    'WHERE actif = TRUE ' +
    'ORDER BY nom, prenom';
  FDQueryClients.Open;
end;

function TdmDatabase.AjouterClient(const Nom, Prenom, Email: string): Integer;
begin
  FDQueryClients.SQL.Text :=
    'INSERT INTO clients (nom, prenom, email, date_creation) ' +
    'VALUES (:nom, :prenom, :email, NOW())';

  FDQueryClients.ParamByName('nom').AsString := Nom;
  FDQueryClients.ParamByName('prenom').AsString := Prenom;
  FDQueryClients.ParamByName('email').AsString := Email;

  FDQueryClients.ExecSQL;

  // Retourner l'ID auto-g√©n√©r√©
  Result := FDConnection1.GetLastAutoGenValue('clients');
end;

procedure TdmDatabase.ModifierClient(ID: Integer; const Nom, Prenom, Email: string);
begin
  FDQueryClients.SQL.Text :=
    'UPDATE clients SET ' +
    '  nom = :nom, ' +
    '  prenom = :prenom, ' +
    '  email = :email ' +
    'WHERE id = :id';

  FDQueryClients.ParamByName('nom').AsString := Nom;
  FDQueryClients.ParamByName('prenom').AsString := Prenom;
  FDQueryClients.ParamByName('email').AsString := Email;
  FDQueryClients.ParamByName('id').AsInteger := ID;

  FDQueryClients.ExecSQL;
end;

procedure TdmDatabase.SupprimerClient(ID: Integer);
begin
  // Suppression logique
  FDQueryClients.SQL.Text := 'UPDATE clients SET actif = FALSE WHERE id = :id';
  FDQueryClients.ParamByName('id').AsInteger := ID;
  FDQueryClients.ExecSQL;
end;

// ‚îÄ‚îÄ‚îÄ COMMANDES ‚îÄ‚îÄ‚îÄ

procedure TdmDatabase.ChargerCommandes(ClientID: Integer);
begin
  FDQueryCommandes.Close;
  FDQueryCommandes.SQL.Text :=
    'SELECT id, date_commande, total, statut ' +
    'FROM commandes ' +
    'WHERE client_id = :client_id ' +
    'ORDER BY date_commande DESC';

  FDQueryCommandes.ParamByName('client_id').AsInteger := ClientID;
  FDQueryCommandes.Open;
end;

function TdmDatabase.CreerCommande(ClientID: Integer;
  const Articles: TArray<Integer>): Integer;
var
  i: Integer;
  CommandeID: Integer;
begin
  FDConnection1.StartTransaction;
  try
    // Cr√©er la commande
    FDQueryCommandes.SQL.Text :=
      'INSERT INTO commandes (client_id, date_commande, statut) ' +
      'VALUES (:client_id, NOW(), ''En cours'')';
    FDQueryCommandes.ParamByName('client_id').AsInteger := ClientID;
    FDQueryCommandes.ExecSQL;

    CommandeID := FDConnection1.GetLastAutoGenValue('commandes');

    // Ajouter les articles (code simplifi√©)
    // ... code pour ajouter les articles ...

    FDConnection1.Commit;
    Result := CommandeID;
  except
    FDConnection1.Rollback;
    raise;
  end;
end;

end.
```

### Utiliser le DataModule dans un formulaire

```pascal
unit uFormClients;

interface

uses
  Winapi.Windows, System.SysUtils, System.Classes, Vcl.Forms,
  Vcl.Controls, Vcl.StdCtrls, Vcl.DBCtrls, Vcl.Grids, Vcl.DBGrids,
  uDmDatabase;  // ‚Üê Ajouter la r√©f√©rence au DataModule

type
  TFormClients = class(TForm)
    DBGrid1: TDBGrid;
    btnNouveau: TButton;
    btnModifier: TButton;
    btnSupprimer: TButton;
    procedure FormCreate(Sender: TObject);
    procedure btnNouveauClick(Sender: TObject);
  private
    { D√©clarations priv√©es }
  public
    { D√©clarations publiques }
  end;

var
  FormClients: TFormClients;

implementation

{$R *.dfm}

procedure TFormClients.FormCreate(Sender: TObject);
begin
  // Lier au DataModule
  DBGrid1.DataSource := dmDatabase.DataSourceClients;

  // Charger les donn√©es
  dmDatabase.ChargerClients;
end;

procedure TFormClients.btnNouveauClick(Sender: TObject);
var
  NouveauID: Integer;
begin
  // Appeler le DataModule pour ajouter
  NouveauID := dmDatabase.AjouterClient('Nouveau', 'Client', 'nouveau@email.fr');

  ShowMessage('Client cr√©√© avec l''ID : ' + IntToStr(NouveauID));

  // Recharger
  dmDatabase.ChargerClients;
end;

end.
```

**Important :** Le DataModule doit √™tre cr√©√© **en premier** dans le projet.

### Configuration dans le projet

Dans le fichier projet (`.dpr`), assurez-vous que le DataModule est cr√©√© avant les formulaires :

```pascal
program GestionClients;

uses
  Vcl.Forms,
  uDmDatabase in 'uDmDatabase.pas' {dmDatabase: TDataModule},  // ‚Üê En premier !
  uFormClients in 'uFormClients.pas' {FormClients};

{$R *.res}

begin
  Application.Initialize;
  Application.MainFormOnTaskbar := True;

  // Cr√©er le DataModule en premier
  Application.CreateForm(TdmDatabase, dmDatabase);

  // Puis les formulaires
  Application.CreateForm(TFormClients, FormClients);

  Application.Run;
end.
```

## Couche M√©tier : Classes de gestion

La couche m√©tier contient la **logique business** et orchestre les op√©rations.

### Cr√©er une classe Manager

```pascal
unit uClientManager;

interface

uses
  System.SysUtils, System.Classes, uDmDatabase;

type
  TClientManager = class
  private
    FDataModule: TdmDatabase;
  public
    constructor Create(ADataModule: TdmDatabase);

    // M√©thodes m√©tier
    function CreerNouveauClient(const Nom, Prenom, Email, Telephone: string): Integer;
    procedure ModifierClient(ID: Integer; const Nom, Prenom, Email, Telephone: string);
    function SupprimerClient(ID: Integer): Boolean;
    function RechercherClients(const Critere: string): Boolean;

    // Validation
    function ValiderEmail(const Email: string): Boolean;
    function ValiderTelephone(const Telephone: string): Boolean;

    // R√®gles m√©tier
    function ClientPeutEtreSupprimer(ClientID: Integer): Boolean;
    function CalculerNombreCommandes(ClientID: Integer): Integer;
  end;

implementation

{ TClientManager }

constructor TClientManager.Create(ADataModule: TdmDatabase);
begin
  inherited Create;
  FDataModule := ADataModule;
end;

function TClientManager.CreerNouveauClient(const Nom, Prenom, Email,
  Telephone: string): Integer;
begin
  // Validation m√©tier
  if Trim(Nom) = '' then
    raise Exception.Create('Le nom est obligatoire');

  if Trim(Prenom) = '' then
    raise Exception.Create('Le pr√©nom est obligatoire');

  if not ValiderEmail(Email) then
    raise Exception.Create('Email invalide');

  if (Telephone <> '') and (not ValiderTelephone(Telephone)) then
    raise Exception.Create('Num√©ro de t√©l√©phone invalide');

  // V√©rifier que l'email n'existe pas d√©j√†
  FDataModule.FDQueryClients.Close;
  FDataModule.FDQueryClients.SQL.Text :=
    'SELECT COUNT(*) AS nb FROM clients WHERE email = :email';
  FDataModule.FDQueryClients.ParamByName('email').AsString := Email;
  FDataModule.FDQueryClients.Open;

  if FDataModule.FDQueryClients.FieldByName('nb').AsInteger > 0 then
    raise Exception.Create('Cet email est d√©j√† utilis√©');

  // Appeler la couche donn√©es
  Result := FDataModule.AjouterClient(Nom, Prenom, Email);

  // Log ou notification (optionnel)
  // LogActivity('Client cr√©√© : ' + Nom + ' ' + Prenom);
end;

procedure TClientManager.ModifierClient(ID: Integer; const Nom, Prenom,
  Email, Telephone: string);
begin
  // Validation
  if Trim(Nom) = '' then
    raise Exception.Create('Le nom est obligatoire');

  if not ValiderEmail(Email) then
    raise Exception.Create('Email invalide');

  // V√©rifier que l'email n'est pas utilis√© par un autre client
  FDataModule.FDQueryClients.Close;
  FDataModule.FDQueryClients.SQL.Text :=
    'SELECT COUNT(*) AS nb FROM clients WHERE email = :email AND id <> :id';
  FDataModule.FDQueryClients.ParamByName('email').AsString := Email;
  FDataModule.FDQueryClients.ParamByName('id').AsInteger := ID;
  FDataModule.FDQueryClients.Open;

  if FDataModule.FDQueryClients.FieldByName('nb').AsInteger > 0 then
    raise Exception.Create('Cet email est d√©j√† utilis√©');

  // Appeler la couche donn√©es
  FDataModule.ModifierClient(ID, Nom, Prenom, Email);
end;

function TClientManager.SupprimerClient(ID: Integer): Boolean;
begin
  Result := False;

  // R√®gle m√©tier : on ne peut pas supprimer un client avec des commandes
  if not ClientPeutEtreSupprimer(ID) then
  begin
    raise Exception.Create(
      'Impossible de supprimer : ce client a des commandes en cours');
  end;

  // Appeler la couche donn√©es
  FDataModule.SupprimerClient(ID);
  Result := True;
end;

function TClientManager.RechercherClients(const Critere: string): Boolean;
begin
  FDataModule.FDQueryClients.Close;
  FDataModule.FDQueryClients.SQL.Text :=
    'SELECT * FROM clients ' +
    'WHERE actif = TRUE ' +
    '  AND (nom LIKE :critere OR prenom LIKE :critere OR email LIKE :critere) ' +
    'ORDER BY nom, prenom';

  FDataModule.FDQueryClients.ParamByName('critere').AsString := '%' + Critere + '%';
  FDataModule.FDQueryClients.Open;

  Result := not FDataModule.FDQueryClients.IsEmpty;
end;

function TClientManager.ValiderEmail(const Email: string): Boolean;
begin
  Result := (Trim(Email) <> '') and
            (Pos('@', Email) > 0) and
            (Pos('.', Email) > Pos('@', Email));
end;

function TClientManager.ValiderTelephone(const Telephone: string): Boolean;
var
  TelNettoy√©: string;
  i: Integer;
begin
  // Enlever les espaces et caract√®res sp√©ciaux
  TelNettoy√© := '';
  for i := 1 to Length(Telephone) do
    if CharInSet(Telephone[i], ['0'..'9']) then
      TelNettoy√© := TelNettoy√© + Telephone[i];

  // V√©rifier la longueur (10 chiffres pour la France)
  Result := Length(TelNettoy√©) = 10;
end;

function TClientManager.ClientPeutEtreSupprimer(ClientID: Integer): Boolean;
var
  NbCommandes: Integer;
begin
  NbCommandes := CalculerNombreCommandes(ClientID);
  Result := NbCommandes = 0;
end;

function TClientManager.CalculerNombreCommandes(ClientID: Integer): Integer;
begin
  FDataModule.FDQueryCommandes.Close;
  FDataModule.FDQueryCommandes.SQL.Text :=
    'SELECT COUNT(*) AS nb FROM commandes WHERE client_id = :id';
  FDataModule.FDQueryCommandes.ParamByName('id').AsInteger := ClientID;
  FDataModule.FDQueryCommandes.Open;

  Result := FDataModule.FDQueryCommandes.FieldByName('nb').AsInteger;
end;

end.
```

### Utiliser le Manager dans le formulaire

```pascal
unit uFormClients;

interface

uses
  System.SysUtils, Vcl.Forms, Vcl.Controls, Vcl.StdCtrls,
  uDmDatabase, uClientManager;  // ‚Üê Ajouter les r√©f√©rences

type
  TFormClients = class(TForm)
    btnNouveau: TButton;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure btnNouveauClick(Sender: TObject);
  private
    FClientManager: TClientManager;
  end;

implementation

{$R *.dfm}

procedure TFormClients.FormCreate(Sender: TObject);
begin
  // Cr√©er le manager
  FClientManager := TClientManager.Create(dmDatabase);
end;

procedure TFormClients.FormDestroy(Sender: TObject);
begin
  // Lib√©rer le manager
  FClientManager.Free;
end;

procedure TFormClients.btnNouveauClick(Sender: TObject);
var
  NouveauID: Integer;
begin
  try
    // Utiliser le manager (pas le DataModule directement !)
    NouveauID := FClientManager.CreerNouveauClient(
      'Nouveau',
      'Client',
      'nouveau@email.fr',
      '0601020304'
    );

    ShowMessage('Client cr√©√© avec succ√®s (ID: ' + IntToStr(NouveauID) + ')');
    dmDatabase.ChargerClients;

  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  end;
end;

end.
```

**Avantage :** Toute la validation et la logique m√©tier est **centralis√©e** dans le Manager, pas dispers√©e dans les formulaires !

## Objets m√©tier (Domain Objects)

Pour une architecture encore plus propre, cr√©ez des **classes m√©tier** qui repr√©sentent vos entit√©s.

### D√©finir une classe m√©tier

```pascal
unit uClient;

interface

uses
  System.SysUtils;

type
  TClient = class
  private
    FID: Integer;
    FNom: string;
    FPrenom: string;
    FEmail: string;
    FTelephone: string;
    FActif: Boolean;
    FDateCreation: TDateTime;
  public
    constructor Create; overload;
    constructor Create(AID: Integer; const ANom, APrenom, AEmail: string); overload;

    // Propri√©t√©s
    property ID: Integer read FID write FID;
    property Nom: string read FNom write FNom;
    property Prenom: string read FPrenom write FPrenom;
    property Email: string read FEmail write FEmail;
    property Telephone: string read FTelephone write FTelephone;
    property Actif: Boolean read FActif write FActif;
    property DateCreation: TDateTime read FDateCreation write FDateCreation;

    // M√©thodes m√©tier
    function NomComplet: string;
    function EstValide: Boolean;
    function ToString: string; override;
  end;

implementation

{ TClient }

constructor TClient.Create;
begin
  inherited Create;
  FActif := True;
  FDateCreation := Now;
end;

constructor TClient.Create(AID: Integer; const ANom, APrenom, AEmail: string);
begin
  Create;
  FID := AID;
  FNom := ANom;
  FPrenom := APrenom;
  FEmail := AEmail;
end;

function TClient.NomComplet: string;
begin
  Result := FPrenom + ' ' + FNom;
end;

function TClient.EstValide: Boolean;
begin
  Result := (Trim(FNom) <> '') and
            (Trim(FPrenom) <> '') and
            (Pos('@', FEmail) > 0);
end;

function TClient.ToString: string;
begin
  Result := Format('%s (ID: %d)', [NomComplet, FID]);
end;

end.
```

### DAO (Data Access Object)

Le **DAO** est responsable de la conversion entre les objets m√©tier et la base de donn√©es.

```pascal
unit uClientDAO;

interface

uses
  System.SysUtils, System.Generics.Collections,
  FireDAC.Comp.Client, uClient, uDmDatabase;

type
  TClientDAO = class
  private
    FDataModule: TdmDatabase;
    function DataSetToClient(DataSet: TFDQuery): TClient;
  public
    constructor Create(ADataModule: TdmDatabase);

    // CRUD
    function Lire(ID: Integer): TClient;
    function LireTous: TObjectList<TClient>;
    function Creer(Client: TClient): Integer;
    procedure Modifier(Client: TClient);
    procedure Supprimer(ID: Integer);

    // Recherches
    function RechercherParEmail(const Email: string): TClient;
    function RechercherParNom(const Nom: string): TObjectList<TClient>;
  end;

implementation

{ TClientDAO }

constructor TClientDAO.Create(ADataModule: TdmDatabase);
begin
  inherited Create;
  FDataModule := ADataModule;
end;

function TClientDAO.DataSetToClient(DataSet: TFDQuery): TClient;
begin
  Result := TClient.Create;
  Result.ID := DataSet.FieldByName('id').AsInteger;
  Result.Nom := DataSet.FieldByName('nom').AsString;
  Result.Prenom := DataSet.FieldByName('prenom').AsString;
  Result.Email := DataSet.FieldByName('email').AsString;
  Result.Telephone := DataSet.FieldByName('telephone').AsString;
  Result.Actif := DataSet.FieldByName('actif').AsBoolean;
  Result.DateCreation := DataSet.FieldByName('date_creation').AsDateTime;
end;

function TClientDAO.Lire(ID: Integer): TClient;
begin
  Result := nil;

  FDataModule.FDQueryClients.Close;
  FDataModule.FDQueryClients.SQL.Text :=
    'SELECT * FROM clients WHERE id = :id';
  FDataModule.FDQueryClients.ParamByName('id').AsInteger := ID;
  FDataModule.FDQueryClients.Open;

  if not FDataModule.FDQueryClients.IsEmpty then
    Result := DataSetToClient(FDataModule.FDQueryClients);
end;

function TClientDAO.LireTous: TObjectList<TClient>;
var
  Client: TClient;
begin
  Result := TObjectList<TClient>.Create(True);  // True = poss√®de les objets

  FDataModule.FDQueryClients.Close;
  FDataModule.FDQueryClients.SQL.Text :=
    'SELECT * FROM clients WHERE actif = TRUE ORDER BY nom, prenom';
  FDataModule.FDQueryClients.Open;

  FDataModule.FDQueryClients.First;
  while not FDataModule.FDQueryClients.Eof do
  begin
    Client := DataSetToClient(FDataModule.FDQueryClients);
    Result.Add(Client);
    FDataModule.FDQueryClients.Next;
  end;
end;

function TClientDAO.Creer(Client: TClient): Integer;
begin
  FDataModule.FDQueryClients.SQL.Text :=
    'INSERT INTO clients (nom, prenom, email, telephone, date_creation) ' +
    'VALUES (:nom, :prenom, :email, :tel, :date)';

  FDataModule.FDQueryClients.ParamByName('nom').AsString := Client.Nom;
  FDataModule.FDQueryClients.ParamByName('prenom').AsString := Client.Prenom;
  FDataModule.FDQueryClients.ParamByName('email').AsString := Client.Email;
  FDataModule.FDQueryClients.ParamByName('tel').AsString := Client.Telephone;
  FDataModule.FDQueryClients.ParamByName('date').AsDateTime := Client.DateCreation;

  FDataModule.FDQueryClients.ExecSQL;

  Result := FDataModule.FDConnection1.GetLastAutoGenValue('clients');
  Client.ID := Result;
end;

procedure TClientDAO.Modifier(Client: TClient);
begin
  FDataModule.FDQueryClients.SQL.Text :=
    'UPDATE clients SET ' +
    '  nom = :nom, ' +
    '  prenom = :prenom, ' +
    '  email = :email, ' +
    '  telephone = :tel ' +
    'WHERE id = :id';

  FDataModule.FDQueryClients.ParamByName('nom').AsString := Client.Nom;
  FDataModule.FDQueryClients.ParamByName('prenom').AsString := Client.Prenom;
  FDataModule.FDQueryClients.ParamByName('email').AsString := Client.Email;
  FDataModule.FDQueryClients.ParamByName('tel').AsString := Client.Telephone;
  FDataModule.FDQueryClients.ParamByName('id').AsInteger := Client.ID;

  FDataModule.FDQueryClients.ExecSQL;
end;

procedure TClientDAO.Supprimer(ID: Integer);
begin
  FDataModule.FDQueryClients.SQL.Text :=
    'UPDATE clients SET actif = FALSE WHERE id = :id';
  FDataModule.FDQueryClients.ParamByName('id').AsInteger := ID;
  FDataModule.FDQueryClients.ExecSQL;
end;

function TClientDAO.RechercherParEmail(const Email: string): TClient;
begin
  Result := nil;

  FDataModule.FDQueryClients.Close;
  FDataModule.FDQueryClients.SQL.Text :=
    'SELECT * FROM clients WHERE email = :email';
  FDataModule.FDQueryClients.ParamByName('email').AsString := Email;
  FDataModule.FDQueryClients.Open;

  if not FDataModule.FDQueryClients.IsEmpty then
    Result := DataSetToClient(FDataModule.FDQueryClients);
end;

function TClientDAO.RechercherParNom(const Nom: string): TObjectList<TClient>;
var
  Client: TClient;
begin
  Result := TObjectList<TClient>.Create(True);

  FDataModule.FDQueryClients.Close;
  FDataModule.FDQueryClients.SQL.Text :=
    'SELECT * FROM clients WHERE nom LIKE :nom ORDER BY nom';
  FDataModule.FDQueryClients.ParamByName('nom').AsString := '%' + Nom + '%';
  FDataModule.FDQueryClients.Open;

  FDataModule.FDQueryClients.First;
  while not FDataModule.FDQueryClients.Eof do
  begin
    Client := DataSetToClient(FDataModule.FDQueryClients);
    Result.Add(Client);
    FDataModule.FDQueryClients.Next;
  end;
end;

end.
```

### Utiliser les objets m√©tier

```pascal
procedure TFormClients.AfficherClients;
var
  DAO: TClientDAO;
  Clients: TObjectList<TClient>;
  Client: TClient;
begin
  DAO := TClientDAO.Create(dmDatabase);
  try
    Clients := DAO.LireTous;
    try
      Memo1.Clear;
      for Client in Clients do
      begin
        Memo1.Lines.Add(Client.ToString);
      end;
    finally
      Clients.Free;  // Lib√®re automatiquement tous les clients
    end;
  finally
    DAO.Free;
  end;
end;

procedure TFormClients.CreerClient;
var
  DAO: TClientDAO;
  Client: TClient;
  NouveauID: Integer;
begin
  Client := TClient.Create;
  try
    // Remplir l'objet
    Client.Nom := 'Dupont';
    Client.Prenom := 'Jean';
    Client.Email := 'jean.dupont@email.fr';
    Client.Telephone := '0601020304';

    // Valider
    if not Client.EstValide then
      raise Exception.Create('Client invalide');

    // Sauvegarder
    DAO := TClientDAO.Create(dmDatabase);
    try
      NouveauID := DAO.Creer(Client);
      ShowMessage('Client cr√©√© avec l''ID : ' + IntToStr(NouveauID));
    finally
      DAO.Free;
    end;
  finally
    Client.Free;
  end;
end;
```

## Organisation des fichiers

### Structure recommand√©e

```
MonProjet/
‚îÇ
‚îú‚îÄ‚îÄ Projet.dpr                  (Fichier projet)
‚îÇ
‚îú‚îÄ‚îÄ Forms/                      (Couche Pr√©sentation)
‚îÇ   ‚îú‚îÄ‚îÄ uFormMain.pas
‚îÇ   ‚îú‚îÄ‚îÄ uFormClients.pas
‚îÇ   ‚îú‚îÄ‚îÄ uFormCommandes.pas
‚îÇ   ‚îî‚îÄ‚îÄ uFormRapports.pas
‚îÇ
‚îú‚îÄ‚îÄ DataModules/                (Couche Donn√©es)
‚îÇ   ‚îú‚îÄ‚îÄ uDmDatabase.pas
‚îÇ   ‚îî‚îÄ‚îÄ uDmConfiguration.pas
‚îÇ
‚îú‚îÄ‚îÄ Business/                   (Couche M√©tier)
‚îÇ   ‚îú‚îÄ‚îÄ Managers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ uClientManager.pas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ uCommandeManager.pas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ uProduitManager.pas
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ       ‚îú‚îÄ‚îÄ uEmailService.pas
‚îÇ       ‚îî‚îÄ‚îÄ uReportService.pas
‚îÇ
‚îú‚îÄ‚îÄ DataAccess/                 (Acc√®s donn√©es)
‚îÇ   ‚îú‚îÄ‚îÄ uClientDAO.pas
‚îÇ   ‚îú‚îÄ‚îÄ uCommandeDAO.pas
‚îÇ   ‚îî‚îÄ‚îÄ uProduitDAO.pas
‚îÇ
‚îú‚îÄ‚îÄ Model/                      (Objets m√©tier)
‚îÇ   ‚îú‚îÄ‚îÄ uClient.pas
‚îÇ   ‚îú‚îÄ‚îÄ uCommande.pas
‚îÇ   ‚îî‚îÄ‚îÄ uProduit.pas
‚îÇ
‚îî‚îÄ‚îÄ Common/                     (Utilitaires communs)
    ‚îú‚îÄ‚îÄ uConstants.pas
    ‚îú‚îÄ‚îÄ uTypes.pas
    ‚îî‚îÄ‚îÄ uUtils.pas
```

## Injection de d√©pendances (niveau interm√©diaire)

Pour une architecture encore plus flexible, utilisez l'**injection de d√©pendances**.

### Principe

Au lieu de cr√©er directement les d√©pendances, on les **injecte** via le constructeur ou des propri√©t√©s.

```pascal
// ‚ùå Sans injection : d√©pendance forte
type
  TClientManager = class
  private
    FDataModule: TdmDatabase;
  public
    constructor Create;  // Cr√©e TdmDatabase √† l'int√©rieur
  end;

// ‚úÖ Avec injection : d√©pendance faible
type
  TClientManager = class
  private
    FDataModule: TdmDatabase;
  public
    constructor Create(ADataModule: TdmDatabase);  // Re√ßoit de l'ext√©rieur
  end;
```

**Avantages :**
- Plus facile √† **tester** (on peut injecter un mock)
- Plus **flexible** (on peut changer l'impl√©mentation)
- Respect du principe de **responsabilit√© unique**

### Exemple avec interface

```pascal
// Interface pour l'acc√®s donn√©es
type
  IClientRepository = interface
    ['{GUID-HERE}']
    function Lire(ID: Integer): TClient;
    function LireTous: TObjectList<TClient>;
    function Creer(Client: TClient): Integer;
    procedure Modifier(Client: TClient);
    procedure Supprimer(ID: Integer);
  end;

// Impl√©mentation avec FireDAC
type
  TClientRepositoryFireDAC = class(TInterfacedObject, IClientRepository)
  private
    FConnection: TFDConnection;
  public
    constructor Create(AConnection: TFDConnection);
    // Impl√©menter les m√©thodes de l'interface
  end;

// Manager qui utilise l'interface
type
  TClientManager = class
  private
    FRepository: IClientRepository;
  public
    constructor Create(ARepository: IClientRepository);
    // Le manager ne conna√Æt pas FireDAC, seulement l'interface !
  end;
```

**R√©sultat :** On peut facilement remplacer FireDAC par une autre technologie sans toucher au Manager !

## Tests unitaires

L'architecture en couches facilite √©norm√©ment les **tests unitaires**.

### Tester la couche m√©tier

```pascal
unit uClientManagerTests;

interface

uses
  DUnitX.TestFramework, uClientManager, uDmDatabase;

type
  [TestFixture]
  TClientManagerTests = class
  private
    FClientManager: TClientManager;
  public
    [Setup]
    procedure Setup;

    [TearDown]
    procedure TearDown;

    [Test]
    procedure TestCreerClient_Valide;

    [Test]
    procedure TestCreerClient_EmailInvalide;

    [Test]
    procedure TestValiderEmail;
  end;

implementation

procedure TClientManagerTests.Setup;
begin
  // Cr√©er le manager avec une base de test
  FClientManager := TClientManager.Create(dmDatabase);
end;

procedure TClientManagerTests.TearDown;
begin
  FClientManager.Free;
end;

procedure TClientManagerTests.TestCreerClient_Valide;
var
  ID: Integer;
begin
  // Arrange
  // Act
  ID := FClientManager.CreerNouveauClient('Test', 'Client', 'test@email.fr', '');

  // Assert
  Assert.IsTrue(ID > 0, 'L''ID doit √™tre sup√©rieur √† 0');
end;

procedure TClientManagerTests.TestCreerClient_EmailInvalide;
begin
  // Assert.WillRaise : on attend une exception
  Assert.WillRaise(
    procedure
    begin
      FClientManager.CreerNouveauClient('Test', 'Client', 'emailinvalide', '');
    end,
    Exception,
    'Devrait lever une exception pour email invalide'
  );
end;

procedure TClientManagerTests.TestValiderEmail;
begin
  Assert.IsTrue(FClientManager.ValiderEmail('test@example.com'));
  Assert.IsFalse(FClientManager.ValiderEmail('invalide'));
  Assert.IsFalse(FClientManager.ValiderEmail(''));
end;

end.
```

## Bonnes pratiques

### ‚úÖ √Ä FAIRE

1. **Un DataModule par base de donn√©es**
   ```pascal
   dmPrincipale  // Base principale
   dmStatistiques  // Base de statistiques
   ```

2. **S√©parer les responsabilit√©s**
   ```
   Formulaires ‚Üí Affichage uniquement
   Managers ‚Üí Logique m√©tier
   DAO ‚Üí Acc√®s donn√©es
   ```

3. **Valider dans la couche m√©tier**
   ```pascal
   // ‚úÖ Dans le Manager
   if not ValiderEmail(Email) then
     raise Exception.Create('Email invalide');
   ```

4. **Utiliser des interfaces**
   ```pascal
   IClientRepository, ICommandeRepository
   ```

5. **Cr√©er des objets m√©tier**
   ```pascal
   TClient, TCommande, TProduit
   ```

6. **Logger les op√©rations importantes**
   ```pascal
   Logger.Info('Client cr√©√© : ' + Client.NomComplet);
   ```

### ‚ùå √Ä √âVITER

1. **M√©langer les couches**
   ```pascal
   // ‚ùå SQL dans le formulaire
   FDQuery1.SQL.Text := 'SELECT...';

   // ‚úÖ Appeler le DataModule ou Manager
   dmDatabase.ChargerClients;
   ```

2. **D√©pendances circulaires**
   ```
   ‚ùå FormClients uses uClientManager
      uClientManager uses FormClients
   ```

3. **Logique dans les getters/setters**
   ```pascal
   // ‚ùå Logique m√©tier dans la propri√©t√©
   procedure TClient.SetEmail(const Value: string);
   begin
     if Pos('@', Value) = 0 then
       raise Exception.Create('Email invalide');
     FEmail := Value;
   end;

   // ‚úÖ M√©thode de validation s√©par√©e
   function TClient.ValiderEmail: Boolean;
   ```

4. **Trop de param√®tres**
   ```pascal
   // ‚ùå Trop de param√®tres
   function Creer(N, P, E, T, A, V, C, D: string): Integer;

   // ‚úÖ Utiliser un objet
   function Creer(Client: TClient): Integer;
   ```

## Architecture compl√®te r√©capitulative

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              COUCHE PR√âSENTATION                    ‚îÇ
‚îÇ  FormMain, FormClients, FormCommandes               ‚îÇ
‚îÇ  ‚Ä¢ Affichage                                        ‚îÇ
‚îÇ  ‚Ä¢ Interaction utilisateur                          ‚îÇ
‚îÇ  ‚Ä¢ Appelle ‚Üí Managers                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              COUCHE M√âTIER                          ‚îÇ
‚îÇ  ClientManager, CommandeManager                     ‚îÇ
‚îÇ  EmailService, ReportService                        ‚îÇ
‚îÇ  ‚Ä¢ R√®gles m√©tier                                    ‚îÇ
‚îÇ  ‚Ä¢ Validation                                       ‚îÇ
‚îÇ  ‚Ä¢ Orchestration                                    ‚îÇ
‚îÇ  ‚Ä¢ Appelle ‚Üí DAO                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         COUCHE ACC√àS DONN√âES (DAO)                  ‚îÇ
‚îÇ  ClientDAO, CommandeDAO                             ‚îÇ
‚îÇ  ‚Ä¢ Conversion objets ‚Üî base                         ‚îÇ
‚îÇ  ‚Ä¢ Requ√™tes SQL                                     ‚îÇ
‚îÇ  ‚Ä¢ Appelle ‚Üí DataModule                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              DATA MODULE                            ‚îÇ
‚îÇ  TFDConnection, TFDQuery                            ‚îÇ
‚îÇ  ‚Ä¢ Connexion physique                               ‚îÇ
‚îÇ  ‚Ä¢ Gestion des composants FireDAC                   ‚îÇ
‚îÇ  ‚Ä¢ Appelle ‚Üí Base de donn√©es                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           BASE DE DONN√âES                           ‚îÇ
‚îÇ  MySQL/MariaDB                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

     OBJETS M√âTIER (utilis√©s dans toutes les couches)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  TClient, TCommande, TProduit                       ‚îÇ
‚îÇ  ‚Ä¢ Propri√©t√©s                                       ‚îÇ
‚îÇ  ‚Ä¢ M√©thodes m√©tier simples                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## R√©sum√©

### Points cl√©s

‚úÖ **S√©parer en 3 couches** : Pr√©sentation, M√©tier, Donn√©es
‚úÖ **DataModule** pour centraliser l'acc√®s aux donn√©es
‚úÖ **Managers** pour la logique m√©tier
‚úÖ **DAO** pour convertir objets ‚Üî base
‚úÖ **Objets m√©tier** pour repr√©senter les entit√©s
‚úÖ **Injection de d√©pendances** pour la flexibilit√©

### Avantages de l'architecture en couches

| Avantage | Description |
|----------|-------------|
| **Maintenabilit√©** | Code organis√©, facile √† comprendre |
| **R√©utilisabilit√©** | M√™me logique dans plusieurs formulaires |
| **Testabilit√©** | Chaque couche testable s√©par√©ment |
| **√âvolutivit√©** | Facile d'ajouter des fonctionnalit√©s |
| **Travail d'√©quipe** | Chacun peut travailler sur sa couche |
| **Flexibilit√©** | Changer une couche sans toucher les autres |

### Progression recommand√©e

**Niveau d√©butant :**
1. Tout dans le formulaire (pour apprendre)
2. Passer √† un DataModule simple

**Niveau interm√©diaire :**
3. Ajouter des classes Manager
4. Cr√©er des objets m√©tier

**Niveau avanc√© :**
5. Impl√©menter des DAO
6. Utiliser des interfaces
7. Injection de d√©pendances

## Prochaines √©tapes

Vous ma√Ætrisez maintenant l'architecture en couches ! Dans les sections suivantes, nous verrons :

1. **Migration de bases** de donn√©es
2. **S√©curisation** avanc√©e
3. **Optimisation** des performances
4. **Patterns avanc√©s** (Repository, Unit of Work)

Avec une architecture en couches bien con√ßue, votre application sera professionnelle, maintenable et √©volutive !

‚è≠Ô∏è [Migration et synchronisation de bases de donn√©es](/08-acces-aux-bases-de-donnees-mysql-mariadb/10-migration-et-synchronisation-de-bases-de-donnees.md)
