üîù Retour au [Sommaire](/SOMMAIRE.md)

# 12.6.1 D√©bogage avanc√© avec LLDB v12

## Introduction

LLDB (Low Level Debugger) est le d√©bogueur moderne et puissant qui a remplac√© GDB (GNU Debugger) pour les plateformes Apple et de nombreux syst√®mes Linux. Delphi 13 Florence int√®gre la **version 12 de LLDB**, apportant des am√©liorations significatives en termes de performances, de stabilit√© et de fonctionnalit√©s.

Pour un d√©butant, LLDB peut sembler intimidant avec son interface en ligne de commande et ses nombreuses options. Cependant, une fois que vous comprenez ses concepts de base, LLDB devient un outil extraordinairement puissant qui vous donne un contr√¥le total sur l'ex√©cution de votre application.

Ce chapitre vous guide √† travers les capacit√©s avanc√©es de LLDB v12, en commen√ßant par les bases et en progressant vers des techniques sophistiqu√©es de d√©bogage.

## Qu'est-ce que LLDB ?

### D√©finition et contexte

**LLDB** est un d√©bogueur de nouvelle g√©n√©ration d√©velopp√© par le projet LLVM. Il est utilis√© par :
- Xcode d'Apple (pour macOS et iOS)
- Android Studio (pour le d√©bogage natif)
- De nombreux IDE modernes
- Delphi (depuis la version 10.3 Rio)

LLDB offre une architecture modulaire et extensible, ce qui le rend adapt√© √† de nombreuses plateformes et langages de programmation.

### Pourquoi LLDB plut√¥t que GDB ?

**Performances sup√©rieures**
- D√©marrage plus rapide
- R√©ponse plus r√©active lors des commandes
- Meilleure gestion de la m√©moire

**Architecture moderne**
- Code plus propre et maintenable
- Meilleure extensibilit√©
- Support natif des nouvelles plateformes

**Support Apple**
- Seul d√©bogueur officiellement support√© pour macOS et iOS modernes
- Int√©gration optimale avec les outils Apple

**Support Delphi am√©lior√©**
- Meilleure compr√©hension des types Object Pascal
- Visualisation am√©lior√©e des structures Delphi
- Int√©gration fluide avec l'IDE

### LLDB dans l'√©cosyst√®me Delphi

Lorsque vous d√©boguez une application Delphi sur :
- **macOS** : LLDB est utilis√© automatiquement
- **iOS** : LLDB est le seul d√©bogueur disponible
- **Linux** : LLDB est utilis√© (selon la configuration)
- **Android** : LLDB peut √™tre utilis√© pour le d√©bogage natif
- **Windows** : Le d√©bogueur Windows natif est utilis√© par d√©faut

## Nouveaut√©s de LLDB v12

Delphi 13 Florence int√®gre LLDB version 12, qui apporte de nombreuses am√©liorations par rapport aux versions pr√©c√©dentes.

### Am√©liorations de performance

**D√©marrage acc√©l√©r√©**

Le temps de d√©marrage d'une session de d√©bogage a √©t√© r√©duit de mani√®re significative :
- Chargement plus rapide des symboles de d√©bogage
- Initialisation optimis√©e du d√©bogueur
- Connexion plus rapide aux processus cibles

**Temps de r√©ponse am√©lior√©**

Les op√©rations courantes sont plus rapides :
- √âvaluation d'expressions (variables, propri√©t√©s)
- Navigation dans la pile d'appels
- Inspection de structures complexes
- Ex√©cution pas √† pas

**Gestion m√©moire optimis√©e**

LLDB v12 utilise moins de m√©moire lors du d√©bogage d'applications complexes, permettant :
- Le d√©bogage d'applications plus volumineuses
- Des sessions de d√©bogage plus longues sans ralentissement
- Meilleure stabilit√© g√©n√©rale

### Support am√©lior√© des types Delphi

**Cha√Ænes de caract√®res**

LLDB v12 comprend mieux les types de cha√Ænes Delphi :
- `String` (UnicodeString)
- `AnsiString`
- `ShortString`
- `WideString`

L'affichage est plus naturel et ne montre plus de donn√©es brutes illisibles.

**Tableaux dynamiques**

Les tableaux dynamiques (`TArray<T>`) sont maintenant :
- Correctement reconnus et affich√©s avec leur taille
- Navigables √©l√©ment par √©l√©ment
- Affich√©s avec leur contenu r√©el

**G√©n√©riques**

Le support des types g√©n√©riques a √©t√© consid√©rablement am√©lior√© :
- `TList<T>`, `TDictionary<K,V>`, etc. sont correctement reconnus
- Les types param√©tr√©s s'affichent clairement
- L'inspection des √©l√©ments internes fonctionne mieux

**Enregistrements (Records)**

Les records complexes, notamment ceux avec m√©thodes et op√©rateurs, sont mieux g√©r√©s :
- Affichage structur√© des champs
- Support des records g√©n√©riques
- Meilleure visualisation des variants records

### Stabilit√© et fiabilit√©

**Moins de crashs**

LLDB v12 est plus robuste face √† :
- Des structures de donn√©es corrompues
- Des pointeurs invalides
- Des conditions de threading complexes
- Des applications avec beaucoup de modules

**R√©cup√©ration d'erreurs**

En cas de probl√®me, LLDB v12 :
- Tente de r√©cup√©rer gracieusement
- Fournit des messages d'erreur plus clairs
- Maintient la session de d√©bogage active si possible

**D√©bogage multi-thread am√©lior√©**

Le support du multi-threading a √©t√© renforc√© :
- Meilleure synchronisation entre threads
- Moins de deadlocks lors du d√©bogage
- Visualisation plus claire de l'√©tat des threads

### Nouvelles fonctionnalit√©s

**Watchpoints am√©lior√©s**

Les watchpoints (surveillance de modification de m√©moire) sont :
- Plus fiables
- Plus rapides
- Supportent plus de cas d'usage

**Expressions conditionnelles plus puissantes**

Les conditions dans les breakpoints peuvent maintenant :
- √âvaluer des expressions plus complexes
- Appeler des fonctions (avec pr√©caution)
- Utiliser des op√©rateurs avanc√©s

**Support de scripting Python am√©lior√©**

LLDB v12 offre une meilleure int√©gration avec Python pour :
- Automatiser des t√¢ches de d√©bogage
- Cr√©er des commandes personnalis√©es
- Analyser des dumps m√©moire

## Interface LLDB dans Delphi

### Acc√©der √† la console LLDB

Lorsque vous d√©boguez une application sur une plateforme utilisant LLDB, vous pouvez acc√©der √† la console LLDB directement depuis l'IDE.

**Ouvrir la console LLDB :**

1. D√©marrez une session de d√©bogage (F9)
2. Mettez l'application en pause (point d'arr√™t ou pause manuelle)
3. Dans Delphi, allez dans **View > Debug Windows > LLDB Console**
4. Une fen√™tre s'ouvre affichant l'invite LLDB : `(lldb)`

**√Ä quoi ressemble la console :**

```
(lldb) target create "/Users/dev/MyApp/MyApp"
Current executable set to '/Users/dev/MyApp/MyApp' (x86_64).
(lldb) process attach --pid 12345
Process 12345 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP
(lldb)
```

Vous pouvez maintenant taper des commandes LLDB directement.

### Commandes de base

Avant d'explorer les commandes avanc√©es, familiarisons-nous avec les commandes de base.

**help** : Obtenir de l'aide

```
(lldb) help
(lldb) help breakpoint    # Aide sur les breakpoints
(lldb) help thread        # Aide sur les threads
```

**process** : Contr√¥ler le processus

```
(lldb) process continue    # Reprendre l'ex√©cution (√©quivalent F9)
(lldb) process interrupt   # Mettre en pause
(lldb) process kill        # Terminer le processus
```

**thread** : Travailler avec les threads

```
(lldb) thread list         # Lister tous les threads
(lldb) thread select 2     # S√©lectionner le thread 2
(lldb) thread backtrace    # Voir la pile du thread actuel
```

**frame** : Naviguer dans la pile d'appels

```
(lldb) frame select 0      # S√©lectionner le frame 0 (fonction actuelle)
(lldb) frame variable      # Voir toutes les variables locales
(lldb) frame info          # Infos sur le frame actuel
```

**expression** (ou **expr** ou **p**) : √âvaluer une expression

```
(lldb) expr MonAge
(int) $0 = 25

(lldb) p MonNom
(string) $1 = "Jean Dupont"

(lldb) expr MaListe.Count
(int) $2 = 10
```

### Commandes de navigation

**step** : Ex√©cution pas √† pas

```
(lldb) step      # √âquivalent F7 (Step Into)
(lldb) next      # √âquivalent F8 (Step Over)
(lldb) finish    # √âquivalent Shift+F8 (Step Out)
(lldb) continue  # √âquivalent F9 (Continue)
```

**Raccourcis :**
- `s` pour `step`
- `n` pour `next`
- `c` pour `continue`

### Affichage de l'√©tat du programme

**backtrace** (ou **bt**) : Pile d'appels

```
(lldb) bt
* thread #1, queue = 'com.apple.main-thread'
  * frame #0: 0x00000001000015a0 MyApp`TForm1.Button1Click at MainForm.pas:42
    frame #1: 0x00000001000023b0 MyApp`TControl.Click at Controls.pas:1234
    frame #2: 0x0000000100003210 MyApp`TButton.Click at Buttons.pas:567
    frame #3: 0x0000000100005678 MyApp`ApplicationRun at Forms.pas:890
```

**frame variable** : Variables locales

```
(lldb) frame variable
(int) Counter = 5
(string) Name = "Test"
(TMyObject *) MyObj = 0x00007f9e8c400000
```

**thread list** : √âtat de tous les threads

```
(lldb) thread list
Process 12345 stopped
* thread #1: tid = 0x1a03, 0x00000001000015a0 MyApp`TForm1.Button1Click
  thread #2: tid = 0x1a04, 0x00007fff204050c0 libsystem_kernel.dylib`__workq_kernreturn
  thread #3: tid = 0x1a05, 0x00007fff204050c0 libsystem_kernel.dylib`__workq_kernreturn
```

L'ast√©risque (*) indique le thread actuel.

## Breakpoints avanc√©s avec LLDB

### Cr√©er des breakpoints en ligne de commande

Bien que vous puissiez cr√©er des breakpoints dans l'IDE, LLDB offre plus de contr√¥le.

**Breakpoint sur une ligne sp√©cifique :**

```
(lldb) breakpoint set --file MainForm.pas --line 42
Breakpoint 1: where = MyApp`TForm1.Button1Click + 20 at MainForm.pas:42
```

Raccourci :
```
(lldb) br s -f MainForm.pas -l 42
```

**Breakpoint sur une fonction :**

```
(lldb) breakpoint set --name TForm1.Button1Click
Breakpoint 2: where = MyApp`TForm1.Button1Click at MainForm.pas:40
```

Raccourci :
```
(lldb) br s -n TForm1.Button1Click
```

**Breakpoint avec wildcard :**

```
(lldb) breakpoint set --func-regex ".*Click"
# S'arr√™te sur toutes les fonctions dont le nom se termine par "Click"
```

### Breakpoints conditionnels

Les breakpoints conditionnels ne se d√©clenchent que si une condition est vraie.

**Syntaxe :**

```
(lldb) breakpoint set -f MainForm.pas -l 42 -c "Counter > 100"
```

L'application ne s'arr√™tera √† la ligne 42 que si `Counter` est sup√©rieur √† 100.

**Exemples de conditions :**

```
# S'arr√™ter si un pointeur est nil
(lldb) br s -f MyUnit.pas -l 50 -c "MyObject == nullptr"

# S'arr√™ter si une cha√Æne contient un texte
(lldb) br s -f MyUnit.pas -l 75 -c "strcmp(Name, \"Test\") == 0"

# S'arr√™ter sur une valeur sp√©cifique
(lldb) br s -f MyUnit.pas -l 100 -c "ID == 12345"
```

**Modifier une condition existante :**

```
(lldb) breakpoint modify 1 --condition "Age >= 18"
```

### Breakpoints avec compteurs

D√©clencher un breakpoint apr√®s N passages :

```
(lldb) breakpoint set -f MyUnit.pas -l 42 --ignore-count 99
```

Le breakpoint se d√©clenchera au 100√®me passage (ignore les 99 premiers).

**Cas d'usage :**

Utile dans les boucles o√π vous voulez examiner un √©tat sp√©cifique :

```pascal
for i := 0 to 999 do
begin
  TraiterElement(i);  // Breakpoint qui se d√©clenche au 500√®me passage
end;
```

### Commandes automatiques sur breakpoint

Ex√©cuter des commandes LLDB automatiquement quand un breakpoint est atteint :

```
(lldb) breakpoint set -f MyUnit.pas -l 42
Breakpoint 3: where = MyApp`ProcessData...

(lldb) breakpoint command add 3
Enter your debugger command(s). Type 'DONE' to end.
> frame variable Counter
> expr MyList.Count
> continue
> DONE
```

Maintenant, chaque fois que le breakpoint 3 est atteint, LLDB :
1. Affiche la valeur de `Counter`
2. Affiche `MyList.Count`
3. Continue automatiquement l'ex√©cution

**Cas d'usage :**

Journaliser des valeurs sans arr√™ter l'ex√©cution :

```
(lldb) br s -f MyUnit.pas -l 50
(lldb) br command add 1
> expr printf("Counter = %d\n", Counter)
> continue
> DONE
```

### Lister et g√©rer les breakpoints

**Lister tous les breakpoints :**

```
(lldb) breakpoint list
Current breakpoints:
1: file = 'MainForm.pas', line = 42, exact_match = 0, locations = 1
2: name = 'TForm1.Button1Click', locations = 1
3: file = 'DataModule.pas', line = 150, exact_match = 0, locations = 1
```

**Activer/d√©sactiver :**

```
(lldb) breakpoint disable 1    # D√©sactiver le breakpoint 1
(lldb) breakpoint enable 1     # R√©activer le breakpoint 1
```

**Supprimer :**

```
(lldb) breakpoint delete 1     # Supprimer le breakpoint 1
(lldb) breakpoint delete       # Supprimer TOUS les breakpoints (demande confirmation)
```

**Informations d√©taill√©es :**

```
(lldb) breakpoint list 1 -v    # D√©tails verbeux sur le breakpoint 1
```

## Watchpoints : Surveiller les modifications m√©moire

Les **watchpoints** (points d'observation) sont diff√©rents des breakpoints. Ils surveillent une zone m√©moire et s'arr√™tent quand cette m√©moire est lue ou modifi√©e.

### Cr√©er un watchpoint

**Surveiller une variable :**

```
(lldb) watchpoint set variable MonCompteur
Watchpoint created: Watchpoint 1: addr = 0x7ffeefbff5a8 size = 4 state = enabled type = w
```

Le programme s'arr√™tera chaque fois que `MonCompteur` est modifi√©.

**Surveiller une adresse m√©moire sp√©cifique :**

```
(lldb) watchpoint set expression -- 0x7ffeefbff5a8
```

**Surveiller en lecture ET √©criture :**

```
(lldb) watchpoint set variable MonCompteur --watch read_write
```

**Surveiller uniquement en √©criture (d√©faut) :**

```
(lldb) watchpoint set variable MonCompteur --watch write
```

### Cas d'usage des watchpoints

**Trouver qui modifie une variable**

Vous avez une variable globale qui change de mani√®re inattendue :

```pascal
var
  GlobalCounter: Integer = 0;  // Qui modifie cette variable ?
```

```
(lldb) watchpoint set variable GlobalCounter
(lldb) continue
```

Le programme s'arr√™tera √† la ligne exacte qui modifie `GlobalCounter`.

**D√©tecter la corruption de donn√©es**

Si une structure de donn√©es se corrompt :

```pascal
type
  TImportantData = record
    ID: Integer;
    Status: Integer;
    Name: string;
  end;

var
  MyData: TImportantData;
```

```
(lldb) watchpoint set expression -- &MyData
```

Toute modification de n'importe quel champ de `MyData` d√©clenchera le watchpoint.

**D√©bogage de pointeurs**

Surveiller o√π un pointeur est modifi√© :

```
(lldb) watchpoint set variable MyPointer
```

### G√©rer les watchpoints

**Lister :**

```
(lldb) watchpoint list
Number of supported hardware watchpoints: 4
Current watchpoints:
Watchpoint 1: addr = 0x7ffeefbff5a8 size = 4 state = enabled type = w
    old value: 5
    new value: 10
```

**D√©sactiver/activer :**

```
(lldb) watchpoint disable 1
(lldb) watchpoint enable 1
```

**Supprimer :**

```
(lldb) watchpoint delete 1
```

**Limitation importante :**

Les watchpoints utilisent des ressources mat√©rielles limit√©es. La plupart des processeurs supportent seulement 4 watchpoints simultan√©s. Si vous en cr√©ez trop, LLDB vous avertira.

## Inspection m√©moire avanc√©e

### Lire la m√©moire

LLDB permet d'inspecter directement la m√©moire brute.

**Syntaxe de base :**

```
(lldb) memory read <adresse>
```

**Exemples :**

```
# Lire 16 octets √† une adresse
(lldb) memory read --size 1 --count 16 0x00007ffeefbff5a8

# Lire sous forme de mots de 4 octets (integers)
(lldb) memory read --size 4 --count 10 0x00007ffeefbff5a8

# Afficher en hexad√©cimal ET en ASCII
(lldb) memory read --format hex 0x00007ffeefbff5a8
```

**Formats d'affichage :**

- `hex` : Hexad√©cimal
- `decimal` : D√©cimal
- `binary` : Binaire
- `character` : Caract√®res ASCII
- `float` : Nombres √† virgule flottante
- `pointer` : Adresses pointeur

**Exemple de sortie :**

```
(lldb) memory read --size 1 --count 32 --format hex 0x00007ffeefbff5a8
0x7ffeefbff5a8: 0x05 0x00 0x00 0x00 0x48 0x65 0x6c 0x6c
0x7ffeefbff5b0: 0x6f 0x00 0x00 0x00 0x00 0x00 0x00 0x00
```

### Trouver l'adresse d'une variable

Pour utiliser `memory read`, vous avez besoin de l'adresse. Comment la trouver ?

```
(lldb) expr &MonCompteur
(int *) $3 = 0x00007ffeefbff5a8

(lldb) memory read 0x00007ffeefbff5a8
```

Ou directement :

```
(lldb) memory read `&MonCompteur`
```

Les backticks `` ` `` permettent d'√©valuer l'expression et d'utiliser le r√©sultat.

### √âcrire dans la m√©moire

**Attention :** Modifier la m√©moire directement peut corrompre votre application. Utilisez cette fonctionnalit√© avec pr√©caution.

```
(lldb) memory write 0x00007ffeefbff5a8 0x0A
```

Ceci √©crit la valeur `0x0A` (10 en d√©cimal) √† l'adresse sp√©cifi√©e.

**Cas d'usage :**

Tester rapidement comment l'application se comporte avec une valeur diff√©rente :

```pascal
if Status = 1 then
  ProcessNormal
else
  ProcessSpecial;
```

Pendant le d√©bogage, vous pouvez changer `Status` en m√©moire pour forcer un chemin sp√©cifique.

### Rechercher dans la m√©moire

Rechercher un pattern dans la m√©moire :

```
(lldb) memory find --size 4 --count 1 --expression 0x12345678 0x100000000 0x200000000
```

Recherche la valeur `0x12345678` dans la plage m√©moire de `0x100000000` √† `0x200000000`.

**Rechercher une cha√Æne :**

```
(lldb) memory find --string "Error" 0x100000000 0x200000000
```

**Cas d'usage :**

Trouver o√π une cha√Æne sp√©cifique est stock√©e en m√©moire, utile pour d√©boguer des probl√®mes de corruption de cha√Ænes.

## √âvaluation d'expressions avanc√©e

### Expressions simples

Nous avons vu les bases avec `expr`. Allons plus loin.

**Op√©rations arithm√©tiques :**

```
(lldb) expr 2 + 2
(int) $0 = 4

(lldb) expr MonAge * 2
(int) $1 = 50

(lldb) expr (Prix * Quantite) * 1.20
(double) $2 = 144.0
```

**Comparaisons :**

```
(lldb) expr Age > 18
(bool) $3 = true

(lldb) expr Status == 0
(bool) $4 = false
```

### Appeler des fonctions

LLDB peut appeler des fonctions pendant le d√©bogage. C'est puissant mais potentiellement dangereux.

**Exemple :**

```pascal
function CalculerTotal(Prix: Double; Quantite: Integer): Double;
begin
  Result := Prix * Quantite;
end;
```

```
(lldb) expr CalculerTotal(10.5, 3)
(double) $5 = 31.5
```

**Pr√©cautions :**

- La fonction ne doit pas avoir d'effets de bord dangereux
- √âvitez d'appeler des fonctions qui modifient l'√©tat global
- Ne jamais appeler des fonctions qui pourraient planter
- Les fonctions peuvent avoir acc√®s aux variables du scope actuel

**Cas d'usage utile :**

```
(lldb) expr ShowMessage("Debug: Counter = " + IntToStr(Counter))
```

Afficher un message depuis le d√©bogueur sans recompiler.

### Cr√©er des variables temporaires

LLDB vous permet de cr√©er des variables temporaires pendant le d√©bogage :

```
(lldb) expr int $mytemp = 42
(lldb) expr $mytemp * 2
(int) $6 = 84
```

Les variables commen√ßant par `$` sont des variables LLDB, pas des variables de votre programme.

**Usage :**

Stocker un calcul complexe pour y faire r√©f√©rence plus tard :

```
(lldb) expr double $total = (Prix * Quantite) * 1.20
(lldb) expr $total > 100
(bool) $7 = true
```

### Type casting

Forcer un type lors de l'√©valuation :

```
(lldb) expr (int)MyFloatValue
(lldb) expr (char*)MyPointer
(lldb) expr (TMyClass*)MyObject
```

Utile quand LLDB ne peut pas d√©terminer automatiquement le type.

## D√©bogage multi-thread avec LLDB

Les applications modernes utilisent souvent plusieurs threads. LLDB offre des outils puissants pour les d√©boguer.

### Lister les threads

```
(lldb) thread list
Process 12345 stopped
* thread #1, name = 'MainThread', queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
  thread #2, name = 'WorkerThread1'
  thread #3, name = 'WorkerThread2'
  thread #4, name = 'NetworkThread'
```

L'ast√©risque (*) indique le thread actuellement s√©lectionn√©.

### S√©lectionner un thread

```
(lldb) thread select 2
* thread #2, name = 'WorkerThread1'
  frame #0: 0x0000000100002340 MyApp`WorkerProc at Worker.pas:25
```

Toutes les commandes suivantes s'appliqueront √† ce thread.

### Voir la pile d'appels de tous les threads

```
(lldb) thread backtrace all
```

Affiche la stack trace de TOUS les threads, utile pour comprendre ce que fait toute l'application.

**Exemple de sortie :**

```
* thread #1, name = 'MainThread'
  * frame #0: 0x0000000100001000 MyApp`TForm1.Button1Click at MainForm.pas:42
    frame #1: 0x0000000100002000 MyApp`TControl.Click at Controls.pas:200

  thread #2, name = 'WorkerThread1'
    frame #0: 0x00007fff204050c0 libsystem_kernel.dylib`__psynch_cvwait
    frame #1: 0x0000000100003000 MyApp`TWorkerThread.Execute at Worker.pas:30

  thread #3, name = 'WorkerThread2'
    frame #0: 0x00007fff204050d0 libsystem_kernel.dylib`__select
    frame #1: 0x0000000100004000 MyApp`NetworkWait at Network.pas:50
```

### Continuer un thread sp√©cifique

```
(lldb) thread continue 2
```

Reprend l'ex√©cution du thread 2 seulement, les autres restent en pause.

### Ex√©cuter une commande sur tous les threads

```
(lldb) thread apply all bt
```

Ex√©cute `bt` (backtrace) sur tous les threads.

### Breakpoints sp√©cifiques √† un thread

Cr√©er un breakpoint qui ne se d√©clenche que sur un thread sp√©cifique :

```
(lldb) breakpoint set -f Worker.pas -l 30 --thread-index 2
```

Le breakpoint ne se d√©clenchera que quand le thread 2 atteint cette ligne.

### D√©boguer les deadlocks

Un **deadlock** survient quand deux threads s'attendent mutuellement.

**Diagnostic :**

1. L'application semble fig√©e
2. Mettez en pause (Pause button ou Ctrl+C dans la console)
3. Examinez tous les threads :

```
(lldb) thread backtrace all
```

4. Cherchez les patterns de verrouillage :
   - Thread 1 attend un mutex d√©tenu par Thread 2
   - Thread 2 attend un mutex d√©tenu par Thread 1

**Exemple de ce que vous pourriez voir :**

```
thread #1: waiting on mutex at 0x12345678
thread #2: waiting on mutex at 0x23456789
```

En examinant les stack traces, vous pouvez identifier l'ordre des verrouillages qui cause le deadlock.

### D√©boguer les data races

Les **data races** surviennent quand plusieurs threads acc√®dent √† la m√™me donn√©e sans synchronisation.

**Utiliser les watchpoints :**

```
(lldb) watchpoint set variable SharedCounter
```

Maintenant, si plusieurs threads modifient `SharedCounter`, vous verrez exactement quand et par quel thread.

## Scripts et automatisation

LLDB supporte les scripts Python pour automatiser des t√¢ches complexes.

### Ex√©cuter une commande Python simple

```
(lldb) script print("Hello from Python")
Hello from Python
```

### Acc√©der aux objets LLDB depuis Python

```
(lldb) script
>>> import lldb
>>> target = lldb.debugger.GetSelectedTarget()
>>> process = target.GetProcess()
>>> print(f"Process ID: {process.GetProcessID()}")
Process ID: 12345
>>>
```

Tapez Ctrl+D pour sortir du mode script.

### Cr√©er des commandes personnalis√©es

Vous pouvez cr√©er des commandes LLDB personnalis√©es en Python.

**Exemple : Commande pour afficher toutes les variables locales format√©es**

```python
# Fichier : mycommands.py

import lldb

def show_all_vars(debugger, command, result, internal_dict):
    target = debugger.GetSelectedTarget()
    process = target.GetProcess()
    thread = process.GetSelectedThread()
    frame = thread.GetSelectedFrame()

    print("=== Variables locales ===")
    for var in frame.GetVariables(True, True, True, True):
        print(f"{var.GetName()} = {var.GetValue()}")

def __lldb_init_module(debugger, internal_dict):
    debugger.HandleCommand('command script add -f mycommands.show_all_vars showvars')
    print("Commande 'showvars' charg√©e")
```

**Charger le script :**

```
(lldb) command script import /path/to/mycommands.py
Commande 'showvars' charg√©e
```

**Utiliser la commande :**

```
(lldb) showvars
=== Variables locales ===
Counter = 5
Name = "Test"
MyObj = 0x00007f9e8c400000
```

### Scripts pour l'analyse automatique

**Exemple : D√©tecter les fuites m√©moire potentielles**

```python
def check_nil_pointers(debugger, command, result, internal_dict):
    frame = debugger.GetSelectedTarget().GetProcess().GetSelectedThread().GetSelectedFrame()

    nil_pointers = []
    for var in frame.GetVariables(True, True, True, True):
        if var.GetTypeName().endswith('*'):  # C'est un pointeur
            if var.GetValueAsUnsigned() == 0:
                nil_pointers.append(var.GetName())

    if nil_pointers:
        print("‚ö†Ô∏è  Pointeurs nil d√©tect√©s:")
        for name in nil_pointers:
            print(f"  - {name}")
    else:
        print("‚úì Aucun pointeur nil")
```

### Charger automatiquement des scripts

Cr√©ez un fichier `.lldbinit` dans votre home directory :

```bash
# ~/.lldbinit
command script import ~/lldb_scripts/mycommands.py
command script import ~/lldb_scripts/memory_tools.py

# Alias utiles
command alias pv frame variable
command alias bt thread backtrace
```

Ces commandes seront ex√©cut√©es automatiquement au d√©marrage de LLDB.

## Astuces et techniques avanc√©es

### Affichage format√© des donn√©es

**Format personnalis√© pour les expressions :**

```
(lldb) type summary add --summary-string "Count: ${var.FCount}" TList
```

Maintenant, quand vous affichez un `TList`, LLDB montrera automatiquement son count.

**Affichage en hexad√©cimal :**

```
(lldb) expr --format hex -- MonEntier
(int) $8 = 0x0000007b
```

**Affichage en binaire :**

```
(lldb) expr --format binary -- MonEntier
(int) $9 = 0b01111011
```

### Capture de la sortie

Rediriger la sortie d'une commande vers un fichier :

```
(lldb) log enable lldb all -f /tmp/lldb.log
```

Tous les √©v√©nements LLDB seront journalis√©s dans `/tmp/lldb.log`.

### D√©sassemblage du code

Voir le code assembleur :

```
(lldb) disassemble
```

Affiche le code assembleur de la fonction actuelle.

**D√©sassembler une fonction sp√©cifique :**

```
(lldb) disassemble --name TForm1.Button1Click
```

**Cas d'usage :**

Comprendre exactement ce que fait le compilateur, utile pour :
- Optimisation de performance
- Comprendre des bugs subtils
- Analyse de s√©curit√©

### Examiner les registres

Voir les registres du processeur :

```
(lldb) register read
```

**Exemple de sortie (x64) :**

```
General Purpose Registers:
       rax = 0x0000000000000005
       rbx = 0x00007ffeefbff5a8
       rcx = 0x0000000000000000
       rdx = 0x0000000000000010
       ...
```

**Modifier un registre :**

```
(lldb) register write rax 0x0000000000000042
```

**Attention :** Modifier les registres peut rendre votre programme instable. √Ä utiliser seulement si vous savez ce que vous faites.

### Informations sur les modules

Lister les modules (DLLs, frameworks) charg√©s :

```
(lldb) image list
[  0] 2A1E5B3C-0000-0000-0000-000000000000 0x0000000100000000 /Users/dev/MyApp/MyApp
[  1] 65289842-0000-0000-0000-000000000000 0x00007fff20400000 /usr/lib/libSystem.B.dylib
[  2] 91FD34AB-0000-0000-0000-000000000000 0x00007fff30000000 /System/Library/Frameworks/Foundation.framework/Foundation
```

**Chercher dans quel module se trouve une adresse :**

```
(lldb) image lookup --address 0x0000000100001234
Address: MyApp[0x0000000000001234] (MyApp.__TEXT.__text + 1234)
Summary: MyApp`TForm1.ProcessData at MainForm.pas:125
```

### Core dumps et post-mortem debugging

Si votre application a plant√© et g√©n√©r√© un core dump, vous pouvez l'analyser avec LLDB.

**Charger un core dump :**

```bash
lldb --core /path/to/core.dump /path/to/executable
```

**Analyser :**

```
(lldb) bt
(lldb) frame variable
(lldb) thread list
```

Vous pouvez examiner l'√©tat exact du programme au moment du crash.

## Int√©gration avec Delphi IDE

### Synchronisation avec l'interface graphique

Lorsque vous utilisez la console LLDB dans Delphi, certaines commandes peuvent ne pas se synchroniser avec l'interface graphique.

**Commandes qui se synchronisent :**
- `breakpoint` : Les breakpoints appara√Ætront dans l'√©diteur
- `thread` : Le thread actuel se synchronisera
- `frame` : La fen√™tre de code suivra

**Commandes qui ne se synchronisent pas toujours :**
- Modifications de variables via `expr`
- Watchpoints cr√©√©s manuellement
- Commandes avanc√©es de script

**Conseil :** Apr√®s des op√©rations complexes dans la console LLDB, rafra√Æchissez l'IDE en cliquant dans une fen√™tre de d√©bogage (Watch List, Call Stack).

### Combiner GUI et ligne de commande

**Strat√©gie recommand√©e :**

1. **Utiliser l'IDE pour :**
   - Placer des breakpoints simples
   - Navigation de base (Step Into, Step Over)
   - Inspection rapide de variables (hover)

2. **Utiliser la console LLDB pour :**
   - Breakpoints conditionnels complexes
   - Watchpoints
   - Inspection m√©moire d√©taill√©e
   - Analyse multi-thread avanc√©e
   - Scripts et automatisation

### Exporter les r√©sultats

Pour partager des informations de d√©bogage avec votre √©quipe :

```
(lldb) thread backtrace all > /tmp/all_threads.txt
(lldb) frame variable > /tmp/variables.txt
```

Les fichiers peuvent √™tre ouverts dans un √©diteur de texte et partag√©s.

## Bonnes pratiques et conseils

### 1. Apprenez progressivement

Ne tentez pas de ma√Ætriser toutes les commandes LLDB d'un coup. Commencez par :
- `bt` (backtrace)
- `frame variable`
- `expr`
- `thread list`

Ajoutez progressivement des commandes plus avanc√©es √† votre arsenal.

### 2. Cr√©ez des alias

Pour les commandes que vous utilisez souvent :

```
(lldb) command alias pv frame variable
(lldb) command alias allvars frame variable --show-types
```

Maintenant `pv` est un raccourci pour `frame variable`.

### 3. Documentez vos sessions

Quand vous trouvez quelque chose d'int√©ressant :

```
# Cr√©er un fichier de notes
(lldb) log enable lldb all -f debug_session.log
```

Vous aurez un enregistrement complet de votre session.

### 4. Utilisez l'historique

LLDB conserve un historique des commandes. Utilisez les fl√®ches ‚Üë et ‚Üì pour naviguer dans l'historique.

### 5. Tab completion

Tapez le d√©but d'une commande et appuyez sur Tab pour l'auto-compl√©tion :

```
(lldb) break<Tab>
breakpoint   break
```

### 6. Soyez prudent avec les appels de fonction

Appeler des fonctions depuis LLDB peut avoir des effets de bord. Ne le faites que si :
- Vous comprenez ce que fait la fonction
- La fonction n'a pas d'effets de bord critiques
- Vous √™tes pr√™t √† red√©marrer le d√©bogage si quelque chose tourne mal

### 7. Sauvegardez vos breakpoints

Si vous avez cr√©√© de nombreux breakpoints complexes :

```
(lldb) breakpoint write -f /tmp/my_breakpoints.txt
```

Pour les recharger plus tard :

```
(lldb) breakpoint read -f /tmp/my_breakpoints.txt
```

### 8. Explorez l'aide int√©gr√©e

LLDB a une documentation compl√®te int√©gr√©e :

```
(lldb) help
(lldb) help breakpoint
(lldb) help breakpoint set
```

Consultez-la r√©guli√®rement pour d√©couvrir de nouvelles fonctionnalit√©s.

### 9. Pratiquez dans un environnement s√ªr

Cr√©ez une petite application de test pour exp√©rimenter avec les commandes LLDB sans risquer d'endommager un projet important.

### 10. Partagez vos d√©couvertes

Si vous trouvez une technique utile, documentez-la et partagez-la avec votre √©quipe.

## D√©pannage LLDB

### LLDB ne r√©pond pas

**Sympt√¥me :** Les commandes LLDB ne retournent rien ou prennent tr√®s longtemps.

**Solutions :**

1. V√©rifiez la connexion r√©seau (pour le d√©bogage distant)
2. V√©rifiez que le processus cible est toujours en cours : `process status`
3. Si fig√©, interrompez : Ctrl+C
4. En dernier recours, arr√™tez et relancez la session de d√©bogage

### "Error: couldn't resolve this expression"

**Cause :** LLDB ne peut pas trouver ou √©valuer l'expression.

**Solutions :**

1. V√©rifiez l'orthographe
2. Assurez-vous que la variable est dans le scope actuel
3. V√©rifiez que les symboles de d√©bogage sont pr√©sents
4. Essayez de sp√©cifier le type explicitement : `(int)MaVariable`

### Symboles de d√©bogage manquants

**Sympt√¥me :** Les noms de variables n'apparaissent pas, tout est en adresses.

**Solution :**

1. Recompilez avec les informations de d√©bogage activ√©es
2. V√©rifiez dans **Project > Options > Delphi Compiler > Compiling**
3. Assurez-vous que **Debug Information** est coch√©
4. Red√©ployez l'application

### Breakpoints ignor√©s

**Cause :** L'optimisation du compilateur peut r√©organiser ou √©liminer du code.

**Solution :**

1. D√©sactivez l'optimisation en mode Debug
2. **Project > Options > Delphi Compiler > Compiling > Optimization** = Off
3. Recompilez et red√©ployez

### LLDB crashe

**Sympt√¥me :** LLDB lui-m√™me plante pendant le d√©bogage.

**Solutions :**

1. V√©rifiez que vous utilisez la bonne version de LLDB pour votre plateforme
2. Mettez √† jour vers la derni√®re version de Delphi/LLDB
3. Simplifiez votre session de d√©bogage (moins de breakpoints, moins de watchpoints)
4. Red√©marrez Delphi

### Performance lente

**Cause :** Trop de breakpoints, watchpoints, ou expressions complexes.

**Solutions :**

1. R√©duisez le nombre de breakpoints actifs
2. Supprimez les watchpoints non n√©cessaires
3. Simplifiez les expressions dans la Watch List
4. Utilisez des breakpoints conditionnels au lieu de v√©rifier manuellement

## Checklist de d√©bogage avanc√© avec LLDB

Utilisez cette checklist pour les sessions de d√©bogage complexes :

**‚ñ° Pr√©paration**
- [ ] Informations de d√©bogage activ√©es dans le projet
- [ ] Optimisation d√©sactiv√©e en mode Debug
- [ ] Application d√©ploy√©e sur la cible
- [ ] LLDB console ouverte dans Delphi

**‚ñ° Session de d√©bogage**
- [ ] Breakpoints plac√©s aux endroits strat√©giques
- [ ] Watchpoints configur√©s si n√©cessaire
- [ ] Thread appropri√© s√©lectionn√©
- [ ] Variables cl√©s surveill√©es

**‚ñ° Analyse**
- [ ] Stack trace examin√©e (`bt`)
- [ ] Variables locales inspect√©es (`frame variable`)
- [ ] √âtat des threads v√©rifi√© (`thread list`)
- [ ] M√©moire examin√©e si n√©cessaire

**‚ñ° Documentation**
- [ ] R√©sultats not√©s
- [ ] Commandes utiles sauvegard√©es
- [ ] Breakpoints complexes export√©s si n√©cessaire

## Ressources suppl√©mentaires

### Documentation officielle

- **LLDB Official Documentation** : https://lldb.llvm.org/
- **LLDB Tutorial** : https://lldb.llvm.org/use/tutorial.html
- **LLDB Command Reference** : https://lldb.llvm.org/use/map.html

### Communaut√©

- **Stack Overflow** : Questions avec le tag [lldb]
- **Forums Embarcadero** : Section Debugging
- **LLDB Mailing List** : lldb-dev@lists.llvm.org

### Cheat sheets

Cr√©ez votre propre cheat sheet avec vos commandes pr√©f√©r√©es. Voici un exemple de d√©part :

```
=== LLDB Quick Reference ===

Navigation:
  continue (c)     - Continue execution
  step (s)         - Step into
  next (n)         - Step over
  finish           - Step out

Inspection:
  bt               - Backtrace
  frame variable   - Show local variables
  expr <expr>      - Evaluate expression
  thread list      - List all threads

Breakpoints:
  br s -f file.pas -l 42           - Set breakpoint
  br s -n FunctionName              - Break on function
  br s -f file.pas -l 42 -c "x>10" - Conditional
  br list                           - List all
  br delete <n>                     - Delete breakpoint

Watchpoints:
  watchpoint set variable <var>     - Watch variable
  watchpoint list                   - List all
  watchpoint delete <n>             - Delete watchpoint

Threads:
  thread select <n>      - Select thread
  thread backtrace all   - All stacks
  thread continue <n>    - Continue one thread

Memory:
  memory read <addr>     - Read memory
  memory write <addr> <val> - Write memory
```

## Conclusion

LLDB v12 est un outil de d√©bogage extraordinairement puissant qui vous donne un contr√¥le total sur l'ex√©cution de vos applications Delphi sur macOS, iOS, Linux et Android. Bien que son interface en ligne de commande puisse sembler intimidante au d√©but, les capacit√©s qu'elle offre en font un atout inestimable pour le d√©bogage de probl√®mes complexes.

**Points cl√©s √† retenir :**

**Nouveaut√©s v12 :** LLDB v12 apporte des am√©liorations significatives en performance, stabilit√© et support des types Delphi.

**Commandes essentielles :** Ma√Ætrisez d'abord `bt`, `frame variable`, `expr`, et `thread list` avant d'explorer les fonctionnalit√©s avanc√©es.

**Breakpoints avanc√©s :** Les conditions, compteurs et commandes automatiques rendent les breakpoints extr√™mement flexibles.

**Watchpoints :** Surveillez les modifications m√©moire pour trouver les bugs insaisissables.

**Multi-threading :** LLDB offre des outils excellents pour d√©boguer les applications multi-thread et diagnostiquer les deadlocks.

**Scripting :** L'int√©gration Python permet d'automatiser des t√¢ches complexes et de cr√©er des outils personnalis√©s.

**Pratique progressive :** Commencez par les bases et ajoutez progressivement des techniques avanc√©es √† votre workflow.

**Documentation :** Utilisez `help` g√©n√©reusement et consultez la documentation officielle pour approfondir.

En ma√Ætrisant LLDB, vous rejoignez les rangs des d√©veloppeurs capables de r√©soudre m√™me les bugs les plus difficiles et obscurs. C'est un investissement en temps qui rapporte √©norm√©ment, particuli√®rement pour le d√©veloppement multi-plateformes avec Delphi. Pratiquez r√©guli√®rement, exp√©rimentez avec les diff√©rentes commandes, et vous d√©couvrirez rapidement que LLDB devient un outil indispensable dans votre arsenal de d√©bogage.

‚è≠Ô∏è [Tests d'int√©gration](/12-debogage-et-tests/07-tests-dintegration.md)
