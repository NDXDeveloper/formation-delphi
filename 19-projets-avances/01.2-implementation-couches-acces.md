üîù Retour au [Sommaire](/SOMMAIRE.md)

# 19.1.2 Impl√©mentation des couches d'acc√®s

## Introduction

L'impl√©mentation des couches d'acc√®s aux donn√©es est l'√©tape qui transforme notre conception de base de donn√©es en code Delphi fonctionnel. Cette couche fait le lien entre votre interface utilisateur et la base de donn√©es MySQL/MariaDB. Une bonne architecture des couches d'acc√®s rend votre application plus maintenable, testable et √©volutive.

## Qu'est-ce qu'une couche d'acc√®s aux donn√©es ?

Une couche d'acc√®s aux donn√©es (DAL - Data Access Layer) est un ensemble de classes et de modules qui :
- Encapsulent toutes les interactions avec la base de donn√©es
- Isolent le code m√©tier de la technologie d'acc√®s aux donn√©es
- Fournissent une API claire et simple pour manipuler les donn√©es
- G√®rent les connexions, transactions et erreurs

### Avantages de cette approche

**S√©paration des responsabilit√©s** : Le code de l'interface utilisateur ne contient pas de SQL, le rendant plus lisible.

**R√©utilisabilit√©** : Les m√™mes m√©thodes d'acc√®s peuvent √™tre utilis√©es dans diff√©rentes parties de l'application.

**Testabilit√©** : Vous pouvez tester la logique d'acc√®s aux donn√©es ind√©pendamment de l'interface.

**Maintenabilit√©** : Les modifications de la base de donn√©es sont centralis√©es dans la couche d'acc√®s.

**Changement de SGBD facilit√©** : Si vous devez changer de base de donn√©es, seule la couche d'acc√®s doit √™tre modifi√©e.

## Architecture en couches

Voici l'architecture recommand√©e pour notre application :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Couche Pr√©sentation (UI)      ‚îÇ  ‚Üê Formulaires VCL/FMX
‚îÇ   - Forms                       ‚îÇ
‚îÇ   - Validation interface        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Couche M√©tier (Business)      ‚îÇ  ‚Üê Logique m√©tier
‚îÇ   - R√®gles de gestion           ‚îÇ
‚îÇ   - Calculs                     ‚îÇ
‚îÇ   - Validations m√©tier          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Couche Acc√®s Donn√©es (DAL)    ‚îÇ  ‚Üê Notre focus ici
‚îÇ   - Modules de donn√©es          ‚îÇ
‚îÇ   - Classes DAO                 ‚îÇ
‚îÇ   - Gestion connexions          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Base de donn√©es MySQL/MariaDB ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## FireDAC : Le framework d'acc√®s aux donn√©es de Delphi

FireDAC est le framework moderne d'acc√®s aux donn√©es de Delphi. Il offre :
- Support natif de nombreux SGBD (MySQL, PostgreSQL, SQLite, SQL Server, Oracle, etc.)
- Hautes performances avec pooling de connexions
- Support des transactions
- Chargement asynchrone des donn√©es
- Cache local et mode d√©connect√©
- Param√®tres typ√©s et protection contre l'injection SQL

### Composants FireDAC essentiels

**FDConnection** : G√®re la connexion √† la base de donn√©es

**FDQuery** : Ex√©cute des requ√™tes SELECT et r√©cup√®re des donn√©es

**FDCommand** : Ex√©cute des commandes SQL (INSERT, UPDATE, DELETE) sans retour de donn√©es

**FDStoredProc** : Appelle des proc√©dures stock√©es

**FDTransaction** : G√®re les transactions

**FDPhysMySQLDriverLink** : Active le support MySQL/MariaDB

## √âtape 1 : Configuration de la connexion

### 1.1 Cr√©er un module de donn√©es de connexion

Le module de donn√©es centralise la connexion √† la base de donn√©es.

**File > New > Other > Delphi Projects > Data Module**

Nommez-le `dmConnection` et ajoutez les composants suivants :

```pascal
unit uDMConnection;

interface

uses
  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,
  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,
  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.Phys.MySQL,
  FireDAC.Phys.MySQLDef, FireDAC.VCLUI.Wait, FireDAC.Comp.Client,
  FireDAC.Stan.Param, FireDAC.DatS, FireDAC.DApt.Intf, FireDAC.DApt,
  Data.DB;

type
  TdmConnection = class(TDataModule)
    FDConnection: TFDConnection;
    FDPhysMySQLDriverLink: TFDPhysMySQLDriverLink;
    procedure DataModuleCreate(Sender: TObject);
  private
    { D√©clarations priv√©es }
    FConnected: Boolean;
  public
    { D√©clarations publiques }
    function Connect: Boolean;
    procedure Disconnect;
    function IsConnected: Boolean;
    function StartTransaction: Boolean;
    procedure CommitTransaction;
    procedure RollbackTransaction;
    property Connected: Boolean read FConnected;
  end;

var
  dmConnection: TdmConnection;

implementation

{%CLASSGROUP 'Vcl.Controls.TControl'}

{$R *.dfm}

{ TdmConnection }

procedure TdmConnection.DataModuleCreate(Sender: TObject);
begin
  FConnected := False;

  // Configuration de la connexion MySQL
  FDConnection.Params.Clear;
  FDConnection.Params.Add('Database=gestion_commerciale');
  FDConnection.Params.Add('User_Name=root');
  FDConnection.Params.Add('Password=votre_mot_de_passe');
  FDConnection.Params.Add('Server=localhost');
  FDConnection.Params.Add('Port=3306');
  FDConnection.Params.Add('DriverID=MySQL');

  // Options de connexion
  FDConnection.LoginPrompt := False;
  FDConnection.Connected := False;
end;

function TdmConnection.Connect: Boolean;
begin
  Result := False;

  if FConnected then
  begin
    Result := True;
    Exit;
  end;

  try
    FDConnection.Connected := True;
    FConnected := True;
    Result := True;
  except
    on E: Exception do
    begin
      FConnected := False;
      raise Exception.Create('Erreur de connexion √† la base de donn√©es : ' + E.Message);
    end;
  end;
end;

procedure TdmConnection.Disconnect;
begin
  if FConnected then
  begin
    FDConnection.Connected := False;
    FConnected := False;
  end;
end;

function TdmConnection.IsConnected: Boolean;
begin
  Result := FConnected and FDConnection.Connected;
end;

function TdmConnection.StartTransaction: Boolean;
begin
  Result := False;

  if not IsConnected then
    if not Connect then
      Exit;

  try
    FDConnection.StartTransaction;
    Result := True;
  except
    on E: Exception do
      raise Exception.Create('Erreur lors du d√©marrage de la transaction : ' + E.Message);
  end;
end;

procedure TdmConnection.CommitTransaction;
begin
  if FDConnection.InTransaction then
    FDConnection.Commit;
end;

procedure TdmConnection.RollbackTransaction;
begin
  if FDConnection.InTransaction then
    FDConnection.Rollback;
end;

end.
```

### 1.2 Am√©lioration : Param√®tres de connexion depuis un fichier

Pour plus de flexibilit√©, stockez les param√®tres dans un fichier INI :

```pascal
uses
  System.IniFiles;

procedure TdmConnection.LoadConnectionParams;
var
  IniFile: TIniFile;
  ConfigPath: string;
begin
  ConfigPath := ExtractFilePath(ParamStr(0)) + 'config.ini';

  if not FileExists(ConfigPath) then
    raise Exception.Create('Fichier de configuration introuvable : ' + ConfigPath);

  IniFile := TIniFile.Create(ConfigPath);
  try
    FDConnection.Params.Clear;
    FDConnection.Params.Add('Database=' + IniFile.ReadString('Database', 'Name', 'gestion_commerciale'));
    FDConnection.Params.Add('User_Name=' + IniFile.ReadString('Database', 'Username', 'root'));
    FDConnection.Params.Add('Password=' + IniFile.ReadString('Database', 'Password', ''));
    FDConnection.Params.Add('Server=' + IniFile.ReadString('Database', 'Server', 'localhost'));
    FDConnection.Params.Add('Port=' + IniFile.ReadString('Database', 'Port', '3306'));
    FDConnection.Params.Add('DriverID=MySQL');
  finally
    IniFile.Free;
  end;
end;
```

Fichier `config.ini` :
```ini
[Database]
Name=gestion_commerciale
Username=root
Password=votre_mot_de_passe
Server=localhost
Port=3306
```

## √âtape 2 : Cr√©er des classes entit√©s

Les classes entit√©s repr√©sentent les tables de la base de donn√©es sous forme d'objets Pascal.

### 2.1 Classe TClient

```pascal
unit uClient;

interface

uses
  System.SysUtils, System.Classes;

type
  TTypeClient = (tcParticulier, tcEntreprise);

  TClient = class
  private
    FIdClient: Integer;
    FCodeClient: string;
    FNom: string;
    FPrenom: string;
    FRaisonSociale: string;
    FTypeClient: TTypeClient;
    FEmail: string;
    FTelephone: string;
    FAdresse: string;
    FCodePostal: string;
    FVille: string;
    FPays: string;
    FActif: Boolean;
    FDateCreation: TDateTime;
  public
    constructor Create;

    // Propri√©t√©s
    property IdClient: Integer read FIdClient write FIdClient;
    property CodeClient: string read FCodeClient write FCodeClient;
    property Nom: string read FNom write FNom;
    property Prenom: string read FPrenom write FPrenom;
    property RaisonSociale: string read FRaisonSociale write FRaisonSociale;
    property TypeClient: TTypeClient read FTypeClient write FTypeClient;
    property Email: string read FEmail write FEmail;
    property Telephone: string read FTelephone write FTelephone;
    property Adresse: string read FAdresse write FAdresse;
    property CodePostal: string read FCodePostal write FCodePostal;
    property Ville: string read FVille write FVille;
    property Pays: string read FPays write FPays;
    property Actif: Boolean read FActif write FActif;
    property DateCreation: TDateTime read FDateCreation write FDateCreation;

    // M√©thodes utilitaires
    function GetNomComplet: string;
    function IsEntreprise: Boolean;
  end;

implementation

{ TClient }

constructor TClient.Create;
begin
  inherited Create;
  FIdClient := 0;
  FActif := True;
  FPays := 'France';
  FTypeClient := tcParticulier;
  FDateCreation := Now;
end;

function TClient.GetNomComplet: string;
begin
  if IsEntreprise then
    Result := FRaisonSociale
  else
    Result := Trim(FPrenom + ' ' + FNom);
end;

function TClient.IsEntreprise: Boolean;
begin
  Result := (FTypeClient = tcEntreprise);
end;

end.
```

### 2.2 Classe TProduit

```pascal
unit uProduit;

interface

uses
  System.SysUtils, System.Classes;

type
  TProduit = class
  private
    FIdProduit: Integer;
    FReference: string;
    FNomProduit: string;
    FDescription: string;
    FIdCategorie: Integer;
    FPrixUnitaire: Currency;
    FPrixAchat: Currency;
    FQuantiteStock: Integer;
    FStockMinimum: Integer;
    FIdFournisseur: Integer;
    FImageUrl: string;
    FActif: Boolean;
    FDateCreation: TDateTime;
  public
    constructor Create;

    property IdProduit: Integer read FIdProduit write FIdProduit;
    property Reference: string read FReference write FReference;
    property NomProduit: string read FNomProduit write FNomProduit;
    property Description: string read FDescription write FDescription;
    property IdCategorie: Integer read FIdCategorie write FIdCategorie;
    property PrixUnitaire: Currency read FPrixUnitaire write FPrixUnitaire;
    property PrixAchat: Currency read FPrixAchat write FPrixAchat;
    property QuantiteStock: Integer read FQuantiteStock write FQuantiteStock;
    property StockMinimum: Integer read FStockMinimum write FStockMinimum;
    property IdFournisseur: Integer read FIdFournisseur write FIdFournisseur;
    property ImageUrl: string read FImageUrl write FImageUrl;
    property Actif: Boolean read FActif write FActif;
    property DateCreation: TDateTime read FDateCreation write FDateCreation;

    function GetMarge: Currency;
    function EstEnRupture: Boolean;
    function EstSousStockMinimum: Boolean;
  end;

implementation

{ TProduit }

constructor TProduit.Create;
begin
  inherited Create;
  FIdProduit := 0;
  FActif := True;
  FStockMinimum := 0;
  FQuantiteStock := 0;
  FDateCreation := Now;
end;

function TProduit.GetMarge: Currency;
begin
  if FPrixAchat > 0 then
    Result := FPrixUnitaire - FPrixAchat
  else
    Result := 0;
end;

function TProduit.EstEnRupture: Boolean;
begin
  Result := (FQuantiteStock <= 0);
end;

function TProduit.EstSousStockMinimum: Boolean;
begin
  Result := (FQuantiteStock < FStockMinimum);
end;

end.
```

## √âtape 3 : Le pattern DAO (Data Access Object)

Le pattern DAO encapsule l'acc√®s aux donn√©es pour chaque entit√©.

### 3.1 Interface de base pour tous les DAO

```pascal
unit uBaseDAO;

interface

uses
  System.Generics.Collections;

type
  IBaseDAO<T: class> = interface
    ['{8F5A7B2C-3D4E-4F5A-9B1C-2E6D8A9F0B1C}']
    function GetById(AId: Integer): T;
    function GetAll: TList<T>;
    function Insert(AEntity: T): Integer;
    function Update(AEntity: T): Boolean;
    function Delete(AId: Integer): Boolean;
  end;

implementation

end.
```

### 3.2 DAO pour les clients

```pascal
unit uClientDAO;

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections,
  FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Param,
  FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,
  FireDAC.Comp.DataSet, FireDAC.Comp.Client, Data.DB,
  uClient, uBaseDAO, uDMConnection;

type
  TClientDAO = class(TInterfacedObject, IBaseDAO<TClient>)
  private
    FConnection: TdmConnection;
    function ClientFromDataSet(ADataSet: TDataSet): TClient;
    function TypeClientFromString(const AValue: string): TTypeClient;
    function TypeClientToString(ATypeClient: TTypeClient): string;
  public
    constructor Create(AConnection: TdmConnection);

    // Impl√©mentation de IBaseDAO
    function GetById(AId: Integer): TClient;
    function GetAll: TList<TClient>;
    function Insert(AEntity: TClient): Integer;
    function Update(AEntity: TClient): Boolean;
    function Delete(AId: Integer): Boolean;

    // M√©thodes sp√©cifiques aux clients
    function GetByCode(const ACode: string): TClient;
    function GetByEmail(const AEmail: string): TClient;
    function Search(const ASearchText: string): TList<TClient>;
    function GetClientsActifs: TList<TClient>;
  end;

implementation

{ TClientDAO }

constructor TClientDAO.Create(AConnection: TdmConnection);
begin
  inherited Create;
  FConnection := AConnection;
end;

function TClientDAO.ClientFromDataSet(ADataSet: TDataSet): TClient;
begin
  Result := TClient.Create;

  Result.IdClient := ADataSet.FieldByName('id_client').AsInteger;
  Result.CodeClient := ADataSet.FieldByName('code_client').AsString;
  Result.Nom := ADataSet.FieldByName('nom').AsString;
  Result.Prenom := ADataSet.FieldByName('prenom').AsString;
  Result.RaisonSociale := ADataSet.FieldByName('raison_sociale').AsString;
  Result.TypeClient := TypeClientFromString(ADataSet.FieldByName('type_client').AsString);
  Result.Email := ADataSet.FieldByName('email').AsString;
  Result.Telephone := ADataSet.FieldByName('telephone').AsString;
  Result.Adresse := ADataSet.FieldByName('adresse').AsString;
  Result.CodePostal := ADataSet.FieldByName('code_postal').AsString;
  Result.Ville := ADataSet.FieldByName('ville').AsString;
  Result.Pays := ADataSet.FieldByName('pays').AsString;
  Result.Actif := ADataSet.FieldByName('actif').AsBoolean;
  Result.DateCreation := ADataSet.FieldByName('date_creation').AsDateTime;
end;

function TClientDAO.TypeClientFromString(const AValue: string): TTypeClient;
begin
  if AValue = 'entreprise' then
    Result := tcEntreprise
  else
    Result := tcParticulier;
end;

function TClientDAO.TypeClientToString(ATypeClient: TTypeClient): string;
begin
  if ATypeClient = tcEntreprise then
    Result := 'entreprise'
  else
    Result := 'particulier';
end;

function TClientDAO.GetById(AId: Integer): TClient;
var
  Query: TFDQuery;
begin
  Result := nil;
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection.FDConnection;
    Query.SQL.Text :=
      'SELECT * FROM CLIENTS WHERE id_client = :id';
    Query.ParamByName('id').AsInteger := AId;
    Query.Open;

    if not Query.IsEmpty then
      Result := ClientFromDataSet(Query);
  finally
    Query.Free;
  end;
end;

function TClientDAO.GetAll: TList<TClient>;
var
  Query: TFDQuery;
begin
  Result := TList<TClient>.Create;
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection.FDConnection;
    Query.SQL.Text :=
      'SELECT * FROM CLIENTS ORDER BY nom, prenom';
    Query.Open;

    while not Query.Eof do
    begin
      Result.Add(ClientFromDataSet(Query));
      Query.Next;
    end;
  finally
    Query.Free;
  end;
end;

function TClientDAO.Insert(AEntity: TClient): Integer;
var
  Query: TFDQuery;
begin
  Result := 0;
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection.FDConnection;
    Query.SQL.Text :=
      'INSERT INTO CLIENTS ' +
      '(code_client, nom, prenom, raison_sociale, type_client, email, ' +
      'telephone, adresse, code_postal, ville, pays, actif) ' +
      'VALUES ' +
      '(:code_client, :nom, :prenom, :raison_sociale, :type_client, :email, ' +
      ':telephone, :adresse, :code_postal, :ville, :pays, :actif)';

    Query.ParamByName('code_client').AsString := AEntity.CodeClient;
    Query.ParamByName('nom').AsString := AEntity.Nom;
    Query.ParamByName('prenom').AsString := AEntity.Prenom;
    Query.ParamByName('raison_sociale').AsString := AEntity.RaisonSociale;
    Query.ParamByName('type_client').AsString := TypeClientToString(AEntity.TypeClient);
    Query.ParamByName('email').AsString := AEntity.Email;
    Query.ParamByName('telephone').AsString := AEntity.Telephone;
    Query.ParamByName('adresse').AsString := AEntity.Adresse;
    Query.ParamByName('code_postal').AsString := AEntity.CodePostal;
    Query.ParamByName('ville').AsString := AEntity.Ville;
    Query.ParamByName('pays').AsString := AEntity.Pays;
    Query.ParamByName('actif').AsBoolean := AEntity.Actif;

    Query.ExecSQL;

    // R√©cup√©rer l'ID auto-g√©n√©r√©
    Query.SQL.Text := 'SELECT LAST_INSERT_ID() AS last_id';
    Query.Open;
    Result := Query.FieldByName('last_id').AsInteger;
    AEntity.IdClient := Result;
  finally
    Query.Free;
  end;
end;

function TClientDAO.Update(AEntity: TClient): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection.FDConnection;
    Query.SQL.Text :=
      'UPDATE CLIENTS SET ' +
      'code_client = :code_client, ' +
      'nom = :nom, ' +
      'prenom = :prenom, ' +
      'raison_sociale = :raison_sociale, ' +
      'type_client = :type_client, ' +
      'email = :email, ' +
      'telephone = :telephone, ' +
      'adresse = :adresse, ' +
      'code_postal = :code_postal, ' +
      'ville = :ville, ' +
      'pays = :pays, ' +
      'actif = :actif ' +
      'WHERE id_client = :id_client';

    Query.ParamByName('id_client').AsInteger := AEntity.IdClient;
    Query.ParamByName('code_client').AsString := AEntity.CodeClient;
    Query.ParamByName('nom').AsString := AEntity.Nom;
    Query.ParamByName('prenom').AsString := AEntity.Prenom;
    Query.ParamByName('raison_sociale').AsString := AEntity.RaisonSociale;
    Query.ParamByName('type_client').AsString := TypeClientToString(AEntity.TypeClient);
    Query.ParamByName('email').AsString := AEntity.Email;
    Query.ParamByName('telephone').AsString := AEntity.Telephone;
    Query.ParamByName('adresse').AsString := AEntity.Adresse;
    Query.ParamByName('code_postal').AsString := AEntity.CodePostal;
    Query.ParamByName('ville').AsString := AEntity.Ville;
    Query.ParamByName('pays').AsString := AEntity.Pays;
    Query.ParamByName('actif').AsBoolean := AEntity.Actif;

    Query.ExecSQL;
    Result := (Query.RowsAffected > 0);
  finally
    Query.Free;
  end;
end;

function TClientDAO.Delete(AId: Integer): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection.FDConnection;

    // Suppression logique (recommand√©e)
    Query.SQL.Text :=
      'UPDATE CLIENTS SET actif = 0 WHERE id_client = :id';
    Query.ParamByName('id').AsInteger := AId;
    Query.ExecSQL;

    // Ou suppression physique (d√©commenter si n√©cessaire)
    // Query.SQL.Text := 'DELETE FROM CLIENTS WHERE id_client = :id';
    // Query.ParamByName('id').AsInteger := AId;
    // Query.ExecSQL;

    Result := (Query.RowsAffected > 0);
  finally
    Query.Free;
  end;
end;

function TClientDAO.GetByCode(const ACode: string): TClient;
var
  Query: TFDQuery;
begin
  Result := nil;
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection.FDConnection;
    Query.SQL.Text :=
      'SELECT * FROM CLIENTS WHERE code_client = :code';
    Query.ParamByName('code').AsString := ACode;
    Query.Open;

    if not Query.IsEmpty then
      Result := ClientFromDataSet(Query);
  finally
    Query.Free;
  end;
end;

function TClientDAO.GetByEmail(const AEmail: string): TClient;
var
  Query: TFDQuery;
begin
  Result := nil;
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection.FDConnection;
    Query.SQL.Text :=
      'SELECT * FROM CLIENTS WHERE email = :email';
    Query.ParamByName('email').AsString := AEmail;
    Query.Open;

    if not Query.IsEmpty then
      Result := ClientFromDataSet(Query);
  finally
    Query.Free;
  end;
end;

function TClientDAO.Search(const ASearchText: string): TList<TClient>;
var
  Query: TFDQuery;
  SearchPattern: string;
begin
  Result := TList<TClient>.Create;
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection.FDConnection;
    SearchPattern := '%' + ASearchText + '%';

    Query.SQL.Text :=
      'SELECT * FROM CLIENTS ' +
      'WHERE nom LIKE :search ' +
      'OR prenom LIKE :search ' +
      'OR raison_sociale LIKE :search ' +
      'OR email LIKE :search ' +
      'OR code_client LIKE :search ' +
      'ORDER BY nom, prenom';

    Query.ParamByName('search').AsString := SearchPattern;
    Query.Open;

    while not Query.Eof do
    begin
      Result.Add(ClientFromDataSet(Query));
      Query.Next;
    end;
  finally
    Query.Free;
  end;
end;

function TClientDAO.GetClientsActifs: TList<TClient>;
var
  Query: TFDQuery;
begin
  Result := TList<TClient>.Create;
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection.FDConnection;
    Query.SQL.Text :=
      'SELECT * FROM CLIENTS WHERE actif = 1 ORDER BY nom, prenom';
    Query.Open;

    while not Query.Eof do
    begin
      Result.Add(ClientFromDataSet(Query));
      Query.Next;
    end;
  finally
    Query.Free;
  end;
end;

end.
```

## √âtape 4 : Gestion des transactions

Les transactions garantissent l'int√©grit√© des donn√©es lors d'op√©rations multiples.

### 4.1 Exemple de transaction simple

```pascal
procedure EnregistrerCommandeAvecTransaction(ACommande: TCommande);
var
  CommandeDAO: TCommandeDAO;
  LigneDAO: TLigneCommandeDAO;
  Ligne: TLigneCommande;
begin
  if not dmConnection.StartTransaction then
    raise Exception.Create('Impossible de d√©marrer la transaction');

  try
    CommandeDAO := TCommandeDAO.Create(dmConnection);
    LigneDAO := TLigneCommandeDAO.Create(dmConnection);
    try
      // Ins√©rer la commande
      ACommande.IdCommande := CommandeDAO.Insert(ACommande);

      // Ins√©rer chaque ligne de commande
      for Ligne in ACommande.Lignes do
      begin
        Ligne.IdCommande := ACommande.IdCommande;
        LigneDAO.Insert(Ligne);
      end;

      // Tout s'est bien pass√©, on valide
      dmConnection.CommitTransaction;
    finally
      LigneDAO.Free;
      CommandeDAO.Free;
    end;
  except
    on E: Exception do
    begin
      // En cas d'erreur, on annule tout
      dmConnection.RollbackTransaction;
      raise Exception.Create('Erreur lors de l''enregistrement de la commande : ' + E.Message);
    end;
  end;
end;
```

### 4.2 Classe helper pour simplifier les transactions

```pascal
unit uTransactionHelper;

interface

uses
  System.SysUtils, uDMConnection;

type
  TTransactionHelper = class
  public
    class procedure ExecuteInTransaction(AConnection: TdmConnection;
      AProc: TProc); static;
  end;

implementation

{ TTransactionHelper }

class procedure TTransactionHelper.ExecuteInTransaction(
  AConnection: TdmConnection; AProc: TProc);
begin
  if not AConnection.StartTransaction then
    raise Exception.Create('Impossible de d√©marrer la transaction');

  try
    AProc();
    AConnection.CommitTransaction;
  except
    on E: Exception do
    begin
      AConnection.RollbackTransaction;
      raise;
    end;
  end;
end;

end.
```

Utilisation :

```pascal
TTransactionHelper.ExecuteInTransaction(dmConnection,
  procedure
  begin
    // Toutes vos op√©rations ici
    ClientDAO.Insert(Client);
    // ...
  end
);
```

## √âtape 5 : Le pattern Repository

Le pattern Repository offre une abstraction suppl√©mentaire au-dessus des DAO.

### 5.1 Classe Repository pour les clients

```pascal
unit uClientRepository;

interface

uses
  System.SysUtils, System.Generics.Collections,
  uClient, uClientDAO, uDMConnection;

type
  TClientRepository = class
  private
    FConnection: TdmConnection;
    FDAO: TClientDAO;
  public
    constructor Create(AConnection: TdmConnection);
    destructor Destroy; override;

    // Op√©rations de base
    function GetClient(AId: Integer): TClient;
    function GetAllClients: TList<TClient>;
    function SaveClient(AClient: TClient): Boolean;
    function DeleteClient(AId: Integer): Boolean;

    // Op√©rations m√©tier
    function SearchClients(const ASearchText: string): TList<TClient>;
    function GetActiveClients: TList<TClient>;
    function GenerateClientCode: string;
    function ValidateClient(AClient: TClient; out AErrors: TStringList): Boolean;
    function ClientExists(const AEmail: string): Boolean;
  end;

implementation

{ TClientRepository }

constructor TClientRepository.Create(AConnection: TdmConnection);
begin
  inherited Create;
  FConnection := AConnection;
  FDAO := TClientDAO.Create(FConnection);
end;

destructor TClientRepository.Destroy;
begin
  FDAO.Free;
  inherited;
end;

function TClientRepository.GetClient(AId: Integer): TClient;
begin
  Result := FDAO.GetById(AId);
  if Result = nil then
    raise Exception.CreateFmt('Client avec ID %d introuvable', [AId]);
end;

function TClientRepository.GetAllClients: TList<TClient>;
begin
  Result := FDAO.GetAll;
end;

function TClientRepository.SaveClient(AClient: TClient): Boolean;
begin
  // Validation
  if not ValidateClient(AClient, nil) then
    raise Exception.Create('Donn√©es client invalides');

  // Insertion ou mise √† jour
  if AClient.IdClient = 0 then
  begin
    // Nouveau client
    if AClient.CodeClient = '' then
      AClient.CodeClient := GenerateClientCode;

    AClient.IdClient := FDAO.Insert(AClient);
    Result := (AClient.IdClient > 0);
  end
  else
  begin
    // Client existant
    Result := FDAO.Update(AClient);
  end;
end;

function TClientRepository.DeleteClient(AId: Integer): Boolean;
begin
  Result := FDAO.Delete(AId);
end;

function TClientRepository.SearchClients(const ASearchText: string): TList<TClient>;
begin
  if Trim(ASearchText) = '' then
    Result := FDAO.GetAll
  else
    Result := FDAO.Search(ASearchText);
end;

function TClientRepository.GetActiveClients: TList<TClient>;
begin
  Result := FDAO.GetClientsActifs;
end;

function TClientRepository.GenerateClientCode: string;
var
  Query: TFDQuery;
  MaxNumber: Integer;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection.FDConnection;
    Query.SQL.Text :=
      'SELECT MAX(CAST(SUBSTRING(code_client, 4) AS UNSIGNED)) AS max_num ' +
      'FROM CLIENTS WHERE code_client LIKE ''CLI%''';
    Query.Open;

    if Query.FieldByName('max_num').IsNull then
      MaxNumber := 0
    else
      MaxNumber := Query.FieldByName('max_num').AsInteger;

    Result := Format('CLI%6.6d', [MaxNumber + 1]);
  finally
    Query.Free;
  end;
end;

function TClientRepository.ValidateClient(AClient: TClient;
  out AErrors: TStringList): Boolean;
begin
  if Assigned(AErrors) then
    AErrors.Clear
  else
    AErrors := TStringList.Create;

  // Validation du nom
  if Trim(AClient.Nom) = '' then
    AErrors.Add('Le nom est obligatoire');

  // Validation de l''email
  if Trim(AClient.Email) <> '' then
  begin
    if Pos('@', AClient.Email) = 0 then
      AErrors.Add('Format d''email invalide');
  end;

  // Validation du type client
  if AClient.IsEntreprise and (Trim(AClient.RaisonSociale) = '') then
    AErrors.Add('La raison sociale est obligatoire pour une entreprise');

  Result := (AErrors.Count = 0);
end;

function TClientRepository.ClientExists(const AEmail: string): Boolean;
var
  Client: TClient;
begin
  Client := FDAO.GetByEmail(AEmail);
  Result := Assigned(Client);
  if Assigned(Client) then
    Client.Free;
end;

end.
```

## √âtape 6 : Utilisation dans l'interface utilisateur

### 6.1 Exemple de formulaire de gestion des clients

```pascal
unit uFormClients;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,
  Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Grids, Vcl.DBGrids, System.Generics.Collections,
  uClient, uClientRepository, uDMConnection;

type
  TFormClients = class(TForm)
    pnlTop: TPanel;
    btnNouveau: TButton;
    btnModifier: TButton;
    btnSupprimer: TButton;
    edtRecherche: TEdit;
    btnRechercher: TButton;
    gridClients: TStringGrid;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure btnNouveauClick(Sender: TObject);
    procedure btnModifierClick(Sender: TObject);
    procedure btnSupprimerClick(Sender: TObject);
    procedure btnRechercherClick(Sender: TObject);
  private
    FRepository: TClientRepository;
    FClients: TList<TClient>;

    procedure LoadClients;
    procedure DisplayClients;
    procedure ClearClients;
    function GetSelectedClientId: Integer;
  public
    { D√©clarations publiques }
  end;

var
  FormClients: TFormClients;

implementation

{$R *.dfm}

uses
  uFormClientEdit;

{ TFormClients }

procedure TFormClients.FormCreate(Sender: TObject);
begin
  FRepository := TClientRepository.Create(dmConnection);
  FClients := TList<TClient>.Create;

  // Configuration de la grille
  gridClients.RowCount := 1;
  gridClients.ColCount := 7;
  gridClients.Cells[0, 0] := 'ID';
  gridClients.Cells[1, 0] := 'Code';
  gridClients.Cells[2, 0] := 'Nom';
  gridClients.Cells[3, 0] := 'Pr√©nom';
  gridClients.Cells[4, 0] := 'Email';
  gridClients.Cells[5, 0] := 'T√©l√©phone';
  gridClients.Cells[6, 0] := 'Ville';

  LoadClients;
end;

procedure TFormClients.FormDestroy(Sender: TObject);
begin
  ClearClients;
  FClients.Free;
  FRepository.Free;
end;

procedure TFormClients.LoadClients;
begin
  ClearClients;

  try
    FClients := FRepository.GetActiveClients;
    DisplayClients;
  except
    on E: Exception do
      ShowMessage('Erreur lors du chargement des clients : ' + E.Message);
  end;
end;

procedure TFormClients.DisplayClients;
var
  I: Integer;
  Client: TClient;
begin
  gridClients.RowCount := FClients.Count + 1;

  for I := 0 to FClients.Count - 1 do
  begin
    Client := FClients[I];
    gridClients.Cells[0, I + 1] := IntToStr(Client.IdClient);
    gridClients.Cells[1, I + 1] := Client.CodeClient;
    gridClients.Cells[2, I + 1] := Client.Nom;
    gridClients.Cells[3, I + 1] := Client.Prenom;
    gridClients.Cells[4, I + 1] := Client.Email;
    gridClients.Cells[5, I + 1] := Client.Telephone;
    gridClients.Cells[6, I + 1] := Client.Ville;
  end;
end;

procedure TFormClients.ClearClients;
var
  Client: TClient;
begin
  for Client in FClients do
    Client.Free;
  FClients.Clear;
end;

function TFormClients.GetSelectedClientId: Integer;
var
  Row: Integer;
begin
  Result := 0;
  Row := gridClients.Row;

  if (Row > 0) and (Row < gridClients.RowCount) then
    Result := StrToIntDef(gridClients.Cells[0, Row], 0);
end;

procedure TFormClients.btnNouveauClick(Sender: TObject);
var
  FormEdit: TFormClientEdit;
begin
  FormEdit := TFormClientEdit.Create(Self);
  try
    FormEdit.IsNewClient := True;
    if FormEdit.ShowModal = mrOk then
      LoadClients;
  finally
    FormEdit.Free;
  end;
end;

procedure TFormClients.btnModifierClick(Sender: TObject);
var
  FormEdit: TFormClientEdit;
  ClientId: Integer;
begin
  ClientId := GetSelectedClientId;
  if ClientId = 0 then
  begin
    ShowMessage('Veuillez s√©lectionner un client');
    Exit;
  end;

  FormEdit := TFormClientEdit.Create(Self);
  try
    FormEdit.IsNewClient := False;
    FormEdit.ClientId := ClientId;
    if FormEdit.ShowModal = mrOk then
      LoadClients;
  finally
    FormEdit.Free;
  end;
end;

procedure TFormClients.btnSupprimerClick(Sender: TObject);
var
  ClientId: Integer;
begin
  ClientId := GetSelectedClientId;
  if ClientId = 0 then
  begin
    ShowMessage('Veuillez s√©lectionner un client');
    Exit;
  end;

  if MessageDlg('√ätes-vous s√ªr de vouloir supprimer ce client ?',
    mtConfirmation, [mbYes, mbNo], 0) = mrYes then
  begin
    try
      if FRepository.DeleteClient(ClientId) then
      begin
        ShowMessage('Client supprim√© avec succ√®s');
        LoadClients;
      end
      else
        ShowMessage('Erreur lors de la suppression du client');
    except
      on E: Exception do
        ShowMessage('Erreur : ' + E.Message);
    end;
  end;
end;

procedure TFormClients.btnRechercherClick(Sender: TObject);
begin
  ClearClients;

  try
    FClients := FRepository.SearchClients(edtRecherche.Text);
    DisplayClients;
  except
    on E: Exception do
      ShowMessage('Erreur lors de la recherche : ' + E.Message);
  end;
end;

end.
```

## Bonnes pratiques

### 1. Gestion des ressources

**Toujours lib√©rer les objets cr√©√©s** :
```pascal
var
  Client: TClient;
begin
  Client := ClientDAO.GetById(1);
  try
    // Utiliser le client
  finally
    Client.Free;  // Lib√©ration garantie
  end;
end;
```

### 2. Gestion des exceptions

**Capturer et g√©rer les exceptions appropri√©es** :
```pascal
try
  Repository.SaveClient(Client);
  ShowMessage('Client enregistr√© avec succ√®s');
except
  on E: EFDDBEngineException do
  begin
    // Erreur base de donn√©es
    if Pos('Duplicate entry', E.Message) > 0 then
      ShowMessage('Ce code client existe d√©j√†')
    else
      ShowMessage('Erreur de base de donn√©es : ' + E.Message);
  end;
  on E: Exception do
    ShowMessage('Erreur : ' + E.Message);
end;
```

### 3. Utilisation de param√®tres

**Toujours utiliser des param√®tres pour √©viter l'injection SQL** :
```pascal
// MAUVAIS - Vuln√©rable √† l'injection SQL
Query.SQL.Text := 'SELECT * FROM CLIENTS WHERE nom = ''' + Nom + '''';

// BON - Utilisation de param√®tres
Query.SQL.Text := 'SELECT * FROM CLIENTS WHERE nom = :nom';
Query.ParamByName('nom').AsString := Nom;
```

### 4. S√©paration des responsabilit√©s

**DAO** : Acc√®s aux donn√©es pur (CRUD)
**Repository** : Logique m√©tier et orchestration
**UI** : Pr√©sentation et interaction utilisateur

### 5. Tests unitaires

Cr√©ez des tests pour vos DAO et Repository :
```pascal
procedure TestClientDAO;
var
  DAO: TClientDAO;
  Client: TClient;
begin
  DAO := TClientDAO.Create(dmConnection);
  try
    Client := TClient.Create;
    try
      Client.CodeClient := 'TEST001';
      Client.Nom := 'Test';
      Client.Prenom := 'Utilisateur';

      // Test insertion
      Client.IdClient := DAO.Insert(Client);
      Assert(Client.IdClient > 0, '√âchec de l''insertion');

      // Test r√©cup√©ration
      var ClientRecup := DAO.GetById(Client.IdClient);
      try
        Assert(ClientRecup.CodeClient = 'TEST001', 'Donn√©es incorrectes');
      finally
        ClientRecup.Free;
      end;

      // Test suppression
      Assert(DAO.Delete(Client.IdClient), '√âchec de la suppression');
    finally
      Client.Free;
    end;
  finally
    DAO.Free;
  end;
end;
```

## Organisation des fichiers

Structure recommand√©e du projet :

```
MonProjet/
‚îú‚îÄ‚îÄ Database/
‚îÇ   ‚îú‚îÄ‚îÄ uDMConnection.pas         // Module de connexion
‚îÇ   ‚îî‚îÄ‚îÄ uDMConnection.dfm
‚îú‚îÄ‚îÄ Entities/
‚îÇ   ‚îú‚îÄ‚îÄ uClient.pas               // Classes entit√©s
‚îÇ   ‚îú‚îÄ‚îÄ uProduit.pas
‚îÇ   ‚îú‚îÄ‚îÄ uCommande.pas
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ DAO/
‚îÇ   ‚îú‚îÄ‚îÄ uBaseDAO.pas              // Interface de base
‚îÇ   ‚îú‚îÄ‚îÄ uClientDAO.pas            // DAO sp√©cifiques
‚îÇ   ‚îú‚îÄ‚îÄ uProduitDAO.pas
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ Repository/
‚îÇ   ‚îú‚îÄ‚îÄ uClientRepository.pas     // Repositories
‚îÇ   ‚îú‚îÄ‚îÄ uProduitRepository.pas
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ Business/
‚îÇ   ‚îî‚îÄ‚îÄ uTransactionHelper.pas    // Helpers et utilitaires
‚îî‚îÄ‚îÄ UI/
    ‚îú‚îÄ‚îÄ Forms/
    ‚îÇ   ‚îú‚îÄ‚îÄ uFormClients.pas      // Formulaires
    ‚îÇ   ‚îî‚îÄ‚îÄ uFormClients.dfm
    ‚îî‚îÄ‚îÄ ...
```

## Conclusion

L'impl√©mentation d'une couche d'acc√®s aux donn√©es structur√©e avec FireDAC vous permet de cr√©er des applications robustes et maintenables. Les patterns DAO et Repository offrent une s√©paration claire des responsabilit√©s et facilitent l'√©volution de votre application.

Les points cl√©s √† retenir :
- Centralisez la connexion dans un module d√©di√©
- Utilisez des classes entit√©s pour repr√©senter vos tables
- Impl√©mentez des DAO pour chaque entit√©
- Ajoutez une couche Repository pour la logique m√©tier
- Utilisez des transactions pour les op√©rations multiples
- Toujours utiliser des param√®tres dans les requ√™tes SQL
- G√©rez correctement les ressources et exceptions
- Documentez votre code

Dans le prochain chapitre, nous verrons comment cr√©er une interface utilisateur √©volu√©e qui exploite cette couche d'acc√®s aux donn√©es.

‚è≠Ô∏è [Interface utilisateur √©volu√©e](/19-projets-avances/01.3-interface-utilisateur-evoluee.md)
