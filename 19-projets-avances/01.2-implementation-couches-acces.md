# 19.1.2 Implémentation des couches d'accès

Dans cette section, nous allons implémenter les couches d'accès aux données pour notre application de gestion. Cette étape est cruciale car elle constitue le pont entre notre base de données MySQL/MariaDB et notre application Delphi.

## Architecture en couches

Avant de commencer le codage, rappelons l'intérêt d'une architecture en couches pour l'accès aux données :

1. **Séparation des préoccupations** : chaque couche a une responsabilité unique
2. **Facilité de maintenance** : vous pouvez modifier une couche sans impacter les autres
3. **Testabilité améliorée** : chaque couche peut être testée indépendamment
4. **Évolutivité** : vous pouvez remplacer la base de données sans réécrire toute l'application

Voici les couches que nous allons implémenter :

![Architecture en couches d'accès](https://via.placeholder.com/600x400)

## Création du module de données principal

Commençons par créer un DataModule qui centralisera notre connexion à la base de données :

1. Dans Delphi, sélectionnez **File > New > Other**
2. Choisissez **Delphi Projects > Data Module**
3. Nommez-le `dmDatabase`

Ajoutez les composants suivants depuis la palette FireDAC :

- `TFDConnection` : pour la connexion à MySQL/MariaDB
- `TFDPhysMySQLDriverLink` : le pilote MySQL
- `TFDGUIxWaitCursor` : pour afficher un curseur d'attente pendant les opérations
- `TFDTransaction` : pour gérer les transactions

Voici le code initial du module de données :

```pascal
unit dmDatabase;

interface

uses
  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,
  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,
  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.Phys.MySQL,
  FireDAC.Phys.MySQLDef, FireDAC.VCLUI.Wait, FireDAC.Comp.UI, FireDAC.Comp.Client,
  Data.DB;

type
  TDataModuleDB = class(TDataModule)
    FDConnection: TFDConnection;
    FDPhysMySQLDriverLink: TFDPhysMySQLDriverLink;
    FDGUIxWaitCursor: TFDGUIxWaitCursor;
    FDTransaction: TFDTransaction;
    procedure DataModuleCreate(Sender: TObject);
  private
    { Déclarations privées }
    procedure LoadConnectionSettings;
  public
    { Déclarations publiques }
    function ConnectToDatabase: Boolean;
    procedure DisconnectFromDatabase;
    function IsConnected: Boolean;
  end;

var
  DataModuleDB: TDataModuleDB;

implementation

{%CLASSGROUP 'Vcl.Controls.TControl'}

{$R *.dfm}

uses
  System.IniFiles;

procedure TDataModuleDB.DataModuleCreate(Sender: TObject);
begin
  LoadConnectionSettings;
end;

procedure TDataModuleDB.LoadConnectionSettings;
var
  IniFile: TIniFile;
  ConfigFilePath: string;
begin
  ConfigFilePath := ChangeFileExt(ParamStr(0), '.ini');
  if FileExists(ConfigFilePath) then
  begin
    IniFile := TIniFile.Create(ConfigFilePath);
    try
      FDConnection.Params.Clear;
      FDConnection.Params.Add('DriverID=MySQL');
      FDConnection.Params.Add('Server=' + IniFile.ReadString('Database', 'Server', 'localhost'));
      FDConnection.Params.Add('Port=' + IniFile.ReadString('Database', 'Port', '3306'));
      FDConnection.Params.Add('Database=' + IniFile.ReadString('Database', 'Database', 'GestionCommerce'));
      FDConnection.Params.Add('User_Name=' + IniFile.ReadString('Database', 'User', 'app_gestion'));
      FDConnection.Params.Add('Password=' + IniFile.ReadString('Database', 'Password', ''));
      FDConnection.Params.Add('CharacterSet=utf8mb4');
    finally
      IniFile.Free;
    end;
  end
  else
  begin
    // Configuration par défaut si le fichier INI n'existe pas
    FDConnection.Params.Clear;
    FDConnection.Params.Add('DriverID=MySQL');
    FDConnection.Params.Add('Server=localhost');
    FDConnection.Params.Add('Port=3306');
    FDConnection.Params.Add('Database=GestionCommerce');
    FDConnection.Params.Add('User_Name=app_gestion');
    FDConnection.Params.Add('Password=mot_de_passe_securise');
    FDConnection.Params.Add('CharacterSet=utf8mb4');
  end;
end;

function TDataModuleDB.ConnectToDatabase: Boolean;
begin
  Result := False;
  try
    if not FDConnection.Connected then
      FDConnection.Connected := True;
    Result := FDConnection.Connected;
  except
    on E: Exception do
    begin
      // Traitement des erreurs de connexion
      ShowMessage('Erreur de connexion à la base de données : ' + E.Message);
    end;
  end;
end;

procedure TDataModuleDB.DisconnectFromDatabase;
begin
  if FDConnection.Connected then
    FDConnection.Connected := False;
end;

function TDataModuleDB.IsConnected: Boolean;
begin
  Result := FDConnection.Connected;
end;

end.
```

## Création du fichier INI de configuration

Pour sécuriser les informations de connexion, nous utiliserons un fichier de configuration externe. Créez un fichier nommé `AppGestion.ini` avec ce contenu :

```ini
[Database]
Server=localhost
Port=3306
Database=GestionCommerce
User=app_gestion
Password=mot_de_passe_securise
```

> **Sécurité** : Dans une application de production, vous devriez envisager de chiffrer le mot de passe dans le fichier INI.

## Création des classes d'entités

Maintenant, créons des classes qui représentent nos entités principales. Ces classes font partie de la couche métier mais sont essentielles pour l'accès aux données.

Créez un dossier `Business` dans votre projet et ajoutez la classe `Produit.pas` :

```pascal
unit Produit;

interface

uses
  System.SysUtils, System.Classes;

type
  TProduit = class
  private
    FProduitID: Integer;
    FReference: string;
    FDesignation: string;
    FDescription: string;
    FPrixAchat: Double;
    FPrixVente: Double;
    FTVA: Double;
    FCategoryID: Integer;
    FFournisseurID: Integer;
    FPhotoURL: string;
    FDateCreation: TDateTime;
    FActif: Boolean;
  public
    constructor Create; overload;
    constructor Create(AProduitID: Integer; AReference, ADesignation: string); overload;
    property ProduitID: Integer read FProduitID write FProduitID;
    property Reference: string read FReference write FReference;
    property Designation: string read FDesignation write FDesignation;
    property Description: string read FDescription write FDescription;
    property PrixAchat: Double read FPrixAchat write FPrixAchat;
    property PrixVente: Double read FPrixVente write FPrixVente;
    property TVA: Double read FTVA write FTVA;
    property CategoryID: Integer read FCategoryID write FCategoryID;
    property FournisseurID: Integer read FFournisseurID write FFournisseurID;
    property PhotoURL: string read FPhotoURL write FPhotoURL;
    property DateCreation: TDateTime read FDateCreation write FDateCreation;
    property Actif: Boolean read FActif write FActif;

    function CalculerPrixTTC: Double;
    function CalculerMarge: Double;
  end;

implementation

constructor TProduit.Create;
begin
  inherited;
  FProduitID := 0;
  FReference := '';
  FDesignation := '';
  FDescription := '';
  FPrixAchat := 0;
  FPrixVente := 0;
  FTVA := 20; // 20% par défaut
  FCategoryID := 0;
  FFournisseurID := 0;
  FPhotoURL := '';
  FDateCreation := Now;
  FActif := True;
end;

constructor TProduit.Create(AProduitID: Integer; AReference, ADesignation: string);
begin
  Create;
  FProduitID := AProduitID;
  FReference := AReference;
  FDesignation := ADesignation;
end;

function TProduit.CalculerPrixTTC: Double;
begin
  Result := FPrixVente * (1 + (FTVA / 100));
end;

function TProduit.CalculerMarge: Double;
begin
  if FPrixAchat > 0 then
    Result := ((FPrixVente - FPrixAchat) / FPrixAchat) * 100
  else
    Result := 0;
end;

end.
```

Créez des classes similaires pour les autres entités (Client, Commande, etc.) en suivant le même modèle.

## Création des modules d'accès aux données

Maintenant, créons les modules d'accès aux données (DAO - Data Access Object) pour chaque entité. Ces modules seront responsables des opérations CRUD.

Créez un dossier `DataAccess` et ajoutez la classe `DAOProduit.pas` :

```pascal
unit DAOProduit;

interface

uses
  System.SysUtils, System.Classes, Data.DB, FireDAC.Comp.Client,
  FireDAC.Comp.DataSet, FireDAC.DApt, FireDAC.Stan.Param,
  Produit, dmDatabase;

type
  TDAOProduit = class
  private
    FDataModule: TDataModuleDB;
  public
    constructor Create(ADataModule: TDataModuleDB);
    destructor Destroy; override;

    // Opérations CRUD
    function InsererProduit(AProduit: TProduit): Boolean;
    function MettreAJourProduit(AProduit: TProduit): Boolean;
    function SupprimerProduit(AProduitID: Integer): Boolean;
    function ObtenirProduit(AProduitID: Integer): TProduit;
    function ObtenirTousProduits: TFDQuery;
    function ObtenirProduitsParCategorie(ACategorieID: Integer): TFDQuery;
    function ObtenirProduitsParFournisseur(AFournisseurID: Integer): TFDQuery;
    function RechercherProduits(ATerme: string): TFDQuery;
  end;

implementation

constructor TDAOProduit.Create(ADataModule: TDataModuleDB);
begin
  inherited Create;
  FDataModule := ADataModule;
end;

destructor TDAOProduit.Destroy;
begin
  inherited;
end;

function TDAOProduit.InsererProduit(AProduit: TProduit): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  if not FDataModule.IsConnected then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDataModule.FDConnection;
    Query.SQL.Text :=
      'INSERT INTO Produits ' +
      '(Reference, Designation, Description, PrixAchat, PrixVente, TVA, ' +
      'CategoryID, FournisseurID, PhotoURL, DateCreation, Actif) ' +
      'VALUES ' +
      '(:Reference, :Designation, :Description, :PrixAchat, :PrixVente, :TVA, ' +
      ':CategoryID, :FournisseurID, :PhotoURL, :DateCreation, :Actif)';

    Query.ParamByName('Reference').AsString := AProduit.Reference;
    Query.ParamByName('Designation').AsString := AProduit.Designation;
    Query.ParamByName('Description').AsString := AProduit.Description;
    Query.ParamByName('PrixAchat').AsFloat := AProduit.PrixAchat;
    Query.ParamByName('PrixVente').AsFloat := AProduit.PrixVente;
    Query.ParamByName('TVA').AsFloat := AProduit.TVA;
    Query.ParamByName('CategoryID').AsInteger := AProduit.CategoryID;
    Query.ParamByName('FournisseurID').AsInteger := AProduit.FournisseurID;
    Query.ParamByName('PhotoURL').AsString := AProduit.PhotoURL;
    Query.ParamByName('DateCreation').AsDateTime := AProduit.DateCreation;
    Query.ParamByName('Actif').AsBoolean := AProduit.Actif;

    FDataModule.FDTransaction.StartTransaction;
    try
      Query.ExecSQL;
      // Récupérer l'ID généré
      AProduit.ProduitID := FDataModule.FDConnection.GetLastAutoGenValue('');
      FDataModule.FDTransaction.Commit;
      Result := True;
    except
      on E: Exception do
      begin
        FDataModule.FDTransaction.Rollback;
        raise Exception.Create('Erreur lors de l''insertion du produit : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;

function TDAOProduit.MettreAJourProduit(AProduit: TProduit): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  if not FDataModule.IsConnected then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDataModule.FDConnection;
    Query.SQL.Text :=
      'UPDATE Produits SET ' +
      'Reference = :Reference, ' +
      'Designation = :Designation, ' +
      'Description = :Description, ' +
      'PrixAchat = :PrixAchat, ' +
      'PrixVente = :PrixVente, ' +
      'TVA = :TVA, ' +
      'CategoryID = :CategoryID, ' +
      'FournisseurID = :FournisseurID, ' +
      'PhotoURL = :PhotoURL, ' +
      'Actif = :Actif ' +
      'WHERE ProduitID = :ProduitID';

    Query.ParamByName('Reference').AsString := AProduit.Reference;
    Query.ParamByName('Designation').AsString := AProduit.Designation;
    Query.ParamByName('Description').AsString := AProduit.Description;
    Query.ParamByName('PrixAchat').AsFloat := AProduit.PrixAchat;
    Query.ParamByName('PrixVente').AsFloat := AProduit.PrixVente;
    Query.ParamByName('TVA').AsFloat := AProduit.TVA;
    Query.ParamByName('CategoryID').AsInteger := AProduit.CategoryID;
    Query.ParamByName('FournisseurID').AsInteger := AProduit.FournisseurID;
    Query.ParamByName('PhotoURL').AsString := AProduit.PhotoURL;
    Query.ParamByName('Actif').AsBoolean := AProduit.Actif;
    Query.ParamByName('ProduitID').AsInteger := AProduit.ProduitID;

    FDataModule.FDTransaction.StartTransaction;
    try
      Query.ExecSQL;
      FDataModule.FDTransaction.Commit;
      Result := True;
    except
      on E: Exception do
      begin
        FDataModule.FDTransaction.Rollback;
        raise Exception.Create('Erreur lors de la mise à jour du produit : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;

function TDAOProduit.SupprimerProduit(AProduitID: Integer): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  if not FDataModule.IsConnected then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDataModule.FDConnection;
    Query.SQL.Text := 'DELETE FROM Produits WHERE ProduitID = :ProduitID';
    Query.ParamByName('ProduitID').AsInteger := AProduitID;

    FDataModule.FDTransaction.StartTransaction;
    try
      Query.ExecSQL;
      FDataModule.FDTransaction.Commit;
      Result := True;
    except
      on E: Exception do
      begin
        FDataModule.FDTransaction.Rollback;
        raise Exception.Create('Erreur lors de la suppression du produit : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;

function TDAOProduit.ObtenirProduit(AProduitID: Integer): TProduit;
var
  Query: TFDQuery;
begin
  Result := nil;

  if not FDataModule.IsConnected then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDataModule.FDConnection;
    Query.SQL.Text := 'SELECT * FROM Produits WHERE ProduitID = :ProduitID';
    Query.ParamByName('ProduitID').AsInteger := AProduitID;
    Query.Open;

    if not Query.IsEmpty then
    begin
      Result := TProduit.Create;
      Result.ProduitID := Query.FieldByName('ProduitID').AsInteger;
      Result.Reference := Query.FieldByName('Reference').AsString;
      Result.Designation := Query.FieldByName('Designation').AsString;
      Result.Description := Query.FieldByName('Description').AsString;
      Result.PrixAchat := Query.FieldByName('PrixAchat').AsFloat;
      Result.PrixVente := Query.FieldByName('PrixVente').AsFloat;
      Result.TVA := Query.FieldByName('TVA').AsFloat;
      Result.CategoryID := Query.FieldByName('CategoryID').AsInteger;
      Result.FournisseurID := Query.FieldByName('FournisseurID').AsInteger;
      Result.PhotoURL := Query.FieldByName('PhotoURL').AsString;
      Result.DateCreation := Query.FieldByName('DateCreation').AsDateTime;
      Result.Actif := Query.FieldByName('Actif').AsBoolean;
    end;
  finally
    Query.Free;
  end;
end;

function TDAOProduit.ObtenirTousProduits: TFDQuery;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  Query.Connection := FDataModule.FDConnection;
  Query.SQL.Text :=
    'SELECT p.*, c.NomCategorie, f.RaisonSociale AS NomFournisseur ' +
    'FROM Produits p ' +
    'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
    'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
    'ORDER BY p.Designation';
  Query.Open;
  Result := Query;
end;

function TDAOProduit.ObtenirProduitsParCategorie(ACategorieID: Integer): TFDQuery;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  Query.Connection := FDataModule.FDConnection;
  Query.SQL.Text :=
    'SELECT p.*, c.NomCategorie, f.RaisonSociale AS NomFournisseur ' +
    'FROM Produits p ' +
    'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
    'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
    'WHERE p.CategoryID = :CategoryID ' +
    'ORDER BY p.Designation';
  Query.ParamByName('CategoryID').AsInteger := ACategorieID;
  Query.Open;
  Result := Query;
end;

function TDAOProduit.ObtenirProduitsParFournisseur(AFournisseurID: Integer): TFDQuery;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  Query.Connection := FDataModule.FDConnection;
  Query.SQL.Text :=
    'SELECT p.*, c.NomCategorie, f.RaisonSociale AS NomFournisseur ' +
    'FROM Produits p ' +
    'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
    'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
    'WHERE p.FournisseurID = :FournisseurID ' +
    'ORDER BY p.Designation';
  Query.ParamByName('FournisseurID').AsInteger := AFournisseurID;
  Query.Open;
  Result := Query;
end;

function TDAOProduit.RechercherProduits(ATerme: string): TFDQuery;
var
  Query: TFDQuery;
  TermeRecherche: string;
begin
  Query := TFDQuery.Create(nil);
  Query.Connection := FDataModule.FDConnection;

  TermeRecherche := '%' + ATerme + '%';

  Query.SQL.Text :=
    'SELECT p.*, c.NomCategorie, f.RaisonSociale AS NomFournisseur ' +
    'FROM Produits p ' +
    'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
    'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
    'WHERE p.Reference LIKE :Terme ' +
    'OR p.Designation LIKE :Terme ' +
    'OR p.Description LIKE :Terme ' +
    'ORDER BY p.Designation';
  Query.ParamByName('Terme').AsString := TermeRecherche;
  Query.Open;
  Result := Query;
end;

end.
```

Créez des classes DAO similaires pour les autres entités.

## Création d'une couche d'abstraction (Repository)

Pour une meilleure organisation, ajoutons un niveau d'abstraction supplémentaire avec le pattern Repository. Cette couche fera le lien entre la couche métier et les DAOs.

Créez un dossier `Repositories` et ajoutez la classe `ProduitRepository.pas` :

```pascal
unit ProduitRepository;

interface

uses
  System.SysUtils, System.Classes, Data.DB, FireDAC.Comp.Client,
  Produit, DAOProduit, dmDatabase;

type
  TProduitRepository = class
  private
    FDAOProduit: TDAOProduit;
  public
    constructor Create(ADataModule: TDataModuleDB);
    destructor Destroy; override;

    function Ajouter(AProduit: TProduit): Boolean;
    function Modifier(AProduit: TProduit): Boolean;
    function Supprimer(AProduitID: Integer): Boolean;
    function ObtenirParID(AProduitID: Integer): TProduit;
    function ObtenirTous: TDataSet;
    function ObtenirParCategorie(ACategorieID: Integer): TDataSet;
    function ObtenirParFournisseur(AFournisseurID: Integer): TDataSet;
    function Rechercher(ATerme: string): TDataSet;
    function VerifierReferenceUnique(AReference: string; AProduitID: Integer = 0): Boolean;
  end;

implementation

constructor TProduitRepository.Create(ADataModule: TDataModuleDB);
begin
  inherited Create;
  FDAOProduit := TDAOProduit.Create(ADataModule);
end;

destructor TProduitRepository.Destroy;
begin
  FDAOProduit.Free;
  inherited;
end;

function TProduitRepository.Ajouter(AProduit: TProduit): Boolean;
begin
  Result := FDAOProduit.InsererProduit(AProduit);
end;

function TProduitRepository.Modifier(AProduit: TProduit): Boolean;
begin
  Result := FDAOProduit.MettreAJourProduit(AProduit);
end;

function TProduitRepository.Supprimer(AProduitID: Integer): Boolean;
begin
  Result := FDAOProduit.SupprimerProduit(AProduitID);
end;

function TProduitRepository.ObtenirParID(AProduitID: Integer): TProduit;
begin
  Result := FDAOProduit.ObtenirProduit(AProduitID);
end;

function TProduitRepository.ObtenirTous: TDataSet;
begin
  Result := FDAOProduit.ObtenirTousProduits;
end;

function TProduitRepository.ObtenirParCategorie(ACategorieID: Integer): TDataSet;
begin
  Result := FDAOProduit.ObtenirProduitsParCategorie(ACategorieID);
end;

function TProduitRepository.ObtenirParFournisseur(AFournisseurID: Integer): TDataSet;
begin
  Result := FDAOProduit.ObtenirProduitsParFournisseur(AFournisseurID);
end;

function TProduitRepository.Rechercher(ATerme: string): TDataSet;
begin
  Result := FDAOProduit.RechercherProduits(ATerme);
end;

function TProduitRepository.VerifierReferenceUnique(AReference: string; AProduitID: Integer): Boolean;
var
  Query: TFDQuery;
  SQL: string;
begin
  Result := False;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := (FDAOProduit as TDAOProduit).FDataModule.FDConnection;

    SQL := 'SELECT COUNT(*) AS Nombre FROM Produits WHERE Reference = :Reference';

    if AProduitID > 0 then
      SQL := SQL + ' AND ProduitID <> :ProduitID';

    Query.SQL.Text := SQL;
    Query.ParamByName('Reference').AsString := AReference;

    if AProduitID > 0 then
      Query.ParamByName('ProduitID').AsInteger := AProduitID;

    Query.Open;

    Result := Query.FieldByName('Nombre').AsInteger = 0;
  finally
    Query.Free;
  end;
end;

end.
```

## Utilisation des couches d'accès dans un formulaire

Maintenant, voyons comment utiliser ces couches d'accès dans un formulaire d'édition de produit :

```pascal
unit FormProduitEdit;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Mask, Vcl.DBCtrls,
  Data.DB, Vcl.ComCtrls, Produit, ProduitRepository, dmDatabase;

type
  TfrmProduitEdit = class(TForm)
    pnlButtons: TPanel;
    btnSave: TButton;
    btnCancel: TButton;
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    lblReference: TLabel;
    edtReference: TEdit;
    lblDesignation: TLabel;
    edtDesignation: TEdit;
    lblDescription: TLabel;
    memoDescription: TMemo;
    lblPrixAchat: TLabel;
    edtPrixAchat: TEdit;
    lblPrixVente: TLabel;
    edtPrixVente: TEdit;
    lblTVA: TLabel;
    edtTVA: TEdit;
    lblCategorie: TLabel;
    cboCategorie: TComboBox;
    lblFournisseur: TLabel;
    cboFournisseur: TComboBox;
    chkActif: TCheckBox;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure btnSaveClick(Sender: TObject);
    procedure btnCancelClick(Sender: TObject);
    procedure FormShow(Sender: TObject);
  private
    { Déclarations privées }
    FProduit: TProduit;
    FProduitRepository: TProduitRepository;
    FMode: string; // 'Add' ou 'Edit'
    procedure LoadCategories;
    procedure LoadFournisseurs;
    procedure LoadProduit;
    procedure SaveProduit;
    function ValidateForm: Boolean;
  public
    { Déclarations publiques }
    procedure InitAdd;
    procedure InitEdit(AProduitID: Integer);
  end;

var
  frmProduitEdit: TfrmProduitEdit;

implementation

{$R *.dfm}

uses
  CategorieRepository, FournisseurRepository;

procedure TfrmProduitEdit.FormCreate(Sender: TObject);
begin
  FProduit := TProduit.Create;
  FProduitRepository := TProduitRepository.Create(DataModuleDB);
  FMode := 'Add';
end;

procedure TfrmProduitEdit.FormDestroy(Sender: TObject);
begin
  FProduit.Free;
  FProduitRepository.Free;
end;

procedure TfrmProduitEdit.FormShow(Sender: TObject);
begin
  LoadCategories;
  LoadFournisseurs;

  if FMode = 'Edit' then
    LoadProduit;

  edtReference.SetFocus;
end;

procedure TfrmProduitEdit.LoadCategories;
var
  CategorieRepository: TCategorieRepository;
  Query: TFDQuery;
begin
  cboCategorie.Items.Clear;
  cboCategorie.Items.AddObject('(Aucune catégorie)', TObject(0));

  CategorieRepository := TCategorieRepository.Create(DataModuleDB);
  try
    Query := CategorieRepository.ObtenirTous as TFDQuery;
    while not Query.Eof do
    begin
      cboCategorie.Items.AddObject(
        Query.FieldByName('NomCategorie').AsString,
        TObject(Query.FieldByName('CategoryID').AsInteger)
      );
      Query.Next;
    end;
    Query.Free;
  finally
    CategorieRepository.Free;
  end;

  cboCategorie.ItemIndex := 0;
end;

procedure TfrmProduitEdit.LoadFournisseurs;
var
  FournisseurRepository: TFournisseurRepository;
  Query: TFDQuery;
begin
  cboFournisseur.Items.Clear;
  cboFournisseur.Items.AddObject('(Aucun fournisseur)', TObject(0));

  FournisseurRepository := TFournisseurRepository.Create(DataModuleDB);
  try
    Query := FournisseurRepository.ObtenirTous as TFDQuery;
    while not Query.Eof do
    begin
      cboFournisseur.Items.AddObject(
        Query.FieldByName('RaisonSociale').AsString,
        TObject(Query.FieldByName('FournisseurID').AsInteger)
      );
      Query.Next;
    end;
    Query.Free;
  finally
    FournisseurRepository.Free;
  end;

  cboFournisseur.ItemIndex := 0;
end;

procedure TfrmProduitEdit.LoadProduit;
var
  i: Integer;
begin
  if FProduit = nil then
    Exit;

  edtReference.Text := FProduit.Reference;
  edtDesignation.Text := FProduit.Designation;
  memoDescription.Text := FProduit.Description;
  edtPrixAchat.Text := FormatFloat('0.00', FProduit.PrixAchat);
  edtPrixVente.Text := FormatFloat('0.00', FProduit.PrixVente);
  edtTVA.Text := FormatFloat('0.00', FProduit.TVA);
  chkActif.Checked := FProduit.Actif;

  // Sélection de la catégorie dans la combobox
  cboCategorie.ItemIndex := 0;
  for i := 0 to cboCategorie.Items.Count - 1 do
  begin
    if Integer(cboCategorie.Items.Objects[i]) = FProduit.CategoryID then
    begin
      cboCategorie.ItemIndex := i;
      Break;
    end;
  end;

  // Sélection du fournisseur dans la combobox
  cboFournisseur.ItemIndex := 0;
  for i := 0 to cboFournisseur.Items.Count - 1 do
  begin
    if Integer(cboFournisseur.Items.Objects[i]) = FProduit.FournisseurID then
    begin
      cboFournisseur.ItemIndex := i;
      Break;
    end;
  end;
end;

procedure TfrmProduitEdit.SaveProduit;
begin
  if not ValidateForm then
    Exit;

  FProduit.Reference := Trim(edtReference.Text);
  FProduit.Designation := Trim(edtDesignation.Text);
  FProduit.Description := Trim(memoDescription.Text);
  FProduit.PrixAchat := StrToFloatDef(edtPrixAchat.Text, 0);
  FProduit.PrixVente := StrToFloatDef(edtPrixVente.Text, 0);
  FProduit.TVA := StrToFloatDef(edtTVA.Text, 20);
  FProduit.Actif := chkActif.Checked;

  if cboCategorie.ItemIndex > 0 then
    FProduit.CategoryID := Integer(cboCategorie.Items.Objects[cboCategorie.ItemIndex])
  else
    FProduit.CategoryID := 0;

  if cboFournisseur.ItemIndex > 0 then
    FProduit.FournisseurID := Integer(cboFournisseur.Items.Objects[cboFournisseur.ItemIndex])
  else
    FProduit.FournisseurID := 0;

  try
    if FMode = 'Add' then
      FProduitRepository.Ajouter(FProduit)
    else
      FProduitRepository.Modifier(FProduit);

    ModalResult := mrOk;
  except
    on E: Exception do
    begin
      ShowMessage('Erreur lors de l''enregistrement du produit : ' + E.Message);
    end;
  end;
end;

function TfrmProduitEdit.ValidateForm: Boolean;
begin
  Result := False;

  if Trim(edtReference.Text) = '' then
  begin
    ShowMessage('Veuillez saisir une référence pour le produit.');
    edtReference.SetFocus;
    Exit;
  end;

  if Trim(edtDesignation.Text) = '' then
  begin
    ShowMessage('Veuillez saisir une désignation pour le produit.');
    edtDesignation.SetFocus;
    Exit;
  end;

  if not FProduitRepository.VerifierReferenceUnique(Trim(edtReference.Text), FProduit.ProduitID) then
  begin
    ShowMessage('Cette référence existe déjà pour un autre produit.');
    edtReference.SetFocus;
    Exit;
  end;

  Result := True;
end;

procedure TfrmProduitEdit.InitAdd;
begin
  FMode := 'Add';
  FProduit.Free;
  FProduit := TProduit.Create;
  Caption := 'Ajout d''un produit';
end;

procedure TfrmProduitEdit.InitEdit(AProduitID: Integer);
begin
  FMode := 'Edit';
  FProduit.Free;
  FProduit := FProduitRepository.ObtenirParID(AProduitID);

  if FProduit = nil then
  begin
    ShowMessage('Produit non trouvé !');
    FProduit := TProduit.Create;
    Close;
  end;

  Caption := 'Modification du produit : ' + FProduit.Designation;
end;

procedure TfrmProduitEdit.btnSaveClick(Sender: TObject);
begin
  SaveProduit;
end;

procedure TfrmProduitEdit.btnCancelClick(Sender: TObject);
begin
  ModalResult := mrCancel;
end;
```

## Création d'un module de données métier (Business Data Module)

Pour améliorer encore la structure de notre application, créons un module de données qui va encapsuler nos repositories et gérer la création des objets métier.

Ajoutez un nouveau Data Module nommé `dmBusiness` :

```pascal
unit dmBusiness;

interface

uses
  System.SysUtils, System.Classes, ProduitRepository, CategorieRepository,
  FournisseurRepository, ClientRepository, CommandeRepository, dmDatabase;

type
  TDataModuleBusiness = class(TDataModule)
    procedure DataModuleCreate(Sender: TObject);
    procedure DataModuleDestroy(Sender: TObject);
  private
    { Déclarations privées }
    FProduitRepository: TProduitRepository;
    FCategorieRepository: TCategorieRepository;
    FFournisseurRepository: TFournisseurRepository;
    FClientRepository: TClientRepository;
    FCommandeRepository: TCommandeRepository;
  public
    { Déclarations publiques }
    property ProduitRepository: TProduitRepository read FProduitRepository;
    property CategorieRepository: TCategorieRepository read FCategorieRepository;
    property FournisseurRepository: TFournisseurRepository read FFournisseurRepository;
    property ClientRepository: TClientRepository read FClientRepository;
    property CommandeRepository: TCommandeRepository read FCommandeRepository;
  end;

var
  DataModuleBusiness: TDataModuleBusiness;

implementation

{%CLASSGROUP 'Vcl.Controls.TControl'}

{$R *.dfm}

procedure TDataModuleBusiness.DataModuleCreate(Sender: TObject);
begin
  // Création des repositories
  FProduitRepository := TProduitRepository.Create(DataModuleDB);
  FCategorieRepository := TCategorieRepository.Create(DataModuleDB);
  FFournisseurRepository := TFournisseurRepository.Create(DataModuleDB);
  FClientRepository := TClientRepository.Create(DataModuleDB);
  FCommandeRepository := TCommandeRepository.Create(DataModuleDB);
end;

procedure TDataModuleBusiness.DataModuleDestroy(Sender: TObject);
begin
  // Libération des repositories
  FProduitRepository.Free;
  FCategorieRepository.Free;
  FFournisseurRepository.Free;
  FClientRepository.Free;
  FCommandeRepository.Free;
end;

end.
```

## Utilisation de LiveBindings pour la liaison de données

Delphi propose une technologie moderne appelée LiveBindings qui permet de lier des données à des contrôles visuels. Voici comment l'utiliser avec notre couche d'accès aux données.

Créez un nouveau formulaire pour afficher la liste des produits :

```pascal
unit FormProduitsList;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.Bind.EngExt,
  Vcl.Bind.DBEngExt, Vcl.Bind.Grid, System.Rtti, System.Bindings.Outputs,
  Vcl.Bind.Editors, Data.Bind.Components, Data.Bind.Grid, Data.Bind.DBScope,
  Vcl.Grids, Vcl.ExtCtrls, Vcl.StdCtrls, Vcl.Buttons, Data.DB,
  FireDAC.Comp.Client, dmBusiness, FormProduitEdit;

type
  TfrmProduitsList = class(TForm)
    pnlTop: TPanel;
    pnlBottom: TPanel;
    GridProduits: TStringGrid;
    BindSourceDB1: TBindSourceDB;
    BindingsList1: TBindingsList;
    LinkGridToDataSourceBindSourceDB1: TLinkGridToDataSource;
    DataSource1: TDataSource;
    edtRecherche: TEdit;
    btnRechercher: TButton;
    btnAjouter: TButton;
    btnModifier: TButton;
    btnSupprimer: TButton;
    btnActualiser: TButton;
    lblTotal: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure btnAjouterClick(Sender: TObject);
    procedure btnModifierClick(Sender: TObject);
    procedure btnSupprimerClick(Sender: TObject);
    procedure btnRechercherClick(Sender: TObject);
    procedure btnActualiserClick(Sender: TObject);
    procedure GridProduitsSelectCell(Sender: TObject; ACol, ARow: Integer;
      var CanSelect: Boolean);
    procedure edtRechercheKeyPress(Sender: TObject; var Key: Char);
  private
    { Déclarations privées }
    FQuery: TFDQuery;
    FSelectedID: Integer;
    procedure RefreshData;
    function GetSelectedProduitID: Integer;
    procedure UpdateButtons;
    procedure UpdateTotalLabel;
  public
    { Déclarations publiques }
  end;

var
  frmProduitsList: TfrmProduitsList;

implementation

{$R *.dfm}

procedure TfrmProduitsList.FormCreate(Sender: TObject);
begin
  FSelectedID := 0;
  RefreshData;
  UpdateButtons;
end;

procedure TfrmProduitsList.FormDestroy(Sender: TObject);
begin
  if Assigned(FQuery) then
    FQuery.Free;
end;

procedure TfrmProduitsList.RefreshData;
begin
  if Assigned(FQuery) then
    FQuery.Free;

  FQuery := DataModuleBusiness.ProduitRepository.ObtenirTous as TFDQuery;
  DataSource1.DataSet := FQuery;

  UpdateTotalLabel;
end;

procedure TfrmProduitsList.UpdateTotalLabel;
begin
  lblTotal.Caption := Format('Total : %d produits', [FQuery.RecordCount]);
end;

function TfrmProduitsList.GetSelectedProduitID: Integer;
begin
  Result := 0;

  if (GridProduits.Row > 0) and (FQuery.RecordCount > 0) then
  begin
    FQuery.RecNo := GridProduits.Row;
    Result := FQuery.FieldByName('ProduitID').AsInteger;
  end;
end;

procedure TfrmProduitsList.UpdateButtons;
var
  HasSelection: Boolean;
begin
  HasSelection := GetSelectedProduitID > 0;

  btnModifier.Enabled := HasSelection;
  btnSupprimer.Enabled := HasSelection;
end;

procedure TfrmProduitsList.GridProduitsSelectCell(Sender: TObject; ACol,
  ARow: Integer; var CanSelect: Boolean);
begin
  FSelectedID := GetSelectedProduitID;
  UpdateButtons;
end;

procedure TfrmProduitsList.btnAjouterClick(Sender: TObject);
var
  Form: TfrmProduitEdit;
begin
  Form := TfrmProduitEdit.Create(Self);
  try
    Form.InitAdd;
    if Form.ShowModal = mrOk then
      RefreshData;
  finally
    Form.Free;
  end;
end;

procedure TfrmProduitsList.btnModifierClick(Sender: TObject);
var
  Form: TfrmProduitEdit;
  ID: Integer;
begin
  ID := GetSelectedProduitID;
  if ID <= 0 then
    Exit;

  Form := TfrmProduitEdit.Create(Self);
  try
    Form.InitEdit(ID);
    if Form.ShowModal = mrOk then
      RefreshData;
  finally
    Form.Free;
  end;
end;

procedure TfrmProduitsList.btnSupprimerClick(Sender: TObject);
var
  ID: Integer;
  Produit: TProduit;
begin
  ID := GetSelectedProduitID;
  if ID <= 0 then
    Exit;

  Produit := DataModuleBusiness.ProduitRepository.ObtenirParID(ID);
  try
    if MessageDlg(Format('Êtes-vous sûr de vouloir supprimer le produit "%s" ?',
      [Produit.Designation]), mtConfirmation, [mbYes, mbNo], 0) = mrYes then
    begin
      if DataModuleBusiness.ProduitRepository.Supprimer(ID) then
        RefreshData
      else
        ShowMessage('Erreur lors de la suppression du produit.');
    end;
  finally
    Produit.Free;
  end;
end;

procedure TfrmProduitsList.btnRechercherClick(Sender: TObject);
var
  Terme: string;
begin
  Terme := Trim(edtRecherche.Text);

  if Assigned(FQuery) then
    FQuery.Free;

  if Terme = '' then
    FQuery := DataModuleBusiness.ProduitRepository.ObtenirTous as TFDQuery
  else
    FQuery := DataModuleBusiness.ProduitRepository.Rechercher(Terme) as TFDQuery;

  DataSource1.DataSet := FQuery;
  UpdateTotalLabel;
end;

procedure TfrmProduitsList.edtRechercheKeyPress(Sender: TObject; var Key: Char);
begin
  if Key = #13 then // Touche Entrée
  begin
    Key := #0; // Supprime le "bip"
    btnRechercherClick(Sender);
  end;
end;

procedure TfrmProduitsList.btnActualiserClick(Sender: TObject);
begin
  edtRecherche.Clear;
  RefreshData;
end;
```

## Gestion des erreurs et transactions

Pour améliorer la robustesse de notre application, implémentons un gestionnaire d'erreurs central et gérons correctement les transactions.

Créez un fichier `ErrorHandler.pas` :

```pascal
unit ErrorHandler;

interface

uses
  System.SysUtils, System.Classes, Vcl.Dialogs, Vcl.Forms;

type
  TErrorHandler = class
  public
    class procedure HandleException(const AErrorMessage: string; E: Exception);
    class procedure LogError(const AErrorMessage: string; E: Exception);
  end;

implementation

uses
  System.IOUtils;

class procedure TErrorHandler.HandleException(const AErrorMessage: string; E: Exception);
begin
  // Affichage à l'utilisateur
  MessageDlg(AErrorMessage + #13#10 + E.Message, mtError, [mbOK], 0);

  // Journalisation
  LogError(AErrorMessage, E);
end;

class procedure TErrorHandler.LogError(const AErrorMessage: string; E: Exception);
var
  LogFile: TextFile;
  LogFileName: string;
  LogDir: string;
begin
  // Création du dossier Logs s'il n'existe pas
  LogDir := TPath.Combine(ExtractFilePath(Application.ExeName), 'Logs');
  if not DirectoryExists(LogDir) then
    ForceDirectories(LogDir);

  // Nom du fichier : logs_YYYYMMDD.txt
  LogFileName := TPath.Combine(LogDir, 'logs_' + FormatDateTime('YYYYMMDD', Now) + '.txt');

  try
    AssignFile(LogFile, LogFileName);
    if FileExists(LogFileName) then
      Append(LogFile)
    else
      Rewrite(LogFile);

    // Écriture de l'erreur avec horodatage
    WriteLn(LogFile, '-------------------------------------------------------');
    WriteLn(LogFile, 'Date/Heure : ' + FormatDateTime('YYYY-MM-DD HH:NN:SS', Now));
    WriteLn(LogFile, 'Message    : ' + AErrorMessage);
    WriteLn(LogFile, 'Exception  : ' + E.ClassName);
    WriteLn(LogFile, 'Détails    : ' + E.Message);
    WriteLn(LogFile, '-------------------------------------------------------');
  finally
    CloseFile(LogFile);
  end;
end;

end.
```

Modifions maintenant notre classe `TDAOProduit` pour utiliser cette gestion d'erreurs :

```pascal
function TDAOProduit.InsererProduit(AProduit: TProduit): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  if not FDataModule.IsConnected then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDataModule.FDConnection;
    Query.SQL.Text :=
      'INSERT INTO Produits ' +
      '(Reference, Designation, Description, PrixAchat, PrixVente, TVA, ' +
      'CategoryID, FournisseurID, PhotoURL, DateCreation, Actif) ' +
      'VALUES ' +
      '(:Reference, :Designation, :Description, :PrixAchat, :PrixVente, :TVA, ' +
      ':CategoryID, :FournisseurID, :PhotoURL, :DateCreation, :Actif)';

    Query.ParamByName('Reference').AsString := AProduit.Reference;
    Query.ParamByName('Designation').AsString := AProduit.Designation;
    Query.ParamByName('Description').AsString := AProduit.Description;
    Query.ParamByName('PrixAchat').AsFloat := AProduit.PrixAchat;
    Query.ParamByName('PrixVente').AsFloat := AProduit.PrixVente;
    Query.ParamByName('TVA').AsFloat := AProduit.TVA;
    Query.ParamByName('CategoryID').AsInteger := AProduit.CategoryID;
    Query.ParamByName('FournisseurID').AsInteger := AProduit.FournisseurID;
    Query.ParamByName('PhotoURL').AsString := AProduit.PhotoURL;
    Query.ParamByName('DateCreation').AsDateTime := AProduit.DateCreation;
    Query.ParamByName('Actif').AsBoolean := AProduit.Actif;

    FDataModule.FDTransaction.StartTransaction;
    try
      Query.ExecSQL;
      // Récupérer l'ID généré
      AProduit.ProduitID := FDataModule.FDConnection.GetLastAutoGenValue('');
      FDataModule.FDTransaction.Commit;
      Result := True;
    except
      on E: Exception do
      begin
        FDataModule.FDTransaction.Rollback;
        TErrorHandler.HandleException('Erreur lors de l''insertion du produit', E);
        raise; // Re-lance l'exception pour la traiter au niveau supérieur si nécessaire
      end;
    end;
  finally
    Query.Free;
  end;
end;
```

## Bonnes pratiques pour la couche d'accès aux données

Voici quelques bonnes pratiques à suivre pour votre couche d'accès aux données :

1. **Séparez les responsabilités** : Chaque classe a un rôle unique
2. **Utilisez des transactions** pour garantir la cohérence des données
3. **Gérez correctement les ressources** en libérant les objets (Free dans finally)
4. **Capturez et journalisez les erreurs** pour faciliter le débogage
5. **Utilisez des paramètres pour les requêtes SQL** pour éviter les injections SQL
6. **Centralisez la configuration** de connexion à la base de données
7. **Évitez de dupliquer du code** SQL dans l'application

## Avantages de l'architecture en couches

Cette architecture présente de nombreux avantages :

1. **Modularité** : Chaque couche peut être modifiée indépendamment
2. **Testabilité** : Les tests unitaires sont plus faciles à écrire
3. **Réutilisabilité** : Les DAOs peuvent être réutilisés dans d'autres parties de l'application
4. **Maintenance** : Le code est plus facile à comprendre et à maintenir
5. **Évolutivité** : Vous pouvez changer de SGBD sans modifier la couche métier

## Optimisations possibles

Voici quelques optimisations que vous pourriez envisager :

1. **Mise en cache** : Mettre en cache certaines données fréquemment accédées
2. **Chargement paresseux** (lazy loading) pour les grandes quantités de données
3. **Préparation des requêtes** pour améliorer les performances
4. **Pool de connexions** pour les applications multi-utilisateurs
5. **Compression des données** pour les transferts réseau dans une architecture distribuée

## Exercices pratiques

Pour vous familiariser avec la couche d'accès aux données :

1. Créez une classe DAO et un Repository pour la table `Clients`
2. Implémentez un formulaire de liste et d'édition pour les clients
3. Ajoutez une fonctionnalité pour exporter les données en CSV
4. Implémentez une fonction de recherche avancée avec plusieurs critères

## Prochaines étapes

Dans la section suivante (19.1.3), nous allons développer l'interface utilisateur évoluée de notre application, en utilisant notre couche d'accès aux données pour afficher et manipuler les informations de la base de données MySQL/MariaDB.

---

*Note : Cette implémentation respecte les principes SOLID et utilise plusieurs patterns de conception (Repository, DAO, etc.) pour assurer une architecture robuste et maintenable. Si certains concepts vous semblent complexes, n'hésitez pas à consulter les chapitres correspondants dans le tutoriel.*
