# 19.1.2 ImplÃ©mentation des couches d'accÃ¨s

ðŸ” Retour Ã  la [Table des matiÃ¨res](/SOMMAIRE.md)

Dans cette section, nous allons implÃ©menter les couches d'accÃ¨s aux donnÃ©es pour notre application de gestion. Cette Ã©tape est cruciale car elle constitue le pont entre notre base de donnÃ©es MySQL/MariaDB et notre application Delphi.

## Architecture en couches

Avant de commencer le codage, rappelons l'intÃ©rÃªt d'une architecture en couches pour l'accÃ¨s aux donnÃ©es :

1. **SÃ©paration des prÃ©occupations** : chaque couche a une responsabilitÃ© unique
2. **FacilitÃ© de maintenance** : vous pouvez modifier une couche sans impacter les autres
3. **TestabilitÃ© amÃ©liorÃ©e** : chaque couche peut Ãªtre testÃ©e indÃ©pendamment
4. **Ã‰volutivitÃ©** : vous pouvez remplacer la base de donnÃ©es sans rÃ©Ã©crire toute l'application

Voici les couches que nous allons implÃ©menter :

![Architecture en couches d'accÃ¨s](https://via.placeholder.com/600x400)

## CrÃ©ation du module de donnÃ©es principal

CommenÃ§ons par crÃ©er un DataModule qui centralisera notre connexion Ã  la base de donnÃ©es :

1. Dans Delphi, sÃ©lectionnez **File > New > Other**
2. Choisissez **Delphi Projects > Data Module**
3. Nommez-le `dmDatabase`

Ajoutez les composants suivants depuis la palette FireDAC :

- `TFDConnection` : pour la connexion Ã  MySQL/MariaDB
- `TFDPhysMySQLDriverLink` : le pilote MySQL
- `TFDGUIxWaitCursor` : pour afficher un curseur d'attente pendant les opÃ©rations
- `TFDTransaction` : pour gÃ©rer les transactions

Voici le code initial du module de donnÃ©es :

```pascal
unit dmDatabase;

interface

uses
  System.SysUtils, System.Classes, FireDAC.Stan.Intf, FireDAC.Stan.Option,
  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,
  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.Phys.MySQL,
  FireDAC.Phys.MySQLDef, FireDAC.VCLUI.Wait, FireDAC.Comp.UI, FireDAC.Comp.Client,
  Data.DB;

type
  TDataModuleDB = class(TDataModule)
    FDConnection: TFDConnection;
    FDPhysMySQLDriverLink: TFDPhysMySQLDriverLink;
    FDGUIxWaitCursor: TFDGUIxWaitCursor;
    FDTransaction: TFDTransaction;
    procedure DataModuleCreate(Sender: TObject);
  private
    { DÃ©clarations privÃ©es }
    procedure LoadConnectionSettings;
  public
    { DÃ©clarations publiques }
    function ConnectToDatabase: Boolean;
    procedure DisconnectFromDatabase;
    function IsConnected: Boolean;
  end;

var
  DataModuleDB: TDataModuleDB;

implementation

{%CLASSGROUP 'Vcl.Controls.TControl'}

{$R *.dfm}

uses
  System.IniFiles;

procedure TDataModuleDB.DataModuleCreate(Sender: TObject);
begin
  LoadConnectionSettings;
end;

procedure TDataModuleDB.LoadConnectionSettings;
var
  IniFile: TIniFile;
  ConfigFilePath: string;
begin
  ConfigFilePath := ChangeFileExt(ParamStr(0), '.ini');
  if FileExists(ConfigFilePath) then
  begin
    IniFile := TIniFile.Create(ConfigFilePath);
    try
      FDConnection.Params.Clear;
      FDConnection.Params.Add('DriverID=MySQL');
      FDConnection.Params.Add('Server=' + IniFile.ReadString('Database', 'Server', 'localhost'));
      FDConnection.Params.Add('Port=' + IniFile.ReadString('Database', 'Port', '3306'));
      FDConnection.Params.Add('Database=' + IniFile.ReadString('Database', 'Database', 'GestionCommerce'));
      FDConnection.Params.Add('User_Name=' + IniFile.ReadString('Database', 'User', 'app_gestion'));
      FDConnection.Params.Add('Password=' + IniFile.ReadString('Database', 'Password', ''));
      FDConnection.Params.Add('CharacterSet=utf8mb4');
    finally
      IniFile.Free;
    end;
  end
  else
  begin
    // Configuration par dÃ©faut si le fichier INI n'existe pas
    FDConnection.Params.Clear;
    FDConnection.Params.Add('DriverID=MySQL');
    FDConnection.Params.Add('Server=localhost');
    FDConnection.Params.Add('Port=3306');
    FDConnection.Params.Add('Database=GestionCommerce');
    FDConnection.Params.Add('User_Name=app_gestion');
    FDConnection.Params.Add('Password=mot_de_passe_securise');
    FDConnection.Params.Add('CharacterSet=utf8mb4');
  end;
end;

function TDataModuleDB.ConnectToDatabase: Boolean;
begin
  Result := False;
  try
    if not FDConnection.Connected then
      FDConnection.Connected := True;
    Result := FDConnection.Connected;
  except
    on E: Exception do
    begin
      // Traitement des erreurs de connexion
      ShowMessage('Erreur de connexion Ã  la base de donnÃ©es : ' + E.Message);
    end;
  end;
end;

procedure TDataModuleDB.DisconnectFromDatabase;
begin
  if FDConnection.Connected then
    FDConnection.Connected := False;
end;

function TDataModuleDB.IsConnected: Boolean;
begin
  Result := FDConnection.Connected;
end;

end.
```

## CrÃ©ation du fichier INI de configuration

Pour sÃ©curiser les informations de connexion, nous utiliserons un fichier de configuration externe. CrÃ©ez un fichier nommÃ© `AppGestion.ini` avec ce contenu :

```ini
[Database]
Server=localhost
Port=3306
Database=GestionCommerce
User=app_gestion
Password=mot_de_passe_securise
```

> **SÃ©curitÃ©** : Dans une application de production, vous devriez envisager de chiffrer le mot de passe dans le fichier INI.

## CrÃ©ation des classes d'entitÃ©s

Maintenant, crÃ©ons des classes qui reprÃ©sentent nos entitÃ©s principales. Ces classes font partie de la couche mÃ©tier mais sont essentielles pour l'accÃ¨s aux donnÃ©es.

CrÃ©ez un dossier `Business` dans votre projet et ajoutez la classe `Produit.pas` :

```pascal
unit Produit;

interface

uses
  System.SysUtils, System.Classes;

type
  TProduit = class
  private
    FProduitID: Integer;
    FReference: string;
    FDesignation: string;
    FDescription: string;
    FPrixAchat: Double;
    FPrixVente: Double;
    FTVA: Double;
    FCategoryID: Integer;
    FFournisseurID: Integer;
    FPhotoURL: string;
    FDateCreation: TDateTime;
    FActif: Boolean;
  public
    constructor Create; overload;
    constructor Create(AProduitID: Integer; AReference, ADesignation: string); overload;
    property ProduitID: Integer read FProduitID write FProduitID;
    property Reference: string read FReference write FReference;
    property Designation: string read FDesignation write FDesignation;
    property Description: string read FDescription write FDescription;
    property PrixAchat: Double read FPrixAchat write FPrixAchat;
    property PrixVente: Double read FPrixVente write FPrixVente;
    property TVA: Double read FTVA write FTVA;
    property CategoryID: Integer read FCategoryID write FCategoryID;
    property FournisseurID: Integer read FFournisseurID write FFournisseurID;
    property PhotoURL: string read FPhotoURL write FPhotoURL;
    property DateCreation: TDateTime read FDateCreation write FDateCreation;
    property Actif: Boolean read FActif write FActif;

    function CalculerPrixTTC: Double;
    function CalculerMarge: Double;
  end;

implementation

constructor TProduit.Create;
begin
  inherited;
  FProduitID := 0;
  FReference := '';
  FDesignation := '';
  FDescription := '';
  FPrixAchat := 0;
  FPrixVente := 0;
  FTVA := 20; // 20% par dÃ©faut
  FCategoryID := 0;
  FFournisseurID := 0;
  FPhotoURL := '';
  FDateCreation := Now;
  FActif := True;
end;

constructor TProduit.Create(AProduitID: Integer; AReference, ADesignation: string);
begin
  Create;
  FProduitID := AProduitID;
  FReference := AReference;
  FDesignation := ADesignation;
end;

function TProduit.CalculerPrixTTC: Double;
begin
  Result := FPrixVente * (1 + (FTVA / 100));
end;

function TProduit.CalculerMarge: Double;
begin
  if FPrixAchat > 0 then
    Result := ((FPrixVente - FPrixAchat) / FPrixAchat) * 100
  else
    Result := 0;
end;

end.
```

CrÃ©ez des classes similaires pour les autres entitÃ©s (Client, Commande, etc.) en suivant le mÃªme modÃ¨le.

## CrÃ©ation des modules d'accÃ¨s aux donnÃ©es

Maintenant, crÃ©ons les modules d'accÃ¨s aux donnÃ©es (DAO - Data Access Object) pour chaque entitÃ©. Ces modules seront responsables des opÃ©rations CRUD.

CrÃ©ez un dossier `DataAccess` et ajoutez la classe `DAOProduit.pas` :

```pascal
unit DAOProduit;

interface

uses
  System.SysUtils, System.Classes, Data.DB, FireDAC.Comp.Client,
  FireDAC.Comp.DataSet, FireDAC.DApt, FireDAC.Stan.Param,
  Produit, dmDatabase;

type
  TDAOProduit = class
  private
    FDataModule: TDataModuleDB;
  public
    constructor Create(ADataModule: TDataModuleDB);
    destructor Destroy; override;

    // OpÃ©rations CRUD
    function InsererProduit(AProduit: TProduit): Boolean;
    function MettreAJourProduit(AProduit: TProduit): Boolean;
    function SupprimerProduit(AProduitID: Integer): Boolean;
    function ObtenirProduit(AProduitID: Integer): TProduit;
    function ObtenirTousProduits: TFDQuery;
    function ObtenirProduitsParCategorie(ACategorieID: Integer): TFDQuery;
    function ObtenirProduitsParFournisseur(AFournisseurID: Integer): TFDQuery;
    function RechercherProduits(ATerme: string): TFDQuery;
  end;

implementation

constructor TDAOProduit.Create(ADataModule: TDataModuleDB);
begin
  inherited Create;
  FDataModule := ADataModule;
end;

destructor TDAOProduit.Destroy;
begin
  inherited;
end;

function TDAOProduit.InsererProduit(AProduit: TProduit): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  if not FDataModule.IsConnected then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDataModule.FDConnection;
    Query.SQL.Text :=
      'INSERT INTO Produits ' +
      '(Reference, Designation, Description, PrixAchat, PrixVente, TVA, ' +
      'CategoryID, FournisseurID, PhotoURL, DateCreation, Actif) ' +
      'VALUES ' +
      '(:Reference, :Designation, :Description, :PrixAchat, :PrixVente, :TVA, ' +
      ':CategoryID, :FournisseurID, :PhotoURL, :DateCreation, :Actif)';

    Query.ParamByName('Reference').AsString := AProduit.Reference;
    Query.ParamByName('Designation').AsString := AProduit.Designation;
    Query.ParamByName('Description').AsString := AProduit.Description;
    Query.ParamByName('PrixAchat').AsFloat := AProduit.PrixAchat;
    Query.ParamByName('PrixVente').AsFloat := AProduit.PrixVente;
    Query.ParamByName('TVA').AsFloat := AProduit.TVA;
    Query.ParamByName('CategoryID').AsInteger := AProduit.CategoryID;
    Query.ParamByName('FournisseurID').AsInteger := AProduit.FournisseurID;
    Query.ParamByName('PhotoURL').AsString := AProduit.PhotoURL;
    Query.ParamByName('DateCreation').AsDateTime := AProduit.DateCreation;
    Query.ParamByName('Actif').AsBoolean := AProduit.Actif;

    FDataModule.FDTransaction.StartTransaction;
    try
      Query.ExecSQL;
      // RÃ©cupÃ©rer l'ID gÃ©nÃ©rÃ©
      AProduit.ProduitID := FDataModule.FDConnection.GetLastAutoGenValue('');
      FDataModule.FDTransaction.Commit;
      Result := True;
    except
      on E: Exception do
      begin
        FDataModule.FDTransaction.Rollback;
        raise Exception.Create('Erreur lors de l''insertion du produit : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;

function TDAOProduit.MettreAJourProduit(AProduit: TProduit): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  if not FDataModule.IsConnected then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDataModule.FDConnection;
    Query.SQL.Text :=
      'UPDATE Produits SET ' +
      'Reference = :Reference, ' +
      'Designation = :Designation, ' +
      'Description = :Description, ' +
      'PrixAchat = :PrixAchat, ' +
      'PrixVente = :PrixVente, ' +
      'TVA = :TVA, ' +
      'CategoryID = :CategoryID, ' +
      'FournisseurID = :FournisseurID, ' +
      'PhotoURL = :PhotoURL, ' +
      'Actif = :Actif ' +
      'WHERE ProduitID = :ProduitID';

    Query.ParamByName('Reference').AsString := AProduit.Reference;
    Query.ParamByName('Designation').AsString := AProduit.Designation;
    Query.ParamByName('Description').AsString := AProduit.Description;
    Query.ParamByName('PrixAchat').AsFloat := AProduit.PrixAchat;
    Query.ParamByName('PrixVente').AsFloat := AProduit.PrixVente;
    Query.ParamByName('TVA').AsFloat := AProduit.TVA;
    Query.ParamByName('CategoryID').AsInteger := AProduit.CategoryID;
    Query.ParamByName('FournisseurID').AsInteger := AProduit.FournisseurID;
    Query.ParamByName('PhotoURL').AsString := AProduit.PhotoURL;
    Query.ParamByName('Actif').AsBoolean := AProduit.Actif;
    Query.ParamByName('ProduitID').AsInteger := AProduit.ProduitID;

    FDataModule.FDTransaction.StartTransaction;
    try
      Query.ExecSQL;
      FDataModule.FDTransaction.Commit;
      Result := True;
    except
      on E: Exception do
      begin
        FDataModule.FDTransaction.Rollback;
        raise Exception.Create('Erreur lors de la mise Ã  jour du produit : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;

function TDAOProduit.SupprimerProduit(AProduitID: Integer): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  if not FDataModule.IsConnected then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDataModule.FDConnection;
    Query.SQL.Text := 'DELETE FROM Produits WHERE ProduitID = :ProduitID';
    Query.ParamByName('ProduitID').AsInteger := AProduitID;

    FDataModule.FDTransaction.StartTransaction;
    try
      Query.ExecSQL;
      FDataModule.FDTransaction.Commit;
      Result := True;
    except
      on E: Exception do
      begin
        FDataModule.FDTransaction.Rollback;
        raise Exception.Create('Erreur lors de la suppression du produit : ' + E.Message);
      end;
    end;
  finally
    Query.Free;
  end;
end;

function TDAOProduit.ObtenirProduit(AProduitID: Integer): TProduit;
var
  Query: TFDQuery;
begin
  Result := nil;

  if not FDataModule.IsConnected then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDataModule.FDConnection;
    Query.SQL.Text := 'SELECT * FROM Produits WHERE ProduitID = :ProduitID';
    Query.ParamByName('ProduitID').AsInteger := AProduitID;
    Query.Open;

    if not Query.IsEmpty then
    begin
      Result := TProduit.Create;
      Result.ProduitID := Query.FieldByName('ProduitID').AsInteger;
      Result.Reference := Query.FieldByName('Reference').AsString;
      Result.Designation := Query.FieldByName('Designation').AsString;
      Result.Description := Query.FieldByName('Description').AsString;
      Result.PrixAchat := Query.FieldByName('PrixAchat').AsFloat;
      Result.PrixVente := Query.FieldByName('PrixVente').AsFloat;
      Result.TVA := Query.FieldByName('TVA').AsFloat;
      Result.CategoryID := Query.FieldByName('CategoryID').AsInteger;
      Result.FournisseurID := Query.FieldByName('FournisseurID').AsInteger;
      Result.PhotoURL := Query.FieldByName('PhotoURL').AsString;
      Result.DateCreation := Query.FieldByName('DateCreation').AsDateTime;
      Result.Actif := Query.FieldByName('Actif').AsBoolean;
    end;
  finally
    Query.Free;
  end;
end;

function TDAOProduit.ObtenirTousProduits: TFDQuery;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  Query.Connection := FDataModule.FDConnection;
  Query.SQL.Text :=
    'SELECT p.*, c.NomCategorie, f.RaisonSociale AS NomFournisseur ' +
    'FROM Produits p ' +
    'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
    'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
    'ORDER BY p.Designation';
  Query.Open;
  Result := Query;
end;

function TDAOProduit.ObtenirProduitsParCategorie(ACategorieID: Integer): TFDQuery;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  Query.Connection := FDataModule.FDConnection;
  Query.SQL.Text :=
    'SELECT p.*, c.NomCategorie, f.RaisonSociale AS NomFournisseur ' +
    'FROM Produits p ' +
    'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
    'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
    'WHERE p.CategoryID = :CategoryID ' +
    'ORDER BY p.Designation';
  Query.ParamByName('CategoryID').AsInteger := ACategorieID;
  Query.Open;
  Result := Query;
end;

function TDAOProduit.ObtenirProduitsParFournisseur(AFournisseurID: Integer): TFDQuery;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  Query.Connection := FDataModule.FDConnection;
  Query.SQL.Text :=
    'SELECT p.*, c.NomCategorie, f.RaisonSociale AS NomFournisseur ' +
    'FROM Produits p ' +
    'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
    'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
    'WHERE p.FournisseurID = :FournisseurID ' +
    'ORDER BY p.Designation';
  Query.ParamByName('FournisseurID').AsInteger := AFournisseurID;
  Query.Open;
  Result := Query;
end;

function TDAOProduit.RechercherProduits(ATerme: string): TFDQuery;
var
  Query: TFDQuery;
  TermeRecherche: string;
begin
  Query := TFDQuery.Create(nil);
  Query.Connection := FDataModule.FDConnection;

  TermeRecherche := '%' + ATerme + '%';

  Query.SQL.Text :=
    'SELECT p.*, c.NomCategorie, f.RaisonSociale AS NomFournisseur ' +
    'FROM Produits p ' +
    'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
    'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
    'WHERE p.Reference LIKE :Terme ' +
    'OR p.Designation LIKE :Terme ' +
    'OR p.Description LIKE :Terme ' +
    'ORDER BY p.Designation';
  Query.ParamByName('Terme').AsString := TermeRecherche;
  Query.Open;
  Result := Query;
end;

end.
```

CrÃ©ez des classes DAO similaires pour les autres entitÃ©s.

## CrÃ©ation d'une couche d'abstraction (Repository)

Pour une meilleure organisation, ajoutons un niveau d'abstraction supplÃ©mentaire avec le pattern Repository. Cette couche fera le lien entre la couche mÃ©tier et les DAOs.

CrÃ©ez un dossier `Repositories` et ajoutez la classe `ProduitRepository.pas` :

```pascal
unit ProduitRepository;

interface

uses
  System.SysUtils, System.Classes, Data.DB, FireDAC.Comp.Client,
  Produit, DAOProduit, dmDatabase;

type
  TProduitRepository = class
  private
    FDAOProduit: TDAOProduit;
  public
    constructor Create(ADataModule: TDataModuleDB);
    destructor Destroy; override;

    function Ajouter(AProduit: TProduit): Boolean;
    function Modifier(AProduit: TProduit): Boolean;
    function Supprimer(AProduitID: Integer): Boolean;
    function ObtenirParID(AProduitID: Integer): TProduit;
    function ObtenirTous: TDataSet;
    function ObtenirParCategorie(ACategorieID: Integer): TDataSet;
    function ObtenirParFournisseur(AFournisseurID: Integer): TDataSet;
    function Rechercher(ATerme: string): TDataSet;
    function VerifierReferenceUnique(AReference: string; AProduitID: Integer = 0): Boolean;
  end;

implementation

constructor TProduitRepository.Create(ADataModule: TDataModuleDB);
begin
  inherited Create;
  FDAOProduit := TDAOProduit.Create(ADataModule);
end;

destructor TProduitRepository.Destroy;
begin
  FDAOProduit.Free;
  inherited;
end;

function TProduitRepository.Ajouter(AProduit: TProduit): Boolean;
begin
  Result := FDAOProduit.InsererProduit(AProduit);
end;

function TProduitRepository.Modifier(AProduit: TProduit): Boolean;
begin
  Result := FDAOProduit.MettreAJourProduit(AProduit);
end;

function TProduitRepository.Supprimer(AProduitID: Integer): Boolean;
begin
  Result := FDAOProduit.SupprimerProduit(AProduitID);
end;

function TProduitRepository.ObtenirParID(AProduitID: Integer): TProduit;
begin
  Result := FDAOProduit.ObtenirProduit(AProduitID);
end;

function TProduitRepository.ObtenirTous: TDataSet;
begin
  Result := FDAOProduit.ObtenirTousProduits;
end;

function TProduitRepository.ObtenirParCategorie(ACategorieID: Integer): TDataSet;
begin
  Result := FDAOProduit.ObtenirProduitsParCategorie(ACategorieID);
end;

function TProduitRepository.ObtenirParFournisseur(AFournisseurID: Integer): TDataSet;
begin
  Result := FDAOProduit.ObtenirProduitsParFournisseur(AFournisseurID);
end;

function TProduitRepository.Rechercher(ATerme: string): TDataSet;
begin
  Result := FDAOProduit.RechercherProduits(ATerme);
end;

function TProduitRepository.VerifierReferenceUnique(AReference: string; AProduitID: Integer): Boolean;
var
  Query: TFDQuery;
  SQL: string;
begin
  Result := False;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := (FDAOProduit as TDAOProduit).FDataModule.FDConnection;

    SQL := 'SELECT COUNT(*) AS Nombre FROM Produits WHERE Reference = :Reference';

    if AProduitID > 0 then
      SQL := SQL + ' AND ProduitID <> :ProduitID';

    Query.SQL.Text := SQL;
    Query.ParamByName('Reference').AsString := AReference;

    if AProduitID > 0 then
      Query.ParamByName('ProduitID').AsInteger := AProduitID;

    Query.Open;

    Result := Query.FieldByName('Nombre').AsInteger = 0;
  finally
    Query.Free;
  end;
end;

end.
```

## Utilisation des couches d'accÃ¨s dans un formulaire

Maintenant, voyons comment utiliser ces couches d'accÃ¨s dans un formulaire d'Ã©dition de produit :

```pascal
unit FormProduitEdit;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Mask, Vcl.DBCtrls,
  Data.DB, Vcl.ComCtrls, Produit, ProduitRepository, dmDatabase;

type
  TfrmProduitEdit = class(TForm)
    pnlButtons: TPanel;
    btnSave: TButton;
    btnCancel: TButton;
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    lblReference: TLabel;
    edtReference: TEdit;
    lblDesignation: TLabel;
    edtDesignation: TEdit;
    lblDescription: TLabel;
    memoDescription: TMemo;
    lblPrixAchat: TLabel;
    edtPrixAchat: TEdit;
    lblPrixVente: TLabel;
    edtPrixVente: TEdit;
    lblTVA: TLabel;
    edtTVA: TEdit;
    lblCategorie: TLabel;
    cboCategorie: TComboBox;
    lblFournisseur: TLabel;
    cboFournisseur: TComboBox;
    chkActif: TCheckBox;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure btnSaveClick(Sender: TObject);
    procedure btnCancelClick(Sender: TObject);
    procedure FormShow(Sender: TObject);
  private
    { DÃ©clarations privÃ©es }
    FProduit: TProduit;
    FProduitRepository: TProduitRepository;
    FMode: string; // 'Add' ou 'Edit'
    procedure LoadCategories;
    procedure LoadFournisseurs;
    procedure LoadProduit;
    procedure SaveProduit;
    function ValidateForm: Boolean;
  public
    { DÃ©clarations publiques }
    procedure InitAdd;
    procedure InitEdit(AProduitID: Integer);
  end;

var
  frmProduitEdit: TfrmProduitEdit;

implementation

{$R *.dfm}

uses
  CategorieRepository, FournisseurRepository;

procedure TfrmProduitEdit.FormCreate(Sender: TObject);
begin
  FProduit := TProduit.Create;
  FProduitRepository := TProduitRepository.Create(DataModuleDB);
  FMode := 'Add';
end;

procedure TfrmProduitEdit.FormDestroy(Sender: TObject);
begin
  FProduit.Free;
  FProduitRepository.Free;
end;

procedure TfrmProduitEdit.FormShow(Sender: TObject);
begin
  LoadCategories;
  LoadFournisseurs;

  if FMode = 'Edit' then
    LoadProduit;

  edtReference.SetFocus;
end;

procedure TfrmProduitEdit.LoadCategories;
var
  CategorieRepository: TCategorieRepository;
  Query: TFDQuery;
begin
  cboCategorie.Items.Clear;
  cboCategorie.Items.AddObject('(Aucune catÃ©gorie)', TObject(0));

  CategorieRepository := TCategorieRepository.Create(DataModuleDB);
  try
    Query := CategorieRepository.ObtenirTous as TFDQuery;
    while not Query.Eof do
    begin
      cboCategorie.Items.AddObject(
        Query.FieldByName('NomCategorie').AsString,
        TObject(Query.FieldByName('CategoryID').AsInteger)
      );
      Query.Next;
    end;
    Query.Free;
  finally
    CategorieRepository.Free;
  end;

  cboCategorie.ItemIndex := 0;
end;

procedure TfrmProduitEdit.LoadFournisseurs;
var
  FournisseurRepository: TFournisseurRepository;
  Query: TFDQuery;
begin
  cboFournisseur.Items.Clear;
  cboFournisseur.Items.AddObject('(Aucun fournisseur)', TObject(0));

  FournisseurRepository := TFournisseurRepository.Create(DataModuleDB);
  try
    Query := FournisseurRepository.ObtenirTous as TFDQuery;
    while not Query.Eof do
    begin
      cboFournisseur.Items.AddObject(
        Query.FieldByName('RaisonSociale').AsString,
        TObject(Query.FieldByName('FournisseurID').AsInteger)
      );
      Query.Next;
    end;
    Query.Free;
  finally
    FournisseurRepository.Free;
  end;

  cboFournisseur.ItemIndex := 0;
end;

procedure TfrmProduitEdit.LoadProduit;
var
  i: Integer;
begin
  if FProduit = nil then
    Exit;

  edtReference.Text := FProduit.Reference;
  edtDesignation.Text := FProduit.Designation;
  memoDescription.Text := FProduit.Description;
  edtPrixAchat.Text := FormatFloat('0.00', FProduit.PrixAchat);
  edtPrixVente.Text := FormatFloat('0.00', FProduit.PrixVente);
  edtTVA.Text := FormatFloat('0.00', FProduit.TVA);
  chkActif.Checked := FProduit.Actif;

  // SÃ©lection de la catÃ©gorie dans la combobox
  cboCategorie.ItemIndex := 0;
  for i := 0 to cboCategorie.Items.Count - 1 do
  begin
    if Integer(cboCategorie.Items.Objects[i]) = FProduit.CategoryID then
    begin
      cboCategorie.ItemIndex := i;
      Break;
    end;
  end;

  // SÃ©lection du fournisseur dans la combobox
  cboFournisseur.ItemIndex := 0;
  for i := 0 to cboFournisseur.Items.Count - 1 do
  begin
    if Integer(cboFournisseur.Items.Objects[i]) = FProduit.FournisseurID then
    begin
      cboFournisseur.ItemIndex := i;
      Break;
    end;
  end;
end;

procedure TfrmProduitEdit.SaveProduit;
begin
  if not ValidateForm then
    Exit;

  FProduit.Reference := Trim(edtReference.Text);
  FProduit.Designation := Trim(edtDesignation.Text);
  FProduit.Description := Trim(memoDescription.Text);
  FProduit.PrixAchat := StrToFloatDef(edtPrixAchat.Text, 0);
  FProduit.PrixVente := StrToFloatDef(edtPrixVente.Text, 0);
  FProduit.TVA := StrToFloatDef(edtTVA.Text, 20);
  FProduit.Actif := chkActif.Checked;

  if cboCategorie.ItemIndex > 0 then
    FProduit.CategoryID := Integer(cboCategorie.Items.Objects[cboCategorie.ItemIndex])
  else
    FProduit.CategoryID := 0;

  if cboFournisseur.ItemIndex > 0 then
    FProduit.FournisseurID := Integer(cboFournisseur.Items.Objects[cboFournisseur.ItemIndex])
  else
    FProduit.FournisseurID := 0;

  try
    if FMode = 'Add' then
      FProduitRepository.Ajouter(FProduit)
    else
      FProduitRepository.Modifier(FProduit);

    ModalResult := mrOk;
  except
    on E: Exception do
    begin
      ShowMessage('Erreur lors de l''enregistrement du produit : ' + E.Message);
    end;
  end;
end;

function TfrmProduitEdit.ValidateForm: Boolean;
begin
  Result := False;

  if Trim(edtReference.Text) = '' then
  begin
    ShowMessage('Veuillez saisir une rÃ©fÃ©rence pour le produit.');
    edtReference.SetFocus;
    Exit;
  end;

  if Trim(edtDesignation.Text) = '' then
  begin
    ShowMessage('Veuillez saisir une dÃ©signation pour le produit.');
    edtDesignation.SetFocus;
    Exit;
  end;

  if not FProduitRepository.VerifierReferenceUnique(Trim(edtReference.Text), FProduit.ProduitID) then
  begin
    ShowMessage('Cette rÃ©fÃ©rence existe dÃ©jÃ  pour un autre produit.');
    edtReference.SetFocus;
    Exit;
  end;

  Result := True;
end;

procedure TfrmProduitEdit.InitAdd;
begin
  FMode := 'Add';
  FProduit.Free;
  FProduit := TProduit.Create;
  Caption := 'Ajout d''un produit';
end;

procedure TfrmProduitEdit.InitEdit(AProduitID: Integer);
begin
  FMode := 'Edit';
  FProduit.Free;
  FProduit := FProduitRepository.ObtenirParID(AProduitID);

  if FProduit = nil then
  begin
    ShowMessage('Produit non trouvÃ© !');
    FProduit := TProduit.Create;
    Close;
  end;

  Caption := 'Modification du produit : ' + FProduit.Designation;
end;

procedure TfrmProduitEdit.btnSaveClick(Sender: TObject);
begin
  SaveProduit;
end;

procedure TfrmProduitEdit.btnCancelClick(Sender: TObject);
begin
  ModalResult := mrCancel;
end;
```

## CrÃ©ation d'un module de donnÃ©es mÃ©tier (Business Data Module)

Pour amÃ©liorer encore la structure de notre application, crÃ©ons un module de donnÃ©es qui va encapsuler nos repositories et gÃ©rer la crÃ©ation des objets mÃ©tier.

Ajoutez un nouveau Data Module nommÃ© `dmBusiness` :

```pascal
unit dmBusiness;

interface

uses
  System.SysUtils, System.Classes, ProduitRepository, CategorieRepository,
  FournisseurRepository, ClientRepository, CommandeRepository, dmDatabase;

type
  TDataModuleBusiness = class(TDataModule)
    procedure DataModuleCreate(Sender: TObject);
    procedure DataModuleDestroy(Sender: TObject);
  private
    { DÃ©clarations privÃ©es }
    FProduitRepository: TProduitRepository;
    FCategorieRepository: TCategorieRepository;
    FFournisseurRepository: TFournisseurRepository;
    FClientRepository: TClientRepository;
    FCommandeRepository: TCommandeRepository;
  public
    { DÃ©clarations publiques }
    property ProduitRepository: TProduitRepository read FProduitRepository;
    property CategorieRepository: TCategorieRepository read FCategorieRepository;
    property FournisseurRepository: TFournisseurRepository read FFournisseurRepository;
    property ClientRepository: TClientRepository read FClientRepository;
    property CommandeRepository: TCommandeRepository read FCommandeRepository;
  end;

var
  DataModuleBusiness: TDataModuleBusiness;

implementation

{%CLASSGROUP 'Vcl.Controls.TControl'}

{$R *.dfm}

procedure TDataModuleBusiness.DataModuleCreate(Sender: TObject);
begin
  // CrÃ©ation des repositories
  FProduitRepository := TProduitRepository.Create(DataModuleDB);
  FCategorieRepository := TCategorieRepository.Create(DataModuleDB);
  FFournisseurRepository := TFournisseurRepository.Create(DataModuleDB);
  FClientRepository := TClientRepository.Create(DataModuleDB);
  FCommandeRepository := TCommandeRepository.Create(DataModuleDB);
end;

procedure TDataModuleBusiness.DataModuleDestroy(Sender: TObject);
begin
  // LibÃ©ration des repositories
  FProduitRepository.Free;
  FCategorieRepository.Free;
  FFournisseurRepository.Free;
  FClientRepository.Free;
  FCommandeRepository.Free;
end;

end.
```

## Utilisation de LiveBindings pour la liaison de donnÃ©es

Delphi propose une technologie moderne appelÃ©e LiveBindings qui permet de lier des donnÃ©es Ã  des contrÃ´les visuels. Voici comment l'utiliser avec notre couche d'accÃ¨s aux donnÃ©es.

CrÃ©ez un nouveau formulaire pour afficher la liste des produits :

```pascal
unit FormProduitsList;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.Bind.EngExt,
  Vcl.Bind.DBEngExt, Vcl.Bind.Grid, System.Rtti, System.Bindings.Outputs,
  Vcl.Bind.Editors, Data.Bind.Components, Data.Bind.Grid, Data.Bind.DBScope,
  Vcl.Grids, Vcl.ExtCtrls, Vcl.StdCtrls, Vcl.Buttons, Data.DB,
  FireDAC.Comp.Client, dmBusiness, FormProduitEdit;

type
  TfrmProduitsList = class(TForm)
    pnlTop: TPanel;
    pnlBottom: TPanel;
    GridProduits: TStringGrid;
    BindSourceDB1: TBindSourceDB;
    BindingsList1: TBindingsList;
    LinkGridToDataSourceBindSourceDB1: TLinkGridToDataSource;
    DataSource1: TDataSource;
    edtRecherche: TEdit;
    btnRechercher: TButton;
    btnAjouter: TButton;
    btnModifier: TButton;
    btnSupprimer: TButton;
    btnActualiser: TButton;
    lblTotal: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure btnAjouterClick(Sender: TObject);
    procedure btnModifierClick(Sender: TObject);
    procedure btnSupprimerClick(Sender: TObject);
    procedure btnRechercherClick(Sender: TObject);
    procedure btnActualiserClick(Sender: TObject);
    procedure GridProduitsSelectCell(Sender: TObject; ACol, ARow: Integer;
      var CanSelect: Boolean);
    procedure edtRechercheKeyPress(Sender: TObject; var Key: Char);
  private
    { DÃ©clarations privÃ©es }
    FQuery: TFDQuery;
    FSelectedID: Integer;
    procedure RefreshData;
    function GetSelectedProduitID: Integer;
    procedure UpdateButtons;
    procedure UpdateTotalLabel;
  public
    { DÃ©clarations publiques }
  end;

var
  frmProduitsList: TfrmProduitsList;

implementation

{$R *.dfm}

procedure TfrmProduitsList.FormCreate(Sender: TObject);
begin
  FSelectedID := 0;
  RefreshData;
  UpdateButtons;
end;

procedure TfrmProduitsList.FormDestroy(Sender: TObject);
begin
  if Assigned(FQuery) then
    FQuery.Free;
end;

procedure TfrmProduitsList.RefreshData;
begin
  if Assigned(FQuery) then
    FQuery.Free;

  FQuery := DataModuleBusiness.ProduitRepository.ObtenirTous as TFDQuery;
  DataSource1.DataSet := FQuery;

  UpdateTotalLabel;
end;

procedure TfrmProduitsList.UpdateTotalLabel;
begin
  lblTotal.Caption := Format('Total : %d produits', [FQuery.RecordCount]);
end;

function TfrmProduitsList.GetSelectedProduitID: Integer;
begin
  Result := 0;

  if (GridProduits.Row > 0) and (FQuery.RecordCount > 0) then
  begin
    FQuery.RecNo := GridProduits.Row;
    Result := FQuery.FieldByName('ProduitID').AsInteger;
  end;
end;

procedure TfrmProduitsList.UpdateButtons;
var
  HasSelection: Boolean;
begin
  HasSelection := GetSelectedProduitID > 0;

  btnModifier.Enabled := HasSelection;
  btnSupprimer.Enabled := HasSelection;
end;

procedure TfrmProduitsList.GridProduitsSelectCell(Sender: TObject; ACol,
  ARow: Integer; var CanSelect: Boolean);
begin
  FSelectedID := GetSelectedProduitID;
  UpdateButtons;
end;

procedure TfrmProduitsList.btnAjouterClick(Sender: TObject);
var
  Form: TfrmProduitEdit;
begin
  Form := TfrmProduitEdit.Create(Self);
  try
    Form.InitAdd;
    if Form.ShowModal = mrOk then
      RefreshData;
  finally
    Form.Free;
  end;
end;

procedure TfrmProduitsList.btnModifierClick(Sender: TObject);
var
  Form: TfrmProduitEdit;
  ID: Integer;
begin
  ID := GetSelectedProduitID;
  if ID <= 0 then
    Exit;

  Form := TfrmProduitEdit.Create(Self);
  try
    Form.InitEdit(ID);
    if Form.ShowModal = mrOk then
      RefreshData;
  finally
    Form.Free;
  end;
end;

procedure TfrmProduitsList.btnSupprimerClick(Sender: TObject);
var
  ID: Integer;
  Produit: TProduit;
begin
  ID := GetSelectedProduitID;
  if ID <= 0 then
    Exit;

  Produit := DataModuleBusiness.ProduitRepository.ObtenirParID(ID);
  try
    if MessageDlg(Format('ÃŠtes-vous sÃ»r de vouloir supprimer le produit "%s" ?',
      [Produit.Designation]), mtConfirmation, [mbYes, mbNo], 0) = mrYes then
    begin
      if DataModuleBusiness.ProduitRepository.Supprimer(ID) then
        RefreshData
      else
        ShowMessage('Erreur lors de la suppression du produit.');
    end;
  finally
    Produit.Free;
  end;
end;

procedure TfrmProduitsList.btnRechercherClick(Sender: TObject);
var
  Terme: string;
begin
  Terme := Trim(edtRecherche.Text);

  if Assigned(FQuery) then
    FQuery.Free;

  if Terme = '' then
    FQuery := DataModuleBusiness.ProduitRepository.ObtenirTous as TFDQuery
  else
    FQuery := DataModuleBusiness.ProduitRepository.Rechercher(Terme) as TFDQuery;

  DataSource1.DataSet := FQuery;
  UpdateTotalLabel;
end;

procedure TfrmProduitsList.edtRechercheKeyPress(Sender: TObject; var Key: Char);
begin
  if Key = #13 then // Touche EntrÃ©e
  begin
    Key := #0; // Supprime le "bip"
    btnRechercherClick(Sender);
  end;
end;

procedure TfrmProduitsList.btnActualiserClick(Sender: TObject);
begin
  edtRecherche.Clear;
  RefreshData;
end;
```

## Gestion des erreurs et transactions

Pour amÃ©liorer la robustesse de notre application, implÃ©mentons un gestionnaire d'erreurs central et gÃ©rons correctement les transactions.

CrÃ©ez un fichier `ErrorHandler.pas` :

```pascal
unit ErrorHandler;

interface

uses
  System.SysUtils, System.Classes, Vcl.Dialogs, Vcl.Forms;

type
  TErrorHandler = class
  public
    class procedure HandleException(const AErrorMessage: string; E: Exception);
    class procedure LogError(const AErrorMessage: string; E: Exception);
  end;

implementation

uses
  System.IOUtils;

class procedure TErrorHandler.HandleException(const AErrorMessage: string; E: Exception);
begin
  // Affichage Ã  l'utilisateur
  MessageDlg(AErrorMessage + #13#10 + E.Message, mtError, [mbOK], 0);

  // Journalisation
  LogError(AErrorMessage, E);
end;

class procedure TErrorHandler.LogError(const AErrorMessage: string; E: Exception);
var
  LogFile: TextFile;
  LogFileName: string;
  LogDir: string;
begin
  // CrÃ©ation du dossier Logs s'il n'existe pas
  LogDir := TPath.Combine(ExtractFilePath(Application.ExeName), 'Logs');
  if not DirectoryExists(LogDir) then
    ForceDirectories(LogDir);

  // Nom du fichier : logs_YYYYMMDD.txt
  LogFileName := TPath.Combine(LogDir, 'logs_' + FormatDateTime('YYYYMMDD', Now) + '.txt');

  try
    AssignFile(LogFile, LogFileName);
    if FileExists(LogFileName) then
      Append(LogFile)
    else
      Rewrite(LogFile);

    // Ã‰criture de l'erreur avec horodatage
    WriteLn(LogFile, '-------------------------------------------------------');
    WriteLn(LogFile, 'Date/Heure : ' + FormatDateTime('YYYY-MM-DD HH:NN:SS', Now));
    WriteLn(LogFile, 'Message    : ' + AErrorMessage);
    WriteLn(LogFile, 'Exception  : ' + E.ClassName);
    WriteLn(LogFile, 'DÃ©tails    : ' + E.Message);
    WriteLn(LogFile, '-------------------------------------------------------');
  finally
    CloseFile(LogFile);
  end;
end;

end.
```

Modifions maintenant notre classe `TDAOProduit` pour utiliser cette gestion d'erreurs :

```pascal
function TDAOProduit.InsererProduit(AProduit: TProduit): Boolean;
var
  Query: TFDQuery;
begin
  Result := False;

  if not FDataModule.IsConnected then
    Exit;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDataModule.FDConnection;
    Query.SQL.Text :=
      'INSERT INTO Produits ' +
      '(Reference, Designation, Description, PrixAchat, PrixVente, TVA, ' +
      'CategoryID, FournisseurID, PhotoURL, DateCreation, Actif) ' +
      'VALUES ' +
      '(:Reference, :Designation, :Description, :PrixAchat, :PrixVente, :TVA, ' +
      ':CategoryID, :FournisseurID, :PhotoURL, :DateCreation, :Actif)';

    Query.ParamByName('Reference').AsString := AProduit.Reference;
    Query.ParamByName('Designation').AsString := AProduit.Designation;
    Query.ParamByName('Description').AsString := AProduit.Description;
    Query.ParamByName('PrixAchat').AsFloat := AProduit.PrixAchat;
    Query.ParamByName('PrixVente').AsFloat := AProduit.PrixVente;
    Query.ParamByName('TVA').AsFloat := AProduit.TVA;
    Query.ParamByName('CategoryID').AsInteger := AProduit.CategoryID;
    Query.ParamByName('FournisseurID').AsInteger := AProduit.FournisseurID;
    Query.ParamByName('PhotoURL').AsString := AProduit.PhotoURL;
    Query.ParamByName('DateCreation').AsDateTime := AProduit.DateCreation;
    Query.ParamByName('Actif').AsBoolean := AProduit.Actif;

    FDataModule.FDTransaction.StartTransaction;
    try
      Query.ExecSQL;
      // RÃ©cupÃ©rer l'ID gÃ©nÃ©rÃ©
      AProduit.ProduitID := FDataModule.FDConnection.GetLastAutoGenValue('');
      FDataModule.FDTransaction.Commit;
      Result := True;
    except
      on E: Exception do
      begin
        FDataModule.FDTransaction.Rollback;
        TErrorHandler.HandleException('Erreur lors de l''insertion du produit', E);
        raise; // Re-lance l'exception pour la traiter au niveau supÃ©rieur si nÃ©cessaire
      end;
    end;
  finally
    Query.Free;
  end;
end;
```

## Bonnes pratiques pour la couche d'accÃ¨s aux donnÃ©es

Voici quelques bonnes pratiques Ã  suivre pour votre couche d'accÃ¨s aux donnÃ©es :

1. **SÃ©parez les responsabilitÃ©s** : Chaque classe a un rÃ´le unique
2. **Utilisez des transactions** pour garantir la cohÃ©rence des donnÃ©es
3. **GÃ©rez correctement les ressources** en libÃ©rant les objets (Free dans finally)
4. **Capturez et journalisez les erreurs** pour faciliter le dÃ©bogage
5. **Utilisez des paramÃ¨tres pour les requÃªtes SQL** pour Ã©viter les injections SQL
6. **Centralisez la configuration** de connexion Ã  la base de donnÃ©es
7. **Ã‰vitez de dupliquer du code** SQL dans l'application

## Avantages de l'architecture en couches

Cette architecture prÃ©sente de nombreux avantages :

1. **ModularitÃ©** : Chaque couche peut Ãªtre modifiÃ©e indÃ©pendamment
2. **TestabilitÃ©** : Les tests unitaires sont plus faciles Ã  Ã©crire
3. **RÃ©utilisabilitÃ©** : Les DAOs peuvent Ãªtre rÃ©utilisÃ©s dans d'autres parties de l'application
4. **Maintenance** : Le code est plus facile Ã  comprendre et Ã  maintenir
5. **Ã‰volutivitÃ©** : Vous pouvez changer de SGBD sans modifier la couche mÃ©tier

## Optimisations possibles

Voici quelques optimisations que vous pourriez envisager :

1. **Mise en cache** : Mettre en cache certaines donnÃ©es frÃ©quemment accÃ©dÃ©es
2. **Chargement paresseux** (lazy loading) pour les grandes quantitÃ©s de donnÃ©es
3. **PrÃ©paration des requÃªtes** pour amÃ©liorer les performances
4. **Pool de connexions** pour les applications multi-utilisateurs
5. **Compression des donnÃ©es** pour les transferts rÃ©seau dans une architecture distribuÃ©e

## Exercices pratiques

Pour vous familiariser avec la couche d'accÃ¨s aux donnÃ©es :

1. CrÃ©ez une classe DAO et un Repository pour la table `Clients`
2. ImplÃ©mentez un formulaire de liste et d'Ã©dition pour les clients
3. Ajoutez une fonctionnalitÃ© pour exporter les donnÃ©es en CSV
4. ImplÃ©mentez une fonction de recherche avancÃ©e avec plusieurs critÃ¨res

## Prochaines Ã©tapes

Dans la section suivante (19.1.3), nous allons dÃ©velopper l'interface utilisateur Ã©voluÃ©e de notre application, en utilisant notre couche d'accÃ¨s aux donnÃ©es pour afficher et manipuler les informations de la base de donnÃ©es MySQL/MariaDB.

---

*Note : Cette implÃ©mentation respecte les principes SOLID et utilise plusieurs patterns de conception (Repository, DAO, etc.) pour assurer une architecture robuste et maintenable. Si certains concepts vous semblent complexes, n'hÃ©sitez pas Ã  consulter les chapitres correspondants dans le tutoriel.*

â­ï¸ [Interface utilisateur Ã©voluÃ©e](19-projets-avances/01.3-interface-utilisateur-evoluee.md)
