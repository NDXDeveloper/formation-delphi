# 19.1.3 Interface utilisateur évoluée

Après avoir créé notre base de données et implémenté les couches d'accès aux données, nous allons maintenant concevoir une interface utilisateur professionnelle et ergonomique pour notre application de gestion. Une bonne interface est essentielle pour que les utilisateurs puissent interagir efficacement avec l'application.

## Objectifs de notre interface utilisateur

Notre interface doit répondre à plusieurs critères :

1. **Intuitive et simple d'utilisation** : même pour des utilisateurs peu familiers avec l'informatique
2. **Cohérente** : navigation et interactions homogènes dans toute l'application
3. **Responsive** : réactive aux actions de l'utilisateur sans temps d'attente
4. **Informative** : fournir des retours clairs sur les actions effectuées
5. **Esthétique** : aspect visuel professionnel et agréable

## Structure globale de l'application

Commençons par définir la structure générale de notre application :

![Structure de l'application](https://via.placeholder.com/800x500)

Notre application comprendra :

- **Un formulaire principal** avec un menu et une barre d'outils
- **Des onglets** pour naviguer entre les différentes sections
- **Un tableau de bord** affichant les informations importantes
- **Des formulaires spécialisés** pour la gestion des différentes entités
- **Un système de notifications** pour informer l'utilisateur

## Création du formulaire principal

Le formulaire principal sera la pierre angulaire de notre application. Créons-le :

1. Dans Delphi, sélectionnez **File > New > VCL Form**
2. Enregistrez-le sous le nom `FormMain.pas`

### Design du formulaire principal

```pascal
unit FormMain;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Menus, Vcl.ComCtrls,
  Vcl.ToolWin, Vcl.ExtCtrls, Vcl.Imaging.pngimage, System.Actions, Vcl.ActnList,
  Vcl.ImgList, System.ImageList, Vcl.StdCtrls, Vcl.Buttons, Vcl.CategoryButtons,
  Vcl.WinXCtrls;

type
  TfrmMain = class(TForm)
    MainMenu1: TMainMenu;
    mnuFichier: TMenuItem;
    mnuEdition: TMenuItem;
    mnuDonnees: TMenuItem;
    mnuRapports: TMenuItem;
    mnuAide: TMenuItem;
    mnuFichierQuitter: TMenuItem;
    mnuDonneesClients: TMenuItem;
    mnuDonneesProduits: TMenuItem;
    mnuDonneesFournisseurs: TMenuItem;
    mnuDonneesCommandes: TMenuItem;
    mnuDonneesCategories: TMenuItem;
    mnuRapportsVentes: TMenuItem;
    mnuRapportsStock: TMenuItem;
    mnuAideAPropos: TMenuItem;
    StatusBar1: TStatusBar;
    ToolBar1: TToolBar;
    pnlSidebar: TPanel;
    pnlContent: TPanel;
    splVertical: TSplitter;
    ActionList1: TActionList;
    actClientsListe: TAction;
    actProduitsListe: TAction;
    actFournisseursListe: TAction;
    actCommandesListe: TAction;
    actCategoriesListe: TAction;
    actRapportVentes: TAction;
    actRapportStock: TAction;
    actQuitter: TAction;
    ImageList1: TImageList;
    btnClients: TToolButton;
    btnProduits: TToolButton;
    btnCommandes: TToolButton;
    btnFournisseurs: TToolButton;
    btnRapports: TToolButton;
    ToolButton6: TToolButton;
    catSidebar: TCategoryButtons;
    SearchBox1: TSearchBox;
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    pnlWelcome: TPanel;
    lblWelcome: TLabel;
    btnQuickClients: TSpeedButton;
    btnQuickProduits: TSpeedButton;
    btnQuickCommandes: TSpeedButton;
    btnQuickRapports: TSpeedButton;
    TabSheet2: TTabSheet;
    procedure FormCreate(Sender: TObject);
    procedure actQuitterExecute(Sender: TObject);
    procedure actClientsListeExecute(Sender: TObject);
    procedure actProduitsListeExecute(Sender: TObject);
    procedure actFournisseursListeExecute(Sender: TObject);
    procedure actCommandesListeExecute(Sender: TObject);
    procedure actCategoriesListeExecute(Sender: TObject);
    procedure actRapportVentesExecute(Sender: TObject);
    procedure actRapportStockExecute(Sender: TObject);
    procedure catSidebarSelectedItemChange(Sender: TObject; const Category: TButtonCategory;
      const Button: TButtonItem);
    procedure FormShow(Sender: TObject);
    procedure SearchBox1InvokeSearch(Sender: TObject);
  private
    { Déclarations privées }
    FCurrentTab: TTabSheet;
    procedure InitializeSidebar;
    procedure ShowTabForm(AClass: TFormClass; const ATitle: string);
    procedure AdjustTabSheet;
    procedure UpdateStatusBar;
  public
    { Déclarations publiques }
  end;

var
  frmMain: TfrmMain;

implementation

{$R *.dfm}

uses
  FormClientsList, FormProduitsList, FormFournisseursList, FormCommandesList,
  FormCategoriesList, FormRapportVentes, FormRapportStock, dmDatabase,
  VersionInfo;

procedure TfrmMain.FormCreate(Sender: TObject);
begin
  // Initialiser la connexion à la base de données
  if not DataModuleDB.ConnectToDatabase then
  begin
    ShowMessage('Impossible de se connecter à la base de données. ' +
      'Veuillez vérifier les paramètres de connexion.');
    Application.Terminate;
  end;

  // Initialiser la barre latérale
  InitializeSidebar;

  // Afficher les informations de version dans la barre d'état
  StatusBar1.Panels[0].Text := Format('Version %s', [GetFileVersion]);
  StatusBar1.Panels[1].Text := 'Prêt';

  // Par défaut, aucun onglet actif
  FCurrentTab := nil;
end;

procedure TfrmMain.FormShow(Sender: TObject);
begin
  // Afficher le panneau d'accueil
  TabSheet1.TabVisible := True;
  TabSheet2.TabVisible := False;
  PageControl1.ActivePage := TabSheet1;

  // Mettre à jour la barre d'état
  UpdateStatusBar;
end;

procedure TfrmMain.InitializeSidebar;
var
  Category: TButtonCategory;
  Item: TButtonItem;
begin
  // Catégorie Gestion
  Category := catSidebar.Categories.Add;
  Category.Caption := 'GESTION';
  Category.Color := clGradientInactiveCaption;

  Item := Category.Items.Add;
  Item.Caption := 'Clients';
  Item.ImageIndex := 0; // Index de l'image dans ImageList
  Item.Data := TObject(1); // ID unique pour l'action

  Item := Category.Items.Add;
  Item.Caption := 'Produits';
  Item.ImageIndex := 1;
  Item.Data := TObject(2);

  Item := Category.Items.Add;
  Item.Caption := 'Commandes';
  Item.ImageIndex := 2;
  Item.Data := TObject(3);

  Item := Category.Items.Add;
  Item.Caption := 'Fournisseurs';
  Item.ImageIndex := 3;
  Item.Data := TObject(4);

  Item := Category.Items.Add;
  Item.Caption := 'Catégories';
  Item.ImageIndex := 4;
  Item.Data := TObject(5);

  // Catégorie Rapports
  Category := catSidebar.Categories.Add;
  Category.Caption := 'RAPPORTS';
  Category.Color := clGradientInactiveCaption;

  Item := Category.Items.Add;
  Item.Caption := 'Ventes';
  Item.ImageIndex := 5;
  Item.Data := TObject(6);

  Item := Category.Items.Add;
  Item.Caption := 'Stock';
  Item.ImageIndex := 6;
  Item.Data := TObject(7);
end;

procedure TfrmMain.actQuitterExecute(Sender: TObject);
begin
  Close;
end;

procedure TfrmMain.ShowTabForm(AClass: TFormClass; const ATitle: string);
var
  Form: TForm;
  I: Integer;
  Found: Boolean;
begin
  // Vérifier si l'onglet existe déjà
  Found := False;
  for I := 0 to PageControl1.PageCount - 1 do
  begin
    if (PageControl1.Pages[I].Tag <> 0) and
       (TObject(PageControl1.Pages[I].Tag).ClassType = AClass) then
    begin
      PageControl1.ActivePage := PageControl1.Pages[I];
      Found := True;
      Break;
    end;
  end;

  if not Found then
  begin
    // Créer un nouvel onglet avec le formulaire
    TabSheet2.Caption := ATitle;
    TabSheet2.TabVisible := True;
    PageControl1.ActivePage := TabSheet2;

    // Créer le formulaire dans l'onglet
    Form := AClass.Create(Self);
    Form.Parent := TabSheet2;
    Form.BorderStyle := bsNone;
    Form.Align := alClient;
    Form.Show;

    // Garder une référence au formulaire
    TabSheet2.Tag := NativeInt(Form);

    // Créer un nouvel onglet vide pour les prochaines vues
    FCurrentTab := TTabSheet.Create(PageControl1);
    FCurrentTab.PageControl := PageControl1;
    FCurrentTab.TabVisible := False;

    // Mettre à jour TabSheet2 pour le nouvel onglet
    TabSheet2 := FCurrentTab;
  end;

  // Mettre à jour la barre d'état
  UpdateStatusBar;
end;

procedure TfrmMain.UpdateStatusBar;
begin
  if PageControl1.ActivePage = TabSheet1 then
    StatusBar1.Panels[1].Text := 'Accueil'
  else
    StatusBar1.Panels[1].Text := PageControl1.ActivePage.Caption;
end;

procedure TfrmMain.actClientsListeExecute(Sender: TObject);
begin
  ShowTabForm(TfrmClientsList, 'Clients');
end;

procedure TfrmMain.actProduitsListeExecute(Sender: TObject);
begin
  ShowTabForm(TfrmProduitsList, 'Produits');
end;

procedure TfrmMain.actFournisseursListeExecute(Sender: TObject);
begin
  ShowTabForm(TfrmFournisseursList, 'Fournisseurs');
end;

procedure TfrmMain.actCommandesListeExecute(Sender: TObject);
begin
  ShowTabForm(TfrmCommandesList, 'Commandes');
end;

procedure TfrmMain.actCategoriesListeExecute(Sender: TObject);
begin
  ShowTabForm(TfrmCategoriesList, 'Catégories');
end;

procedure TfrmMain.actRapportVentesExecute(Sender: TObject);
begin
  ShowTabForm(TfrmRapportVentes, 'Rapport des ventes');
end;

procedure TfrmMain.actRapportStockExecute(Sender: TObject);
begin
  ShowTabForm(TfrmRapportStock, 'Rapport de stock');
end;

procedure TfrmMain.catSidebarSelectedItemChange(Sender: TObject;
  const Category: TButtonCategory; const Button: TButtonItem);
begin
  case Integer(Button.Data) of
    1: actClientsListe.Execute;
    2: actProduitsListe.Execute;
    3: actCommandesListe.Execute;
    4: actFournisseursListe.Execute;
    5: actCategoriesListe.Execute;
    6: actRapportVentes.Execute;
    7: actRapportStock.Execute;
  end;
end;

procedure TfrmMain.SearchBox1InvokeSearch(Sender: TObject);
var
  SearchTerm: string;
begin
  SearchTerm := Trim(SearchBox1.Text);
  if SearchTerm = '' then
    Exit;

  // Implémenter la recherche globale ici
  ShowMessage('Recherche de : ' + SearchTerm);
  // Vous pourriez ouvrir un formulaire de résultats de recherche
end;

end.
```

## Utilisation des styles VCL

Delphi permet d'appliquer des styles visuels à l'application pour lui donner un aspect moderne. Ajoutons cette fonctionnalité :

```pascal
// Dans le projet (.dpr)
program GestionCommerce;

uses
  Vcl.Forms,
  Vcl.Themes,
  Vcl.Styles,
  FormMain in 'FormMain.pas' {frmMain},
  // autres uses...

{$R *.res}

begin
  Application.Initialize;
  Application.MainFormOnTaskbar := True;

  // Chargement du style
  TStyleManager.TrySetStyle('Windows10');

  Application.CreateForm(TDataModuleDB, DataModuleDB);
  Application.CreateForm(TDataModuleBusiness, DataModuleBusiness);
  Application.CreateForm(TfrmMain, frmMain);
  Application.Run;
end.
```

Pour permettre à l'utilisateur de choisir un style, ajoutons un menu :

```pascal
// Dans FormMain, ajouter :
mnuAffichage: TMenuItem;
mnuAffichageStyles: TMenuItem;
procedure mnuAffichageStylesClick(Sender: TObject);
// ...

// Et dans l'implémentation :
procedure TfrmMain.mnuAffichageStylesClick(Sender: TObject);
var
  StyleName: string;
  MenuItem: TMenuItem;
begin
  for StyleName in TStyleManager.StyleNames do
  begin
    MenuItem := TMenuItem.Create(mnuAffichageStyles);
    MenuItem.Caption := StyleName;
    MenuItem.OnClick := StyleMenuItemClick;
    MenuItem.RadioItem := True;
    MenuItem.Checked := StyleName = TStyleManager.ActiveStyle.Name;
    mnuAffichageStyles.Add(MenuItem);
  end;
end;

procedure TfrmMain.StyleMenuItemClick(Sender: TObject);
begin
  if Sender is TMenuItem then
    TStyleManager.TrySetStyle(TMenuItem(Sender).Caption);
end;
```

## Création d'un tableau de bord (Dashboard)

Ajoutons un tableau de bord attractif à notre écran d'accueil :

```pascal
// Ajouter dans le fichier DFM ou via le designer
object pnlDashboard: TPanel
  AlignWithMargins = True
  Left = 10
  Top = 70
  Width = 580
  Height = 350
  Margins.Left = 10
  Margins.Top = 10
  Margins.Right = 10
  Margins.Bottom = 10
  Align = alClient
  BevelOuter = bvNone
  TabOrder = 1
  object FlowPanel1: TFlowPanel
    Left = 0
    Top = 0
    Width = 580
    Height = 350
    Align = alClient
    BevelOuter = bvNone
    TabOrder = 0
    object pnlStats1: TPanel
      AlignWithMargins = True
      Left = 3
      Top = 3
      Width = 180
      Height = 100
      Margins.Bottom = 10
      BevelOuter = bvNone
      Color = clSkyBlue
      ParentBackground = False
      TabOrder = 0
      object Label1: TLabel
        AlignWithMargins = True
        Left = 10
        Top = 10
        Width = 160
        Height = 19
        Margins.Left = 10
        Margins.Top = 10
        Align = alTop
        Caption = 'Clients'
        Font.Charset = DEFAULT_CHARSET
        Font.Color = clWhite
        Font.Height = -16
        Font.Name = 'Tahoma'
        Font.Style = [fsBold]
        ParentFont = False
        ExplicitWidth = 55
      end
      object lblTotalClients: TLabel
        AlignWithMargins = True
        Left = 10
        Top = 45
        Width = 160
        Height = 45
        Margins.Left = 10
        Margins.Top = 10
        Align = alClient
        Caption = '0'
        Font.Charset = DEFAULT_CHARSET
        Font.Color = clWhite
        Font.Height = -29
        Font.Name = 'Tahoma'
        Font.Style = [fsBold]
        ParentFont = False
        ExplicitWidth = 18
        ExplicitHeight = 35
      end
    end
    // Autres panneaux de statistiques similaires...
  end
end
```

Pour charger les données du tableau de bord :

```pascal
procedure TfrmMain.UpdateDashboard;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    // Nombre de clients
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text := 'SELECT COUNT(*) AS Total FROM Clients';
    Query.Open;
    lblTotalClients.Caption := Query.FieldByName('Total').AsString;
    Query.Close;

    // Nombre de produits
    Query.SQL.Text := 'SELECT COUNT(*) AS Total FROM Produits';
    Query.Open;
    lblTotalProduits.Caption := Query.FieldByName('Total').AsString;
    Query.Close;

    // Chiffre d'affaires du mois
    Query.SQL.Text :=
      'SELECT SUM(MontantTTC) AS Total FROM Commandes ' +
      'WHERE YEAR(DateCommande) = YEAR(CURRENT_DATE()) AND MONTH(DateCommande) = MONTH(CURRENT_DATE())';
    Query.Open;
    if not Query.FieldByName('Total').IsNull then
      lblCAMois.Caption := FormatFloat('#,##0.00 €', Query.FieldByName('Total').AsFloat)
    else
      lblCAMois.Caption := '0,00 €';
    Query.Close;

    // Commandes en attente
    Query.SQL.Text :=
      'SELECT COUNT(*) AS Total FROM Commandes WHERE Statut = ''En attente''';
    Query.Open;
    lblCommandesAttente.Caption := Query.FieldByName('Total').AsString;
    Query.Close;
  finally
    Query.Free;
  end;
end;
```

## Création d'un formulaire de liste évoluée

Améliorons notre formulaire de liste de produits pour le rendre plus fonctionnel :

```pascal
unit FormProduitsList;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.Grids,
  Vcl.DBGrids, Vcl.ExtCtrls, Vcl.StdCtrls, Vcl.Buttons, Vcl.ComCtrls,
  FireDAC.Comp.Client, System.Actions, Vcl.ActnList, System.ImageList,
  Vcl.ImgList, Vcl.Menus, Vcl.WinXCtrls, Vcl.DBCtrls, Vcl.Imaging.pngimage;

type
  TFilterType = (ftReference, ftDesignation, ftCategorie, ftFournisseur, ftTous);

  TfrmProduitsList = class(TForm)
    pnlTop: TPanel;
    pnlCenter: TPanel;
    pnlBottom: TPanel;
    btnAjouter: TSpeedButton;
    btnModifier: TSpeedButton;
    btnSupprimer: TSpeedButton;
    btnActualiser: TSpeedButton;
    lblTotal: TLabel;
    btnExporter: TSpeedButton;
    DBGrid1: TDBGrid;
    ActionList1: TActionList;
    actAjouter: TAction;
    actModifier: TAction;
    actSupprimer: TAction;
    actActualiser: TAction;
    actExporter: TAction;
    ImageList1: TImageList;
    DataSource1: TDataSource;
    SearchBox1: TSearchBox;
    cboFiltre: TComboBox;
    lblFiltre: TLabel;
    StatusBar1: TStatusBar;
    PanelPreview: TPanel;
    SplitterPreview: TSplitter;
    lblPreviewTitle: TLabel;
    imgProduit: TImage;
    lblReference: TLabel;
    lblDesignation: TLabel;
    lblPrix: TLabel;
    lblCategorie: TLabel;
    lblStock: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure actAjouterExecute(Sender: TObject);
    procedure actModifierExecute(Sender: TObject);
    procedure actSupprimerExecute(Sender: TObject);
    procedure actActualiserExecute(Sender: TObject);
    procedure actExporterExecute(Sender: TObject);
    procedure cboFiltreChange(Sender: TObject);
    procedure SearchBox1InvokeSearch(Sender: TObject);
    procedure DBGrid1CellClick(Column: TColumn);
    procedure FormResize(Sender: TObject);
  private
    { Déclarations privées }
    FQuery: TFDQuery;
    FFilterType: TFilterType;
    procedure LoadData(const ASearchTerm: string = '');
    procedure UpdateButtons;
    procedure UpdateTotalLabel;
    procedure PreviewProduit;
    function GetSelectedProduitID: Integer;
    procedure ExportToCSV;
    procedure AdjustGridColumns;
  public
    { Déclarations publiques }
  end;

var
  frmProduitsList: TfrmProduitsList;

implementation

{$R *.dfm}

uses
  dmBusiness, FormProduitEdit, FormProduitDetails, Winapi.ShellAPI,
  System.UITypes, Vcl.FileCtrl, System.IOUtils, System.Types;

procedure TfrmProduitsList.FormCreate(Sender: TObject);
begin
  FFilterType := ftTous;
  cboFiltre.ItemIndex := 4; // "Tous" par défaut

  LoadData;
  UpdateButtons;
  AdjustGridColumns;

  // Initialiser le panneau d'aperçu
  PanelPreview.Width := 250;
  PreviewProduit; // Afficher le premier produit
end;

procedure TfrmProduitsList.FormDestroy(Sender: TObject);
begin
  if Assigned(FQuery) then
    FQuery.Free;
end;

procedure TfrmProduitsList.FormResize(Sender: TObject);
begin
  AdjustGridColumns;
end;

procedure TfrmProduitsList.AdjustGridColumns;
var
  TotalWidth, i: Integer;
  ColWidths: array[0..5] of Double;
  ColPercents: array[0..5] of Double;
begin
  // Définir les pourcentages de largeur pour chaque colonne
  ColPercents[0] := 0.08; // ID
  ColPercents[1] := 0.17; // Référence
  ColPercents[2] := 0.35; // Désignation
  ColPercents[3] := 0.15; // Prix
  ColPercents[4] := 0.15; // Catégorie
  ColPercents[5] := 0.10; // Stock

  // Calculer la largeur totale disponible
  TotalWidth := DBGrid1.ClientWidth - 25; // 25 pour la scrollbar

  // Calculer la largeur de chaque colonne
  for i := 0 to 5 do
    ColWidths[i] := TotalWidth * ColPercents[i];

  // Appliquer les largeurs aux colonnes
  for i := 0 to 5 do
  begin
    if i < DBGrid1.Columns.Count then
      DBGrid1.Columns[i].Width := Round(ColWidths[i]);
  end;
end;

procedure TfrmProduitsList.LoadData(const ASearchTerm: string = '');
var
  SQL, WhereClause: string;
begin
  if Assigned(FQuery) then
    FQuery.Free;

  FQuery := TFDQuery.Create(nil);
  FQuery.Connection := DataModuleBusiness.ProduitRepository.Connection;

  SQL :=
    'SELECT p.ProduitID, p.Reference, p.Designation, p.PrixVente, p.TVA, ' +
    'c.NomCategorie, s.QuantiteDisponible, f.RaisonSociale AS Fournisseur ' +
    'FROM Produits p ' +
    'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
    'LEFT JOIN Stock s ON p.ProduitID = s.ProduitID ' +
    'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID';

  // Construire la clause WHERE selon le filtre et le terme de recherche
  if ASearchTerm <> '' then
  begin
    case FFilterType of
      ftReference:
        WhereClause := ' WHERE p.Reference LIKE ' + QuotedStr('%' + ASearchTerm + '%');
      ftDesignation:
        WhereClause := ' WHERE p.Designation LIKE ' + QuotedStr('%' + ASearchTerm + '%');
      ftCategorie:
        WhereClause := ' WHERE c.NomCategorie LIKE ' + QuotedStr('%' + ASearchTerm + '%');
      ftFournisseur:
        WhereClause := ' WHERE f.RaisonSociale LIKE ' + QuotedStr('%' + ASearchTerm + '%');
      ftTous:
        WhereClause := ' WHERE (p.Reference LIKE ' + QuotedStr('%' + ASearchTerm + '%') +
                       ' OR p.Designation LIKE ' + QuotedStr('%' + ASearchTerm + '%') +
                       ' OR c.NomCategorie LIKE ' + QuotedStr('%' + ASearchTerm + '%') +
                       ' OR f.RaisonSociale LIKE ' + QuotedStr('%' + ASearchTerm + '%') + ')';
    end;

    SQL := SQL + WhereClause;
  end;

  // Ajouter l'ordre de tri
  SQL := SQL + ' ORDER BY p.Designation';

  FQuery.SQL.Text := SQL;
  FQuery.Open;

  // Configurer les champs pour l'affichage
  FQuery.FieldByName('ProduitID').DisplayLabel := 'ID';
  FQuery.FieldByName('Reference').DisplayLabel := 'Référence';
  FQuery.FieldByName('Designation').DisplayLabel := 'Désignation';
  FQuery.FieldByName('PrixVente').DisplayLabel := 'Prix HT';
  FQuery.FieldByName('PrixVente').DisplayFormat := '#,##0.00 €';
  FQuery.FieldByName('NomCategorie').DisplayLabel := 'Catégorie';
  FQuery.FieldByName('QuantiteDisponible').DisplayLabel := 'Stock';
  FQuery.FieldByName('QuantiteDisponible').DisplayFormat := '#,##0';

  // Associer à la source de données
  DataSource1.DataSet := FQuery;

  // Mettre à jour le label de total
  UpdateTotalLabel;

  // Mettre à jour les boutons
  UpdateButtons;

  // Afficher un aperçu du premier produit
  if not FQuery.IsEmpty then
    PreviewProduit;
end;

procedure TfrmProduitsList.UpdateTotalLabel;
begin
  lblTotal.Caption := Format('Total : %d produits', [FQuery.RecordCount]);
end;

procedure TfrmProduitsList.UpdateButtons;
var
  HasSelection: Boolean;
begin
  HasSelection := not FQuery.IsEmpty;

  actModifier.Enabled := HasSelection;
  actSupprimer.Enabled := HasSelection;

  if HasSelection then
    StatusBar1.Panels[0].Text := 'Produit sélectionné : ' + FQuery.FieldByName('Designation').AsString
  else
    StatusBar1.Panels[0].Text := 'Aucun produit sélectionné';
end;

procedure TfrmProduitsList.PreviewProduit;
var
  PhotoPath: string;
  Query: TFDQuery;
begin
  if FQuery.IsEmpty then
  begin
    // Réinitialiser l'aperçu
    lblPreviewTitle.Caption := 'Aucun produit sélectionné';
    lblReference.Caption := '';
    lblDesignation.Caption := '';
    lblPrix.Caption := '';
    lblCategorie.Caption := '';
    lblStock.Caption := '';
    imgProduit.Picture := nil;
    Exit;
  end;

procedure TfrmProduitsList.PreviewProduit;
var
  PhotoPath: string;
  Query: TFDQuery;
begin
  if FQuery.IsEmpty then
  begin
    // Réinitialiser l'aperçu
    lblPreviewTitle.Caption := 'Aucun produit sélectionné';
    lblReference.Caption := '';
    lblDesignation.Caption := '';
    lblPrix.Caption := '';
    lblCategorie.Caption := '';
    lblStock.Caption := '';
    imgProduit.Picture := nil;
    Exit;
  end;

  // Charger les informations détaillées du produit
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleBusiness.ProduitRepository.Connection;
    Query.SQL.Text :=
      'SELECT p.*, c.NomCategorie, s.QuantiteDisponible, f.RaisonSociale AS Fournisseur ' +
      'FROM Produits p ' +
      'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
      'LEFT JOIN Stock s ON p.ProduitID = s.ProduitID ' +
      'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
      'WHERE p.ProduitID = :ProduitID';
    Query.ParamByName('ProduitID').AsInteger := FQuery.FieldByName('ProduitID').AsInteger;
    Query.Open;

    // Mettre à jour les labels
    lblPreviewTitle.Caption := 'Aperçu du produit';
    lblReference.Caption := 'Réf : ' + Query.FieldByName('Reference').AsString;
    lblDesignation.Caption := Query.FieldByName('Designation').AsString;

    // Afficher le prix TTC
    lblPrix.Caption := 'Prix : ' + FormatFloat('#,##0.00 €',
      Query.FieldByName('PrixVente').AsFloat * (1 + Query.FieldByName('TVA').AsFloat / 100));

    lblCategorie.Caption := 'Catégorie : ' + Query.FieldByName('NomCategorie').AsString;

    // Afficher le stock avec une couleur selon la disponibilité
    if Query.FieldByName('QuantiteDisponible').AsInteger <= 0 then
    begin
      lblStock.Font.Color := clRed;
      lblStock.Caption := 'Stock : Épuisé';
    end
    else if Query.FieldByName('QuantiteDisponible').AsInteger < 5 then
    begin
      lblStock.Font.Color := clOrange;
      lblStock.Caption := 'Stock : ' + Query.FieldByName('QuantiteDisponible').AsString + ' (Faible)';
    end
    else
    begin
      lblStock.Font.Color := clGreen;
      lblStock.Caption := 'Stock : ' + Query.FieldByName('QuantiteDisponible').AsString;
    end;

    // Charger l'image du produit si disponible
    PhotoPath := Query.FieldByName('PhotoURL').AsString;
    if (PhotoPath <> '') and FileExists(PhotoPath) then
    begin
      try
        imgProduit.Picture.LoadFromFile(PhotoPath);
      except
        // En cas d'erreur, on affiche une image par défaut
        imgProduit.Picture := nil;
      end;
    end
    else
    begin
      // Image par défaut si aucune photo n'est disponible
      imgProduit.Picture := nil;
    end;
  finally
    Query.Free;
  end;
end;

function TfrmProduitsList.GetSelectedProduitID: Integer;
begin
  Result := 0;

  if not FQuery.IsEmpty then
    Result := FQuery.FieldByName('ProduitID').AsInteger;
end;

procedure TfrmProduitsList.DBGrid1CellClick(Column: TColumn);
begin
  PreviewProduit;
  UpdateButtons;
end;

procedure TfrmProduitsList.cboFiltreChange(Sender: TObject);
begin
  // Mettre à jour le type de filtre
  FFilterType := TFilterType(cboFiltre.ItemIndex);

  // Réinitialiser la recherche
  SearchBox1.Text := '';

  // Recharger les données
  LoadData;
end;

procedure TfrmProduitsList.SearchBox1InvokeSearch(Sender: TObject);
begin
  LoadData(SearchBox1.Text);
end;

procedure TfrmProduitsList.actAjouterExecute(Sender: TObject);
var
  Form: TfrmProduitEdit;
begin
  Form := TfrmProduitEdit.Create(Self);
  try
    Form.InitAdd;
    if Form.ShowModal = mrOk then
    begin
      LoadData(SearchBox1.Text);
      ShowMessage('Produit ajouté avec succès !');
    end;
  finally
    Form.Free;
  end;
end;

procedure TfrmProduitsList.actModifierExecute(Sender: TObject);
var
  Form: TfrmProduitEdit;
  ID: Integer;
begin
  ID := GetSelectedProduitID;
  if ID <= 0 then
    Exit;

  Form := TfrmProduitEdit.Create(Self);
  try
    Form.InitEdit(ID);
    if Form.ShowModal = mrOk then
    begin
      LoadData(SearchBox1.Text);
      ShowMessage('Produit modifié avec succès !');
    end;
  finally
    Form.Free;
  end;
end;

procedure TfrmProduitsList.actSupprimerExecute(Sender: TObject);
var
  ID: Integer;
  Designation: string;
begin
  ID := GetSelectedProduitID;
  if ID <= 0 then
    Exit;

  Designation := FQuery.FieldByName('Designation').AsString;

  if MessageDlg(Format('Êtes-vous sûr de vouloir supprimer le produit "%s" ?',
    [Designation]), mtConfirmation, [mbYes, mbNo], 0) = mrYes then
  begin
    if DataModuleBusiness.ProduitRepository.Supprimer(ID) then
    begin
      LoadData(SearchBox1.Text);
      ShowMessage('Produit supprimé avec succès !');
    end
    else
      ShowMessage('Erreur lors de la suppression du produit.');
  end;
end;

procedure TfrmProduitsList.actActualiserExecute(Sender: TObject);
begin
  SearchBox1.Text := '';
  LoadData;
end;

procedure TfrmProduitsList.ExportToCSV;
var
  SaveDialog: TSaveDialog;
  CSVFile: TextFile;
  i, j: Integer;
  Line, CellValue: string;
  OutputDir: string;
begin
  SaveDialog := TSaveDialog.Create(nil);
  try
    SaveDialog.Title := 'Exporter les produits au format CSV';
    SaveDialog.Filter := 'Fichiers CSV (*.csv)|*.csv';
    SaveDialog.DefaultExt := 'csv';
    SaveDialog.FileName := 'liste_produits_' + FormatDateTime('yyyymmdd', Now) + '.csv';

    if not SaveDialog.Execute then
      Exit;

    OutputDir := ExtractFilePath(SaveDialog.FileName);
    if not DirectoryExists(OutputDir) then
      ForceDirectories(OutputDir);

    AssignFile(CSVFile, SaveDialog.FileName);
    Rewrite(CSVFile);

    try
      // Écrire l'en-tête
      Line := '';
      for i := 0 to DBGrid1.Columns.Count - 1 do
      begin
        if i > 0 then
          Line := Line + ';';
        Line := Line + '"' + DBGrid1.Columns[i].Title.Caption + '"';
      end;
      WriteLn(CSVFile, Line);

      // Écrire les données
      FQuery.First;
      while not FQuery.Eof do
      begin
        Line := '';
        for i := 0 to DBGrid1.Columns.Count - 1 do
        begin
          if i > 0 then
            Line := Line + ';';

          CellValue := FQuery.Fields[i].AsString;
          // Remplacer les guillemets par des doubles guillemets pour CSV
          CellValue := StringReplace(CellValue, '"', '""', [rfReplaceAll]);
          Line := Line + '"' + CellValue + '"';
        end;
        WriteLn(CSVFile, Line);
        FQuery.Next;
      end;

      // Afficher un message de confirmation
      if MessageDlg('Export CSV terminé avec succès. Voulez-vous ouvrir le fichier ?',
         mtConfirmation, [mbYes, mbNo], 0) = mrYes then
      begin
        ShellExecute(0, 'open', PChar(SaveDialog.FileName), nil, nil, SW_SHOWNORMAL);
      end;
    finally
      CloseFile(CSVFile);
    end;
  finally
    SaveDialog.Free;
  end;
end;

procedure TfrmProduitsList.actExporterExecute(Sender: TObject);
begin
  ExportToCSV;
end;
```

## Création d'un formulaire de détails avec onglets

Créons maintenant un formulaire détaillé pour afficher toutes les informations d'un produit, avec une interface à onglets pour une meilleure organisation :

```pascal
unit FormProduitDetails;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ComCtrls, Vcl.ExtCtrls,
  Vcl.StdCtrls, Vcl.Imaging.pngimage, Vcl.Buttons, Data.DB, FireDAC.Comp.Client,
  Vcl.Grids, Vcl.DBGrids, System.Actions, Vcl.ActnList,
  Produit, ProduitRepository, dmDatabase, dmBusiness;

type
  TfrmProduitDetails = class(TForm)
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    TabSheet2: TTabSheet;
    TabSheet3: TTabSheet;
    TabSheet4: TTabSheet;
    pnlTop: TPanel;
    lblTitre: TLabel;
    btnClose: TSpeedButton;
    btnEdit: TSpeedButton;
    pnlInfos: TPanel;
    lblReference: TLabel;
    lblDesignation: TLabel;
    lblDescription: TLabel;
    lblPrixAchat: TLabel;
    lblPrixVente: TLabel;
    lblTVA: TLabel;
    lblCategorie: TLabel;
    lblFournisseur: TLabel;
    memoDescription: TMemo;
    imgProduit: TImage;
    lblDateCreation: TLabel;
    pnlStock: TPanel;
    lblStockDisponible: TLabel;
    lblStockMinimum: TLabel;
    lblEmplacement: TLabel;
    lblDerniereMAJ: TLabel;
    btnCommanderStock: TButton;
    DBGridMouvements: TDBGrid;
    lblMouvements: TLabel;
    pnlCommandes: TPanel;
    lblHistoriqueCommandes: TLabel;
    DBGridCommandes: TDBGrid;
    pnlStats: TPanel;
    lblStatistiques: TLabel;
    lblVentesMois: TLabel;
    lblVentesAnnee: TLabel;
    lblEvolution: TLabel;
    chartVentes: TPanel;
    ActionList1: TActionList;
    actEditer: TAction;
    actCommanderStock: TAction;
    actExportHistorique: TAction;
    btnExportHistorique: TButton;
    DataSource1: TDataSource;
    DataSource2: TDataSource;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure btnCloseClick(Sender: TObject);
    procedure actEditerExecute(Sender: TObject);
    procedure actCommanderStockExecute(Sender: TObject);
    procedure actExportHistoriqueExecute(Sender: TObject);
    procedure FormShow(Sender: TObject);
  private
    { Déclarations privées }
    FProduitID: Integer;
    FProduit: TProduit;
    FQueryMouvements: TFDQuery;
    FQueryCommandes: TFDQuery;
    procedure LoadProduit;
    procedure LoadMouvements;
    procedure LoadCommandes;
    procedure LoadStatistiques;
    procedure UpdateLabels;
  public
    { Déclarations publiques }
    constructor Create(AOwner: TComponent; AProduitID: Integer); reintroduce;
  end;

implementation

{$R *.dfm}

uses
  FormProduitEdit, System.UITypes, Vcl.FileCtrl, System.IOUtils;

constructor TfrmProduitDetails.Create(AOwner: TComponent; AProduitID: Integer);
begin
  inherited Create(AOwner);
  FProduitID := AProduitID;
end;

procedure TfrmProduitDetails.FormCreate(Sender: TObject);
begin
  FProduit := nil;
  FQueryMouvements := nil;
  FQueryCommandes := nil;

  // Par défaut, on affiche le premier onglet
  PageControl1.ActivePageIndex := 0;
end;

procedure TfrmProduitDetails.FormDestroy(Sender: TObject);
begin
  if Assigned(FProduit) then
    FProduit.Free;

  if Assigned(FQueryMouvements) then
    FQueryMouvements.Free;

  if Assigned(FQueryCommandes) then
    FQueryCommandes.Free;
end;

procedure TfrmProduitDetails.FormShow(Sender: TObject);
begin
  LoadProduit;
  LoadMouvements;
  LoadCommandes;
  LoadStatistiques;
end;

procedure TfrmProduitDetails.LoadProduit;
var
  Query: TFDQuery;
begin
  // Libérer l'objet précédent s'il existe
  if Assigned(FProduit) then
    FProduit.Free;

  // Charger le produit complet
  FProduit := DataModuleBusiness.ProduitRepository.ObtenirParID(FProduitID);

  if FProduit = nil then
  begin
    ShowMessage('Produit non trouvé !');
    Close;
    Exit;
  end;

  // Mettre à jour le titre
  lblTitre.Caption := FProduit.Designation;

  // Charger les informations complémentaires (catégorie, fournisseur, stock)
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text :=
      'SELECT p.*, c.NomCategorie, f.RaisonSociale AS NomFournisseur, ' +
      's.QuantiteDisponible, s.StockMinimum, s.Emplacement, s.DerniereMiseAJour ' +
      'FROM Produits p ' +
      'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
      'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
      'LEFT JOIN Stock s ON p.ProduitID = s.ProduitID ' +
      'WHERE p.ProduitID = :ProduitID';
    Query.ParamByName('ProduitID').AsInteger := FProduitID;
    Query.Open;

    if not Query.IsEmpty then
    begin
      // Mettre à jour les labels avec les informations
      lblReference.Caption := 'Référence : ' + Query.FieldByName('Reference').AsString;
      lblDesignation.Caption := Query.FieldByName('Designation').AsString;
      memoDescription.Text := Query.FieldByName('Description').AsString;
      lblPrixAchat.Caption := 'Prix d''achat : ' + FormatFloat('#,##0.00 €', Query.FieldByName('PrixAchat').AsFloat);
      lblPrixVente.Caption := 'Prix de vente HT : ' + FormatFloat('#,##0.00 €', Query.FieldByName('PrixVente').AsFloat);
      lblTVA.Caption := 'TVA : ' + FormatFloat('0.0 %', Query.FieldByName('TVA').AsFloat);

      // Prix TTC
      lblPrixVente.Hint := 'Prix TTC : ' + FormatFloat('#,##0.00 €',
        Query.FieldByName('PrixVente').AsFloat * (1 + Query.FieldByName('TVA').AsFloat / 100));
      lblPrixVente.ShowHint := True;

      lblCategorie.Caption := 'Catégorie : ' + Query.FieldByName('NomCategorie').AsString;
      lblFournisseur.Caption := 'Fournisseur : ' + Query.FieldByName('NomFournisseur').AsString;
      lblDateCreation.Caption := 'Date d''ajout : ' + FormatDateTime('dd/mm/yyyy', Query.FieldByName('DateCreation').AsDateTime);

      // Stock
      if not Query.FieldByName('QuantiteDisponible').IsNull then
      begin
        lblStockDisponible.Caption := 'Stock disponible : ' + Query.FieldByName('QuantiteDisponible').AsString;

        // Couleur selon le niveau de stock
        if Query.FieldByName('QuantiteDisponible').AsInteger <= 0 then
          lblStockDisponible.Font.Color := clRed
        else if Query.FieldByName('QuantiteDisponible').AsInteger < Query.FieldByName('StockMinimum').AsInteger then
          lblStockDisponible.Font.Color := clOrange
        else
          lblStockDisponible.Font.Color := clGreen;
      end
      else
        lblStockDisponible.Caption := 'Stock disponible : Non suivi';

      lblStockMinimum.Caption := 'Stock minimum : ' + Query.FieldByName('StockMinimum').AsString;
      lblEmplacement.Caption := 'Emplacement : ' + Query.FieldByName('Emplacement').AsString;

      if not Query.FieldByName('DerniereMiseAJour').IsNull then
        lblDerniereMAJ.Caption := 'Dernière mise à jour : ' +
          FormatDateTime('dd/mm/yyyy hh:nn', Query.FieldByName('DerniereMiseAJour').AsDateTime)
      else
        lblDerniereMAJ.Caption := 'Dernière mise à jour : Jamais';

      // Chargement de l'image
      if (FProduit.PhotoURL <> '') and FileExists(FProduit.PhotoURL) then
      begin
        try
          imgProduit.Picture.LoadFromFile(FProduit.PhotoURL);
        except
          // En cas d'erreur, on laisse l'image vide
        end;
      end;
    end;
  finally
    Query.Free;
  end;
end;

procedure TfrmProduitDetails.LoadMouvements;
begin
  if Assigned(FQueryMouvements) then
    FQueryMouvements.Free;

  FQueryMouvements := TFDQuery.Create(nil);
  FQueryMouvements.Connection := DataModuleDB.FDConnection;
  FQueryMouvements.SQL.Text :=
    'SELECT m.MouvementID, m.DateMouvement, m.TypeMouvement, m.Quantite, ' +
    'm.Commentaire, u.Nom AS Utilisateur ' +
    'FROM MouvementStock m ' +
    'LEFT JOIN Utilisateurs u ON m.UtilisateurID = u.UtilisateurID ' +
    'WHERE m.ProduitID = :ProduitID ' +
    'ORDER BY m.DateMouvement DESC';
  FQueryMouvements.ParamByName('ProduitID').AsInteger := FProduitID;
  FQueryMouvements.Open;

  // Configuration de l'affichage des colonnes
  DataSource1.DataSet := FQueryMouvements;

  // Titre mis à jour avec le nombre de mouvements
  lblMouvements.Caption := Format('Historique des mouvements (%d)', [FQueryMouvements.RecordCount]);
end;

procedure TfrmProduitDetails.LoadCommandes;
begin
  if Assigned(FQueryCommandes) then
    FQueryCommandes.Free;

  FQueryCommandes := TFDQuery.Create(nil);
  FQueryCommandes.Connection := DataModuleDB.FDConnection;
  FQueryCommandes.SQL.Text :=
    'SELECT c.CommandeID, c.Reference, c.DateCommande, c.Statut, ' +
    'cl.Nom AS NomClient, l.Quantite, l.PrixUnitaire, l.Remise ' +
    'FROM Commandes c ' +
    'JOIN LignesCommande l ON c.CommandeID = l.CommandeID ' +
    'JOIN Clients cl ON c.ClientID = cl.ClientID ' +
    'WHERE l.ProduitID = :ProduitID ' +
    'ORDER BY c.DateCommande DESC';
  FQueryCommandes.ParamByName('ProduitID').AsInteger := FProduitID;
  FQueryCommandes.Open;

  // Configuration de l'affichage des colonnes
  DataSource2.DataSet := FQueryCommandes;

  // Titre mis à jour avec le nombre de commandes
  lblHistoriqueCommandes.Caption := Format('Historique des commandes (%d)', [FQueryCommandes.RecordCount]);
end;

procedure TfrmProduitDetails.LoadStatistiques;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;

    // Ventes du mois en cours
    Query.SQL.Text :=
      'SELECT SUM(l.Quantite) AS TotalVentes, SUM(l.Quantite * l.PrixUnitaire) AS MontantTotal ' +
      'FROM LignesCommande l ' +
      'JOIN Commandes c ON l.CommandeID = c.CommandeID ' +
      'WHERE l.ProduitID = :ProduitID ' +
      'AND YEAR(c.DateCommande) = YEAR(CURRENT_DATE) ' +
      'AND MONTH(c.DateCommande) = MONTH(CURRENT_DATE) ' +
      'AND c.Statut NOT IN (''Annulée'')';
    Query.ParamByName('ProduitID').AsInteger := FProduitID;
    Query.Open;

    if not Query.FieldByName('TotalVentes').IsNull then
      lblVentesMois.Caption := Format('Ventes du mois : %d unités / %s',
        [Query.FieldByName('TotalVentes').AsInteger,
         FormatFloat('#,##0.00 €', Query.FieldByName('MontantTotal').AsFloat)])
    else
      lblVentesMois.Caption := 'Ventes du mois : 0 unité / 0,00 €';

    Query.Close;

    // Ventes de l'année en cours
    Query.SQL.Text :=
      'SELECT SUM(l.Quantite) AS TotalVentes, SUM(l.Quantite * l.PrixUnitaire) AS MontantTotal ' +
      'FROM LignesCommande l ' +
      'JOIN Commandes c ON l.CommandeID = c.CommandeID ' +
      'WHERE l.ProduitID = :ProduitID ' +
      'AND YEAR(c.DateCommande) = YEAR(CURRENT_DATE) ' +
      'AND c.Statut NOT IN (''Annulée'')';
    Query.ParamByName('ProduitID').AsInteger := FProduitID;
    Query.Open;

    if not Query.FieldByName('TotalVentes').IsNull then
      lblVentesAnnee.Caption := Format('Ventes de l''année : %d unités / %s',
        [Query.FieldByName('TotalVentes').AsInteger,
         FormatFloat('#,##0.00 €', Query.FieldByName('MontantTotal').AsFloat)])
    else
      lblVentesAnnee.Caption := 'Ventes de l''année : 0 unité / 0,00 €';

    Query.Close;

    // Évolution par rapport au mois précédent
    Query.SQL.Text :=
      'SELECT ' +
      '(SELECT SUM(l.Quantite) FROM LignesCommande l ' +
      'JOIN Commandes c ON l.CommandeID = c.CommandeID ' +
      'WHERE l.ProduitID = :ProduitID ' +
      'AND YEAR(c.DateCommande) = YEAR(CURRENT_DATE) ' +
      'AND MONTH(c.DateCommande) = MONTH(CURRENT_DATE) ' +
      'AND c.Statut NOT IN (''Annulée'')) AS VentesMoisCourant, ' +

      '(SELECT SUM(l.Quantite) FROM LignesCommande l ' +
      'JOIN Commandes c ON l.CommandeID = c.CommandeID ' +
      'WHERE l.ProduitID = :ProduitID ' +
      'AND YEAR(c.DateCommande) = YEAR(DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)) ' +
      'AND MONTH(c.DateCommande) = MONTH(DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)) ' +
      'AND c.Statut NOT IN (''Annulée'')) AS VentesMoisPrecedent';
    Query.ParamByName('ProduitID').AsInteger := FProduitID;
    Query.Open;

    if (not Query.FieldByName('VentesMoisCourant').IsNull) and
       (not Query.FieldByName('VentesMoisPrecedent').IsNull) and
       (Query.FieldByName('VentesMoisPrecedent').AsInteger > 0) then
    begin
      // Calculer l'évolution en pourcentage
      var VentesMoisCourant: Integer := Query.FieldByName('VentesMoisCourant').AsInteger;
      var VentesMoisPrecedent: Integer := Query.FieldByName('VentesMoisPrecedent').AsInteger;
      var Evolution: Double := ((VentesMoisCourant - VentesMoisPrecedent) / VentesMoisPrecedent) * 100;

      if Evolution > 0 then
      begin
        lblEvolution.Caption := Format('Évolution : +%.1f%% par rapport au mois précédent', [Evolution]);
        lblEvolution.Font.Color := clGreen;
      end
      else if Evolution < 0 then
      begin
        lblEvolution.Caption := Format('Évolution : %.1f%% par rapport au mois précédent', [Evolution]);
        lblEvolution.Font.Color := clRed;
      end
      else
      begin
        lblEvolution.Caption := 'Évolution : stable par rapport au mois précédent';
        lblEvolution.Font.Color := clWindowText;
      end;
    end
    else
      lblEvolution.Caption := 'Évolution : non disponible';

    // Ici, on pourrait ajouter du code pour générer un graphique des ventes
    // en utilisant par exemple TeeChart ou un autre composant de graphique
  finally
    Query.Free;
  end;
end;

procedure TfrmProduitDetails.actCommanderStockExecute(Sender: TObject);
var
  Quantite: Integer;
begin
  if not InputQuery('Commander du stock', 'Quantité à commander :', Quantite) then
    Exit;

  if Quantite <= 0 then
  begin
    ShowMessage('Veuillez entrer une quantité valide.');
    Exit;
  end;

  // Ici, on pourrait implémenter la création d'une commande fournisseur
  // ou d'un mouvement de stock prévu

  ShowMessage(Format('Commande de %d unités effectuée.', [Quantite]));

  // Recharger les données
  LoadMouvements;
end;

procedure TfrmProduitDetails.actEditerExecute(Sender: TObject);
var
  Form: TfrmProduitEdit;
begin
  Form := TfrmProduitEdit.Create(Self);
  try
    Form.InitEdit(FProduitID);
    if Form.ShowModal = mrOk then
    begin
      // Recharger les données
      LoadProduit;
      LoadMouvements;
      LoadCommandes;
      LoadStatistiques;
      ShowMessage('Produit modifié avec succès !');
    end;
  finally
    Form.Free;
  end;
end;

procedure TfrmProduitDetails.actExportHistoriqueExecute(Sender: TObject);
var
  SaveDialog: TSaveDialog;
  CSVFile: TextFile;
  i: Integer;
  Line, CellValue: string;
begin
  SaveDialog := TSaveDialog.Create(nil);
  try
    SaveDialog.Title := 'Exporter l''historique au format CSV';
    SaveDialog.Filter := 'Fichiers CSV (*.csv)|*.csv';
    SaveDialog.DefaultExt := 'csv';
    SaveDialog.FileName := 'historique_' + FProduit.Reference + '_' + FormatDateTime('yyyymmdd', Now) + '.csv';

    if not SaveDialog.Execute then
      Exit;

    AssignFile(CSVFile, SaveDialog.FileName);
    Rewrite(CSVFile);

    try
      // Écrire l'en-tête
      Line := '';
      for i := 0 to DBGridMouvements.Columns.Count - 1 do
      begin
        if i > 0 then
          Line := Line + ';';
        Line := Line + '"' + DBGridMouvements.Columns[i].Title.Caption + '"';
      end;
      WriteLn(CSVFile, Line);

      // Écrire les données
      FQueryMouvements.First;
      while not FQueryMouvements.Eof do
      begin
        Line := '';
        for i := 0 to DBGridMouvements.Columns.Count - 1 do
        begin
          if i > 0 then
            Line := Line + ';';

          CellValue := DBGridMouvements.Columns[i].Field.AsString;
          // Remplacer les guillemets par des doubles guillemets pour CSV
          CellValue := StringReplace(CellValue, '"', '""', [rfReplaceAll]);
          Line := Line + '"' + CellValue + '"';
        end;
        WriteLn(CSVFile, Line);
        FQueryMouvements.Next;
      end;

      ShowMessage('Export terminé avec succès : ' + SaveDialog.FileName);
    finally
      CloseFile(CSVFile);
    end;
  finally
    SaveDialog.Free;
  end;
end;

procedure TfrmProduitDetails.btnCloseClick(Sender: TObject);
begin
  Close;
end;
```

## Création d'un formulaire de commande avec gestion du panier

Maintenant, créons un formulaire pour gérer les commandes des clients avec une interface intuitive de type "panier d'achat" :

```pascal
unit FormCommandeEdit;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls,
  Vcl.ComCtrls, Vcl.Buttons, Vcl.Grids, Vcl.DBGrids, Data.DB, FireDAC.Comp.Client,
  System.Actions, Vcl.ActnList, Vcl.Mask, Vcl.DBCtrls, JvExMask, JvToolEdit,
  JvBaseEdits, Commande, Client, dmDatabase, dmBusiness;

type
  TfrmCommandeEdit = class(TForm)
    pnlTop: TPanel;
    lblTitre: TLabel;
    pnlClient: TPanel;
    pnlBottom: TPanel;
    btnValider: TButton;
    btnAnnuler: TButton;
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    TabSheet2: TTabSheet;
    TabSheet3: TTabSheet;
    pnlClient1: TPanel;
    pnlClient2: TPanel;
    pnlClient3: TPanel;
    lblReference: TLabel;
    edtReference: TEdit;
    lblClient: TLabel;
    cboClient: TDBLookupComboBox;
    btnNouveauClient: TSpeedButton;
    lblDateCommande: TLabel;
    dtpDateCommande: TDateTimePicker;
    lblDateLivraison: TLabel;
    dtpDateLivraison: TDateTimePicker;
    lblStatut: TLabel;
    cboStatut: TComboBox;
    lblVendeur: TLabel;
    cboVendeur: TDBLookupComboBox;
    gbAdresseLivraison: TGroupBox;
    memoAdresseLivraison: TMemo;
    btnCopierAdresseClient: TButton;
    btnPrecedent1: TButton;
    btnSuivant1: TButton;
    pnlRechercherProduit: TPanel;
    lblRechercherProduit: TLabel;
    edtRechercheProduit: TEdit;
    btnRechercherProduit: TSpeedButton;
    StringGrid1: TStringGrid;
    pnlDetailsProduit: TPanel;
    lblProduitSelectionne: TLabel;
    lblPrixUnitaire: TLabel;
    lblQuantiteStock: TLabel;
    lblQuantite: TLabel;
    edtQuantite: TJvCalcEdit;
    lblRemise: TLabel;
    edtRemise: TJvCalcEdit;
    btnAjouterProduit: TButton;
    pnlLignesCommande: TPanel;
    StringGrid2: TStringGrid;
    pnlActionsLigne: TPanel;
    btnModifierLigne: TButton;
    btnSupprimerLigne: TButton;
    btnPrecedent2: TButton;
    btnSuivant2: TButton;
    pnlResume: TPanel;
    lblResume: TLabel;
    lblTotalHT: TLabel;
    lblTotalTVA: TLabel;
    lblTotalTTC: TLabel;
    lblPaiement: TLabel;
    cboPaiement: TComboBox;
    lblFraisPort: TLabel;
    edtFraisPort: TJvCalcEdit;
    memoCommentaires: TMemo;
    lblCommentaires: TLabel;
    lblAcompte: TLabel;
    edtAcompte: TJvCalcEdit;
    DataSource1: TDataSource;
    DataSource2: TDataSource;
    ActionList1: TActionList;
    actEnregistrer: TAction;
    actAnnuler: TAction;
    actRechercherProduit: TAction;
    actAjouterProduit: TAction;
    actModifierLigne: TAction;
    actSupprimerLigne: TAction;
    actNouveauClient: TAction;
    actCopierAdresseClient: TAction;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure actRechercherProduitExecute(Sender: TObject);
    procedure StringGrid1SelectCell(Sender: TObject; ACol, ARow: Integer;
      var CanSelect: Boolean);
    procedure actAjouterProduitExecute(Sender: TObject);
    procedure actModifierLigneExecute(Sender: TObject);
    procedure actSupprimerLigneExecute(Sender: TObject);
    procedure btnSuivant1Click(Sender: TObject);
    procedure btnPrecedent2Click(Sender: TObject);
    procedure btnSuivant2Click(Sender: TObject);
    procedure actEnregistrerExecute(Sender: TObject);
    procedure actAnnulerExecute(Sender: TObject);
    procedure actNouveauClientExecute(Sender: TObject);
    procedure actCopierAdresseClientExecute(Sender: TObject);
    procedure cboPaiementChange(Sender: TObject);
    procedure edtRemiseChange(Sender: TObject);
    procedure edtQuantiteChange(Sender: TObject);
    procedure edtFraisPortChange(Sender: TObject);
    procedure StringGrid2SelectCell(Sender: TObject; ACol, ARow: Integer;
      var CanSelect: Boolean);
  private
    { Déclarations privées }
    FCommande: TCommande;
    FMode: string; // 'Add' ou 'Edit'
    FProduitSelectionneID: Integer;
    FProduitSelectionnePrix: Double;
    FProduitSelectionneStock: Integer;
    FLigneSelectionnee: Integer;
    FQueryProduits: TFDQuery;

    procedure InitializeGrids;
    procedure LoadClients;
    procedure LoadVendeurs;
    procedure LoadCommande;
    procedure SaveCommande;
    procedure CalculerTotaux;
    procedure AjouterLigne(ProduitID: Integer; Reference, Designation: string;
      Quantite: Integer; PrixUnitaire, Remise: Double);
    procedure ModifierLigne(ARow: Integer; Quantite: Integer; Remise: Double);
    procedure SupprimerLigne(ARow: Integer);
    procedure MettreAJourDetailsProduit;
    function VerifierFormulaire: Boolean;
  public
    { Déclarations publiques }
    procedure InitAdd;
    procedure InitEdit(ACommandeID: Integer);
  end;

var
  frmCommandeEdit: TfrmCommandeEdit;

implementation

{$R *.dfm}

uses
  FormClientEdit, System.Math, System.UITypes;

procedure TfrmCommandeEdit.FormCreate(Sender: TObject);
begin
  FCommande := TCommande.Create;
  FMode := 'Add';
  FProduitSelectionneID := 0;
  FProduitSelectionnePrix := 0;
  FProduitSelectionneStock := 0;
  FLigneSelectionnee := 0;
  FQueryProduits := nil;

  // Initialiser les contrôles
  dtpDateCommande.Date := Date;
  dtpDateLivraison.Date := Date + 7; // Par défaut, livraison dans 1 semaine

  // Initialiser les statuts
  cboStatut.Items.Clear;
  cboStatut.Items.Add('En attente');
  cboStatut.Items.Add('Validée');
  cboStatut.Items.Add('En préparation');
  cboStatut.Items.Add('Expédiée');
  cboStatut.Items.Add('Livrée');
  cboStatut.Items.Add('Annulée');
  cboStatut.ItemIndex := 0;

  // Initialiser les modes de paiement
  cboPaiement.Items.Clear;
  cboPaiement.Items.Add('Virement bancaire');
  cboPaiement.Items.Add('Carte bancaire');
  cboPaiement.Items.Add('Chèque');
  cboPaiement.Items.Add('Espèces');
  cboPaiement.ItemIndex := 0;

  // Initialiser les grilles
  InitializeGrids;

  // Charger les clients et vendeurs
  LoadClients;
  LoadVendeurs;

  // Afficher le premier onglet
  PageControl1.ActivePageIndex := 0;
end;

procedure TfrmCommandeEdit.FormDestroy(Sender: TObject);
begin
  FCommande.Free;

  if Assigned(FQueryProduits) then
    FQueryProduits.Free;
end;

procedure TfrmCommandeEdit.InitializeGrids;
begin
  // Grille des produits (recherche)
  with StringGrid1 do
  begin
    ColCount := 5;
    RowCount := 2;
    FixedRows := 1;

    Cells[0, 0] := 'ID';
    Cells[1, 0] := 'Référence';
    Cells[2, 0] := 'Désignation';
    Cells[3, 0] := 'Prix HT';
    Cells[4, 0] := 'Stock';

    ColWidths[0] := 40;
    ColWidths[1] := 100;
    ColWidths[2] := 300;
    ColWidths[3] := 80;
    ColWidths[4] := 60;

    // Effacer la première ligne de données
    Cells[0, 1] := '';
    Cells[1, 1] := '';
    Cells[2, 1] := '';
    Cells[3, 1] := '';
    Cells[4, 1] := '';
  end;

  // Grille des lignes de commande
  with StringGrid2 do
  begin
    ColCount := 6;
    RowCount := 2;
    FixedRows := 1;

    Cells[0, 0] := 'ID';
    Cells[1, 0] := 'Référence';
    Cells[2, 0] := 'Désignation';
    Cells[3, 0] := 'Quantité';
    Cells[4, 0] := 'Prix unitaire';
    Cells[5, 0] := 'Total HT';

    ColWidths[0] := 40;
    ColWidths[1] := 100;
    ColWidths[2] := 300;
    ColWidths[3] := 70;
    ColWidths[4] := 90;
    ColWidths[5] := 90;

    // Effacer la première ligne de données
    Cells[0, 1] := '';
    Cells[1, 1] := '';
    Cells[2, 1] := '';
    Cells[3, 1] := '';
    Cells[4, 1] := '';
    Cells[5, 1] := '';
  end;
end;

procedure TfrmCommandeEdit.LoadClients;
var
  Query: TFDQuery;
begin
  // Charger la liste des clients pour le DBLookupComboBox
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text :=
      'SELECT ClientID, CONCAT(Nom, '' '', Prenom, IFNULL(CONCAT('' - '', Societe), '''')) AS NomComplet ' +
      'FROM Clients ORDER BY Nom, Prenom';
    Query.Open;

    DataSource1.DataSet := Query;
    cboClient.ListSource := DataSource1;
    cboClient.ListField := 'NomComplet';
    cboClient.KeyField := 'ClientID';
  except
    on E: Exception do
    begin
      ShowMessage('Erreur lors du chargement des clients : ' + E.Message);
      Query.Free;
    end;
  end;
end;

procedure TfrmCommandeEdit.LoadVendeurs;
var
  Query: TFDQuery;
begin
  // Charger la liste des vendeurs (utilisateurs)
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text :=
      'SELECT UtilisateurID, CONCAT(Nom, '' '', Prenom) AS NomComplet ' +
      'FROM Utilisateurs WHERE Actif = TRUE ORDER BY Nom, Prenom';
    Query.Open;

    DataSource2.DataSet := Query;
    cboVendeur.ListSource := DataSource2;
    cboVendeur.ListField := 'NomComplet';
    cboVendeur.KeyField := 'UtilisateurID';

    // Par défaut, sélectionner l'utilisateur courant (à implémenter)
  except
    on E: Exception do
    begin
      ShowMessage('Erreur lors du chargement des vendeurs : ' + E.Message);
      Query.Free;
    end;
  end;
end;

procedure TfrmCommandeEdit.actRechercherProduitExecute(Sender: TObject);
var
  TermeRecherche: string;
  Row: Integer;
begin
  TermeRecherche := Trim(edtRechercheProduit.Text);
  if TermeRecherche = '' then
  begin
    ShowMessage('Veuillez saisir un terme de recherche.');
    Exit;
  end;

  // Réinitialiser la grille
  StringGrid1.RowCount := 2;
  for Row := 0 to StringGrid1.ColCount - 1 do
    StringGrid1.Cells[Row, 1] := '';

  // Libérer la requête précédente si existante
  if Assigned(FQueryProduits) then
    FQueryProduits.Free;

  // Créer la nouvelle requête
  FQueryProduits := TFDQuery.Create(nil);
  FQueryProduits.Connection := DataModuleDB.FDConnection;
  FQueryProduits.SQL.Text :=
    'SELECT p.ProduitID, p.Reference, p.Designation, p.PrixVente, ' +
    'IFNULL(s.QuantiteDisponible, 0) AS QuantiteDisponible ' +
    'FROM Produits p ' +
    'LEFT JOIN Stock s ON p.ProduitID = s.ProduitID ' +
    'WHERE p.Actif = TRUE AND ' +
    '(p.Reference LIKE :Terme OR p.Designation LIKE :Terme) ' +
    'ORDER BY p.Designation';
  FQueryProduits.ParamByName('Terme').AsString := '%' + TermeRecherche + '%';
  FQueryProduits.Open;

  // Remplir la grille avec les résultats
  Row := 1;
  while not FQueryProduits.Eof do
  begin
    if Row >= StringGrid1.RowCount then
      StringGrid1.RowCount := StringGrid1.RowCount + 1;

    StringGrid1.Cells[0, Row] := FQueryProduits.FieldByName('ProduitID').AsString;
    StringGrid1.Cells[1, Row] := FQueryProduits.FieldByName('Reference').AsString;
    StringGrid1.Cells[2, Row] := FQueryProduits.FieldByName('Designation').AsString;
    StringGrid1.Cells[3, Row] := FormatFloat('#,##0.00 €', FQueryProduits.FieldByName('PrixVente').AsFloat);
    StringGrid1.Cells[4, Row] := FQueryProduits.FieldByName('QuantiteDisponible').AsString;

    Inc(Row);
    FQueryProduits.Next;
  end;

  // Si aucun résultat
  if FQueryProduits.RecordCount = 0 then
  begin
    ShowMessage('Aucun produit trouvé avec ce terme de recherche.');
    StringGrid1.RowCount := 2; // Garder une ligne vide
  end;
end;

procedure TfrmCommandeEdit.StringGrid1SelectCell(Sender: TObject; ACol, ARow: Integer;
  var CanSelect: Boolean);
begin
  // Sélection d'un produit dans la grille de recherche
  if (ARow > 0) and (ARow < StringGrid1.RowCount) and (StringGrid1.Cells[0, ARow] <> '') then
  begin
    FProduitSelectionneID := StrToIntDef(StringGrid1.Cells[0, ARow], 0);
    FProduitSelectionnePrix := StrToFloatDef(StringReplace(StringGrid1.Cells[3, ARow], ' €', '', []), 0);
    FProduitSelectionneStock := StrToIntDef(StringGrid1.Cells[4, ARow], 0);

    // Mettre à jour les informations
    MettreAJourDetailsProduit;
  end
  else
  begin
    FProduitSelectionneID := 0;
    FProduitSelectionnePrix := 0;
    FProduitSelectionneStock := 0;

    // Réinitialiser les informations
    lblProduitSelectionne.Caption := 'Aucun produit sélectionné';
    lblPrixUnitaire.Caption := 'Prix unitaire : 0,00 €';
    lblQuantiteStock.Caption := 'Stock disponible : 0';
    edtQuantite.Value := 1;
    edtRemise.Value := 0;
  end;

  // Mettre à jour le bouton d'ajout
  actAjouterProduit.Enabled := FProduitSelectionneID > 0;
end;

procedure TfrmCommandeEdit.MettreAJourDetailsProduit;
begin
  if FProduitSelectionneID > 0 then
  begin
    lblProduitSelectionne.Caption := 'Produit : ' + StringGrid1.Cells[2, StringGrid1.Selection.Top];
    lblPrixUnitaire.Caption := 'Prix unitaire : ' + FormatFloat('#,##0.00 €', FProduitSelectionnePrix);
    lblQuantiteStock.Caption := 'Stock disponible : ' + IntToStr(FProduitSelectionneStock);

    // Par défaut, quantité = 1 et remise = 0%
    edtQuantite.Value := 1;
    edtRemise.Value := 0;

    // Limiter la quantité au stock disponible
    edtQuantite.MaxValue := FProduitSelectionneStock;

    // Mettre à jour le bouton d'ajout
    actAjouterProduit.Enabled := (FProduitSelectionneID > 0) and (FProduitSelectionneStock > 0);
  end;
end;

procedure TfrmCommandeEdit.actAjouterProduitExecute(Sender: TObject);
var
  Quantite: Integer;
  Remise: Double;
  Reference, Designation: string;
begin
  if FProduitSelectionneID <= 0 then
  begin
    ShowMessage('Veuillez sélectionner un produit.');
    Exit;
  end;

  Quantite := Round(edtQuantite.Value);
  if Quantite <= 0 then
  begin
    ShowMessage('La quantité doit être supérieure à 0.');
    edtQuantite.SetFocus;
    Exit;
  end;

  if Quantite > FProduitSelectionneStock then
  begin
    ShowMessage('La quantité demandée dépasse le stock disponible.');
    edtQuantite.SetFocus;
    Exit;
  end;

  Remise := edtRemise.Value;
  if (Remise < 0) or (Remise > 100) then
  begin
    ShowMessage('La remise doit être comprise entre 0 et 100%.');
    edtRemise.SetFocus;
    Exit;
  end;

  // Récupérer les informations du produit
  Reference := StringGrid1.Cells[1, StringGrid1.Selection.Top];
  Designation := StringGrid1.Cells[2, StringGrid1.Selection.Top];

  // Ajouter la ligne à la grille des produits commandés
  AjouterLigne(FProduitSelectionneID, Reference, Designation, Quantite, FProduitSelectionnePrix, Remise);

  // Recalculer les totaux
  CalculerTotaux;

  // Message de confirmation
  ShowMessage('Produit ajouté au panier.');

  // Réinitialiser la sélection
  FProduitSelectionneID := 0;
  FProduitSelectionnePrix := 0;
  FProduitSelectionneStock := 0;
  lblProduitSelectionne.Caption := 'Aucun produit sélectionné';
  lblPrixUnitaire.Caption := 'Prix unitaire : 0,00 €';
  lblQuantiteStock.Caption := 'Stock disponible : 0';
  edtQuantite.Value := 1;
  edtRemise.Value := 0;
  actAjouterProduit.Enabled := False;
end;

procedure TfrmCommandeEdit.AjouterLigne(ProduitID: Integer; Reference, Designation: string;
  Quantite: Integer; PrixUnitaire, Remise: Double);
var
  Row: Integer;
  TotalHT: Double;
begin
  // Vérifier si le produit est déjà dans la commande
  for Row := 1 to StringGrid2.RowCount - 1 do
  begin
    if (StringGrid2.Cells[0, Row] <> '') and
       (StrToInt(StringGrid2.Cells[0, Row]) = ProduitID) then
    begin
      // Le produit existe déjà, on met à jour la quantité
      Quantite := Quantite + StrToInt(StringGrid2.Cells[3, Row]);
      ModifierLigne(Row, Quantite, Remise);
      Exit;
    end;
  end;

  // Trouver la première ligne vide
  Row := 1;
  while (Row < StringGrid2.RowCount) and (StringGrid2.Cells[0, Row] <> '') do
    Inc(Row);

  // Si nécessaire, ajouter une nouvelle ligne
  if Row = StringGrid2.RowCount then
    StringGrid2.RowCount := StringGrid2.RowCount + 1;

  // Calculer le total HT
  TotalHT := Quantite * PrixUnitaire * (1 - Remise / 100);

  // Remplir la ligne
  StringGrid2.Cells[0, Row] := IntToStr(ProduitID);
  StringGrid2.Cells[1, Row] := Reference;
  StringGrid2.Cells[2, Row] := Designation;
  StringGrid2.Cells[3, Row] := IntToStr(Quantite);
  StringGrid2.Cells[4, Row] := FormatFloat('#,##0.00 €', PrixUnitaire);
  StringGrid2.Cells[5, Row] := FormatFloat('#,##0.00 €', TotalHT);

  // Tag pour stocker la remise (non visible dans la grille)
  StringGrid2.Objects[3, Row] := TObject(Round(Remise * 100)); // Stocker en centièmes
end;

procedure TfrmCommandeEdit.ModifierLigne(ARow: Integer; Quantite: Integer; Remise: Double);
var
  PrixUnitaire, TotalHT: Double;
begin
  // Extraire le prix unitaire
  PrixUnitaire := StrToFloatDef(StringReplace(StringGrid2.Cells[4, ARow], ' €', '', []), 0);

  // Calculer le total HT
  TotalHT := Quantite * PrixUnitaire * (1 - Remise / 100);

  // Mettre à jour la ligne
  StringGrid2.Cells[3, ARow] := IntToStr(Quantite);
  StringGrid2.Cells[5, ARow] := FormatFloat('#,##0.00 €', TotalHT);

  // Stocker la remise
  StringGrid2.Objects[3, ARow] := TObject(Round(Remise * 100));
end;

procedure TfrmCommandeEdit.SupprimerLigne(ARow: Integer);
var
  i, j: Integer;
begin
  // Supprimer la ligne en décalant toutes les lignes suivantes
  for i := ARow to StringGrid2.RowCount - 2 do
    for j := 0 to StringGrid2.ColCount - 1 do
    begin
      StringGrid2.Cells[j, i] := StringGrid2.Cells[j, i + 1];
      if j = 3 then // Colonne avec l'objet pour la remise
        StringGrid2.Objects[j, i] := StringGrid2.Objects[j, i + 1];
    end;

  // Effacer la dernière ligne
  for j := 0 to StringGrid2.ColCount - 1 do
  begin
    StringGrid2.Cells[j, StringGrid2.RowCount - 1] := '';
    if j = 3 then
      StringGrid2.Objects[j, StringGrid2.RowCount - 1] := nil;
  end;

  // Si la grille ne contient plus qu'une ligne vide (en plus de l'en-tête), réduire le nombre de lignes
  if (StringGrid2.RowCount > 2) and (StringGrid2.Cells[0, StringGrid2.RowCount - 1] = '') and
     (StringGrid2.Cells[0, StringGrid2.RowCount - 2] = '') then
    StringGrid2.RowCount := StringGrid2.RowCount - 1;

  // Réinitialiser la ligne sélectionnée
  FLigneSelectionnee := 0;

  // Mettre à jour les boutons
  actModifierLigne.Enabled := False;
  actSupprimerLigne.Enabled := False;
end;

procedure TfrmCommandeEdit.CalculerTotaux;
var
  Row: Integer;
  TotalHT, TotalTVA, TotalTTC: Double;
begin
  TotalHT := 0;

  // Calculer le total HT à partir des lignes de commande
  for Row := 1 to StringGrid2.RowCount - 1 do
  begin
    if StringGrid2.Cells[0, Row] <> '' then
      TotalHT := TotalHT + StrToFloatDef(StringReplace(StringGrid2.Cells[5, Row], ' €', '', []), 0);
  end;

  // Ajouter les frais de port
  TotalHT := TotalHT + edtFraisPort.Value;

  // Calculer la TVA (supposons 20% pour simplifier)
  TotalTVA := TotalHT * 0.2;

  // Calculer le total TTC
  TotalTTC := TotalHT + TotalTVA;

  // Mettre à jour les labels
  lblTotalHT.Caption := 'Total HT : ' + FormatFloat('#,##0.00 €', TotalHT);
  lblTotalTVA.Caption := 'TVA : ' + FormatFloat('#,##0.00 €', TotalTVA);
  lblTotalTTC.Caption := 'Total TTC : ' + FormatFloat('#,##0.00 €', TotalTTC);

  // Stocker dans l'objet commande
  FCommande.MontantHT := TotalHT;
  FCommande.MontantTTC := TotalTTC;
  FCommande.FraisPort := edtFraisPort.Value;

  // Mettre à jour le reste à payer
  if edtAcompte.Value > 0 then
  begin
    var ResteAPayer := TotalTTC - edtAcompte.Value;
    lblTotalTTC.Caption := lblTotalTTC.Caption + ' (Reste à payer : ' +
      FormatFloat('#,##0.00 €', ResteAPayer) + ')';
  end;
end;

procedure TfrmCommandeEdit.StringGrid2SelectCell(Sender: TObject; ACol, ARow: Integer;
  var CanSelect: Boolean);
begin
  // Sélection d'une ligne dans la grille des produits commandés
  if (ARow > 0) and (ARow < StringGrid2.RowCount) and (StringGrid2.Cells[0, ARow] <> '') then
  begin
    FLigneSelectionnee := ARow;

    // Activer les boutons d'action
    actModifierLigne.Enabled := True;
    actSupprimerLigne.Enabled := True;
  end
  else
  begin
    FLigneSelectionnee := 0;

    // Désactiver les boutons d'action
    actModifierLigne.Enabled := False;
    actSupprimerLigne.Enabled := False;
  end;
end;

procedure TfrmCommandeEdit.actModifierLigneExecute(Sender: TObject);
var
  Quantite: Integer;
  Remise: Double;
  ProduitID: Integer;
begin
  if FLigneSelectionnee <= 0 then
    Exit;

  // Récupérer les valeurs actuelles
  ProduitID := StrToIntDef(StringGrid2.Cells[0, FLigneSelectionnee], 0);
  Quantite := StrToIntDef(StringGrid2.Cells[3, FLigneSelectionnee], 0);

  // La remise est stockée dans l'objet associé à la cellule
  Remise := Integer(StringGrid2.Objects[3, FLigneSelectionnee]) / 100;

  // Demander les nouvelles valeurs
  if InputQuery('Modifier la ligne', 'Nouvelle quantité :', Quantite) and
     InputQuery('Modifier la ligne', 'Nouvelle remise (%) :', Remise) then
  begin
    if Quantite <= 0 then
    begin
      ShowMessage('La quantité doit être supérieure à 0.');
      Exit;
    end;

    if (Remise < 0) or (Remise > 100) then
    begin
      ShowMessage('La remise doit être comprise entre 0 et 100%.');
      Exit;
    end;

    // Mettre à jour la ligne
    ModifierLigne(FLigneSelectionnee, Quantite, Remise);

    // Recalculer les totaux
    CalculerTotaux;
  end;
end;

procedure TfrmCommandeEdit.actSupprimerLigneExecute(Sender: TObject);
begin
  if FLigneSelectionnee <= 0 then
    Exit;

  if MessageDlg('Êtes-vous sûr de vouloir supprimer cette ligne ?',
    mtConfirmation, [mbYes, mbNo], 0) = mrYes then
  begin
    // Supprimer la ligne
    SupprimerLigne(FLigneSelectionnee);

    // Recalculer les totaux
    CalculerTotaux;
  end;
end;

procedure TfrmCommandeEdit.btnSuivant1Click(Sender: TObject);
begin
  // Valider les informations du premier onglet
  if Trim(edtReference.Text) = '' then
  begin
    ShowMessage('Veuillez saisir une référence pour la commande.');
    edtReference.SetFocus;
    Exit;
  end;

  if cboClient.KeyValue = null then
  begin
    ShowMessage('Veuillez sélectionner un client.');
    cboClient.SetFocus;
    Exit;
  end;

  if cboVendeur.KeyValue = null then
  begin
    ShowMessage('Veuillez sélectionner un vendeur.');
    cboVendeur.SetFocus;
    Exit;
  end;

  // Passer à l'onglet suivant
  PageControl1.ActivePageIndex := 1;
end;

procedure TfrmCommandeEdit.btnPrecedent2Click(Sender: TObject);
begin
  // Revenir à l'onglet précédent
  PageControl1.ActivePageIndex := 0;
end;

procedure TfrmCommandeEdit.btnSuivant2Click(Sender: TObject);
begin
  // Vérifier qu'il y a au moins une ligne de commande
  if (StringGrid2.RowCount <= 2) and (StringGrid2.Cells[0, 1] = '') then
  begin
    ShowMessage('Veuillez ajouter au moins un produit à la commande.');
    Exit;
  end;

  // Passer à l'onglet suivant
  PageControl1.ActivePageIndex := 2;

  // Recalculer les totaux
  CalculerTotaux;
end;

procedure TfrmCommandeEdit.actNouveauClientExecute(Sender: TObject);
var
  Form: TfrmClientEdit;
begin
  Form := TfrmClientEdit.Create(Self);
  try
    Form.InitAdd;
    if Form.ShowModal = mrOk then
    begin
      // Recharger la liste des clients
      LoadClients;

      // Sélectionner le nouveau client
      cboClient.KeyValue := Form.ClientID;
    end;
  finally
    Form.Free;
  end;
end;

procedure TfrmCommandeEdit.actCopierAdresseClientExecute(Sender: TObject);
var
  Query: TFDQuery;
  ClientID: Integer;
  Adresse: string;
begin
  if cboClient.KeyValue = null then
  begin
    ShowMessage('Veuillez d''abord sélectionner un client.');
    Exit;
  end;

  ClientID := Integer(cboClient.KeyValue);

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text :=
      'SELECT CONCAT(Nom, '' '', Prenom, CHAR(13), Adresse, CHAR(13), CodePostal, '' '', Ville) AS AdresseComplete ' +
      'FROM Clients WHERE ClientID = :ClientID';
    Query.ParamByName('ClientID').AsInteger := ClientID;
    Query.Open;

    if not Query.IsEmpty then
    begin
      Adresse := Query.FieldByName('AdresseComplete').AsString;
      memoAdresseLivraison.Text := Adresse;
    end;
  finally
    Query.Free;
  end;
end;

procedure TfrmCommandeEdit.edtQuantiteChange(Sender: TObject);
begin
  // Mettre à jour le bouton d'ajout
  actAjouterProduit.Enabled := (FProduitSelectionneID > 0) and (edtQuantite.Value > 0);
end;

procedure TfrmCommandeEdit.edtRemiseChange(Sender: TObject);
begin
  // S'assurer que la remise est entre 0 et 100%
  if edtRemise.Value < 0 then
    edtRemise.Value := 0
  else if edtRemise.Value > 100 then
    edtRemise.Value := 100;
end;

procedure TfrmCommandeEdit.edtFraisPortChange(Sender: TObject);
begin
  // Recalculer les totaux
  CalculerTotaux;
end;

procedure TfrmCommandeEdit.cboPaiementChange(Sender: TObject);
begin
  // Activer/désactiver le champ d'acompte selon le mode de paiement
  edtAcompte.Enabled := cboPaiement.ItemIndex > 0; // Tous sauf "Virement bancaire"

  if not edtAcompte.Enabled then
    edtAcompte.Value := 0;

  // Recalculer les totaux
  CalculerTotaux;
end;

procedure TfrmCommandeEdit.InitAdd;
begin
  FMode := 'Add';

  // Définir le titre
  lblTitre.Caption := 'Nouvelle commande';

  // Générer une référence automatique
  edtReference.Text := 'CMD-' + FormatDateTime('yyyymmdd-hhnn', Now);

  // Initialiser les valeurs par défaut
  dtpDateCommande.Date := Date;
  dtpDateLivraison.Date := Date + 7;
  cboStatut.ItemIndex := 0; // En attente
  memoAdresseLivraison.Clear;

  // Réinitialiser la grille des produits
  StringGrid2.RowCount := 2;
  StringGrid2.Cells[0, 1] := '';
  StringGrid2.Cells[1, 1] := '';
  StringGrid2.Cells[2, 1] := '';
  StringGrid2.Cells[3, 1] := '';
  StringGrid2.Cells[4, 1] := '';
  StringGrid2.Cells[5, 1] := '';

  // Réinitialiser les totaux
  edtFraisPort.Value := 0;
  edtAcompte.Value := 0;
  memoCommentaires.Clear;

  CalculerTotaux;
end;

procedure TfrmCommandeEdit.InitEdit(ACommandeID: Integer);
begin
  FMode := 'Edit';

  // Récupérer la commande
  FCommande.Free;
  FCommande := DataModuleBusiness.CommandeRepository.ObtenirParID(ACommandeID);

  if FCommande = nil then
  begin
    ShowMessage('Commande non trouvée !');
    FCommande := TCommande.Create;
    Close;
    Exit;
  end;

  // Définir le titre
  lblTitre.Caption := 'Modifier la commande ' + FCommande.Reference;

  // Charger les informations de la commande
  LoadCommande;
end;

procedure TfrmCommandeEdit.LoadCommande;
var
  Query: TFDQuery;
  Row: Integer;
begin
  // Remplir les champs avec les informations de la commande
  edtReference.Text := FCommande.Reference;
  cboClient.KeyValue := FCommande.ClientID;
  dtpDateCommande.Date := FCommande.DateCommande;
  dtpDateLivraison.Date := FCommande.DateLivraison;

  // Trouver l'index du statut
  for Row := 0 to cboStatut.Items.Count - 1 do
  begin
    if cboStatut.Items[Row] = FCommande.Statut then
    begin
      cboStatut.ItemIndex := Row;
      Break;
    end;
  end;

  cboVendeur.KeyValue := FCommande.UtilisateurID;
  memoAdresseLivraison.Text := FCommande.AdresseLivraison;

  // Trouver l'index du mode de paiement
  for Row := 0 to cboPaiement.Items.Count - 1 do
  begin
    if cboPaiement.Items[Row] = FCommande.ModePaiement then
    begin
      cboPaiement.ItemIndex := Row;
      Break;
    end;
  end;

  edtFraisPort.Value := FCommande.FraisPort;
  memoCommentaires.Text := FCommande.Commentaires;

  // Charger les lignes de commande
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text :=
      'SELECT l.*, p.Reference, p.Designation ' +
      'FROM LignesCommande l ' +
      'JOIN Produits p ON l.ProduitID = p.ProduitID ' +
      'WHERE l.CommandeID = :CommandeID ' +
      'ORDER BY l.LigneID';
    Query.ParamByName('CommandeID').AsInteger := FCommande.CommandeID;
    Query.Open;

    // Réinitialiser la grille
    StringGrid2.RowCount := 2;
    for Row := 0 to StringGrid2.ColCount - 1 do
      StringGrid2.Cells[Row, 1] := '';

    // Remplir la grille avec les lignes de commande
    Row := 1;
    while not Query.Eof do
    begin
      if Row >= StringGrid2.RowCount then
        StringGrid2.RowCount := StringGrid2.RowCount + 1;

      StringGrid2.Cells[0, Row] := Query.FieldByName('ProduitID').AsString;
      StringGrid2.Cells[1, Row] := Query.FieldByName('Reference').AsString;
      StringGrid2.Cells[2, Row] := Query.FieldByName('Designation').AsString;
      StringGrid2.Cells[3, Row] := Query.FieldByName('Quantite').AsString;
      StringGrid2.Cells[4, Row] := FormatFloat('#,##0.00 €', Query.FieldByName('PrixUnitaire').AsFloat);

      // Calculer le total HT de la ligne
      var Quantite: Integer := Query.FieldByName('Quantite').AsInteger;
      var PrixUnitaire: Double := Query.FieldByName('PrixUnitaire').AsFloat;
      var Remise: Double := Query.FieldByName('Remise').AsFloat;
      var TotalHT: Double := Quantite * PrixUnitaire * (1 - Remise / 100);

      StringGrid2.Cells[5, Row] := FormatFloat('#,##0.00 €', TotalHT);

      // Stocker la remise
      StringGrid2.Objects[3, Row] := TObject(Round(Remise * 100));

      Inc(Row);
      Query.Next;
    end;
  finally
    Query.Free;
  end;

  // Calculer les totaux
  CalculerTotaux;
end;

procedure TfrmCommandeEdit.SaveCommande;
var
  Query: TFDQuery;
  Row: Integer;
  CommandeID: Integer;
begin
  // Mettre à jour les propriétés de la commande
  FCommande.Reference := edtReference.Text;
  FCommande.ClientID := Integer(cboClient.KeyValue);
  FCommande.DateCommande := dtpDateCommande.Date;
  FCommande.DateLivraison := dtpDateLivraison.Date;
  FCommande.Statut := cboStatut.Text;
  FCommande.UtilisateurID := Integer(cboVendeur.KeyValue);
  FCommande.AdresseLivraison := memoAdresseLivraison.Text;
  FCommande.ModePaiement := cboPaiement.Text;
  FCommande.FraisPort := edtFraisPort.Value;
  FCommande.Commentaires := memoCommentaires.Text;

  // Recalculer les totaux pour s'assurer qu'ils sont à jour
  CalculerTotaux;

  try
    // Démarrer une transaction
    DataModuleDB.FDTransaction.StartTransaction;

    try
      // Enregistrer l'en-tête de la commande
      if FMode = 'Add' then
      begin
        // Insérer une nouvelle commande
        Query := TFDQuery.Create(nil);
        try
          Query.Connection := DataModuleDB.FDConnection;
          Query.SQL.Text :=
            'INSERT INTO Commandes (Reference, ClientID, DateCommande, DateLivraison, ' +
            'Statut, MontantHT, MontantTTC, FraisPort, AdresseLivraison, UtilisateurID, ' +
            'ModePaiement, Commentaires) ' +
            'VALUES (:Reference, :ClientID, :DateCommande, :DateLivraison, ' +
            ':Statut, :MontantHT, :MontantTTC, :FraisPort, :AdresseLivraison, :UtilisateurID, ' +
            ':ModePaiement, :Commentaires)';

          Query.ParamByName('Reference').AsString := FCommande.Reference;
          Query.ParamByName('ClientID').AsInteger := FCommande.ClientID;
          Query.ParamByName('DateCommande').AsDate := FCommande.DateCommande;
          Query.ParamByName('DateLivraison').AsDate := FCommande.DateLivraison;
          Query.ParamByName('Statut').AsString := FCommande.Statut;
          Query.ParamByName('MontantHT').AsFloat := FCommande.MontantHT;
          Query.ParamByName('MontantTTC').AsFloat := FCommande.MontantTTC;
          Query.ParamByName('FraisPort').AsFloat := FCommande.FraisPort;
          Query.ParamByName('AdresseLivraison').AsString := FCommande.AdresseLivraison;
          Query.ParamByName('UtilisateurID').AsInteger := FCommande.UtilisateurID;
          Query.ParamByName('ModePaiement').AsString := FCommande.ModePaiement;
          Query.ParamByName('Commentaires').AsString := FCommande.Commentaires;

          Query.ExecSQL;

          // Récupérer l'ID de la commande créée
          CommandeID := DataModuleDB.FDConnection.GetLastAutoGenValue('CommandeID');
          FCommande.CommandeID := CommandeID;
        finally
          Query.Free;
        end;
      end
      else
      begin
        // Mettre à jour une commande existante
        Query := TFDQuery.Create(nil);
        try
          Query.Connection := DataModuleDB.FDConnection;
          Query.SQL.Text :=
            'UPDATE Commandes SET ' +
            'Reference = :Reference, ' +
            'ClientID = :ClientID, ' +
            'DateCommande = :DateCommande, ' +
            'DateLivraison = :DateLivraison, ' +
            'Statut = :Statut, ' +
            'MontantHT = :MontantHT, ' +
            'MontantTTC = :MontantTTC, ' +
            'FraisPort = :FraisPort, ' +
            'AdresseLivraison = :AdresseLivraison, ' +
            'UtilisateurID = :UtilisateurID, ' +
            'ModePaiement = :ModePaiement, ' +
            'Commentaires = :Commentaires ' +
            'WHERE CommandeID = :CommandeID';

          Query.ParamByName('Reference').AsString := FCommande.Reference;
          Query.ParamByName('ClientID').AsInteger := FCommande.ClientID;
          Query.ParamByName('DateCommande').AsDate := FCommande.DateCommande;
          Query.ParamByName('DateLivraison').AsDate := FCommande.DateLivraison;
          Query.ParamByName('Statut').AsString := FCommande.Statut;
          Query.ParamByName('MontantHT').AsFloat := FCommande.MontantHT;
          Query.ParamByName('MontantTTC').AsFloat := FCommande.MontantTTC;
          Query.ParamByName('FraisPort').AsFloat := FCommande.FraisPort;
          Query.ParamByName('AdresseLivraison').AsString := FCommande.AdresseLivraison;
          Query.ParamByName('UtilisateurID').AsInteger := FCommande.UtilisateurID;
          Query.ParamByName('ModePaiement').AsString := FCommande.ModePaiement;
          Query.ParamByName('Commentaires').AsString := FCommande.Commentaires;
          Query.ParamByName('CommandeID').AsInteger := FCommande.CommandeID;

          Query.ExecSQL;

          CommandeID := FCommande.CommandeID;

          // Supprimer les anciennes lignes de commande
          Query.SQL.Text := 'DELETE FROM LignesCommande WHERE CommandeID = :CommandeID';
          Query.ParamByName('CommandeID').AsInteger := CommandeID;
          Query.ExecSQL;
        finally
          Query.Free;
        end;
      end;

      // Insérer les lignes de commande
      Query := TFDQuery.Create(nil);
      try
        Query.Connection := DataModuleDB.FDConnection;
        Query.SQL.Text :=
          'INSERT INTO LignesCommande (CommandeID, ProduitID, Quantite, PrixUnitaire, Remise) ' +
          'VALUES (:CommandeID, :ProduitID, :Quantite, :PrixUnitaire, :Remise)';

        for Row := 1 to StringGrid2.RowCount - 1 do
        begin
          if StringGrid2.Cells[0, Row] = '' then
            Continue;

          var ProduitID: Integer := StrToInt(StringGrid2.Cells[0, Row]);
          var Quantite: Integer := StrToInt(StringGrid2.Cells[3, Row]);
          var PrixUnitaire: Double := StrToFloatDef(StringReplace(StringGrid2.Cells[4, Row], ' €', '', []), 0);
          var Remise: Double := Integer(StringGrid2.Objects[3, Row]) / 100;

          Query.ParamByName('CommandeID').AsInteger := CommandeID;
          Query.ParamByName('ProduitID').AsInteger := ProduitID;
          Query.ParamByName('Quantite').AsInteger := Quantite;
          Query.ParamByName('PrixUnitaire').AsFloat := PrixUnitaire;
          Query.ParamByName('Remise').AsFloat := Remise;

          Query.ExecSQL;
        end;
      finally
        Query.Free;
      end;

      // Valider la transaction
      DataModuleDB.FDTransaction.Commit;

      ModalResult := mrOk;
    except
      on E: Exception do
      begin
        // Annuler la transaction en cas d'erreur
        DataModuleDB.FDTransaction.Rollback;
        ShowMessage('Erreur lors de l''enregistrement de la commande : ' + E.Message);
      end;
    end;
  except
    on E: Exception do
      ShowMessage('Erreur de transaction : ' + E.Message);
  end;
end;

function TfrmCommandeEdit.VerifierFormulaire: Boolean;
begin
  Result := False;

  // Vérifier les informations de base
  if Trim(edtReference.Text) = '' then
  begin
    ShowMessage('Veuillez saisir une référence pour la commande.');
    PageControl1.ActivePageIndex := 0;
    edtReference.SetFocus;
    Exit;
  end;

  if cboClient.KeyValue = null then
  begin
    ShowMessage('Veuillez sélectionner un client.');
    PageControl1.ActivePageIndex := 0;
    cboClient.SetFocus;
    Exit;
  end;

  if cboVendeur.KeyValue = null then
  begin
    ShowMessage('Veuillez sélectionner un vendeur.');
    PageControl1.ActivePageIndex := 0;
    cboVendeur.SetFocus;
    Exit;
  end;

  // Vérifier qu'il y a au moins une ligne de commande
  if (StringGrid2.RowCount <= 2) and (StringGrid2.Cells[0, 1] = '') then
  begin
    ShowMessage('Veuillez ajouter au moins un produit à la commande.');
    PageControl1.ActivePageIndex := 1;
    Exit;
  end;

  // Vérifier l'adresse de livraison
  if Trim(memoAdresseLivraison.Text) = '' then
  begin
    ShowMessage('Veuillez saisir une adresse de livraison.');
    PageControl1.ActivePageIndex := 0;
    memoAdresseLivraison.SetFocus;
    Exit;
  end;

  Result := True;
end;

procedure TfrmCommandeEdit.actEnregistrerExecute(Sender: TObject);
begin
  if not VerifierFormulaire then
    Exit;

  SaveCommande;
end;

procedure TfrmCommandeEdit.actAnnulerExecute(Sender: TObject);
begin
  // Demander confirmation si des modifications ont été apportées
  if (StringGrid2.RowCount > 2) or (StringGrid2.Cells[0, 1] <> '') then
  begin
    if MessageDlg('Annuler les modifications ?', mtConfirmation, [mbYes, mbNo], 0) = mrYes then
      ModalResult := mrCancel;
  end
  else
    ModalResult := mrCancel;
end;
```

## Améliorations visuelles pour une interface moderne

Pour finaliser notre interface utilisateur évoluée, ajoutons quelques améliorations visuelles qui rendront notre application plus attrayante et professionnelle :

### 1. Utilisation de thèmes visuels

Delphi inclut un système de thèmes visuels qui peut transformer l'apparence de l'application. Pour implémenter un sélecteur de thèmes, créez un nouveau menu dans le formulaire principal :

```pascal
procedure TfrmMain.InitializeThemes;
var
  StyleName: string;
  MenuItem: TMenuItem;
begin
  // Vider le menu existant
  mnuThemes.Clear;

  // Ajouter un élément par style disponible
  for StyleName in TStyleManager.StyleNames do
  begin
    MenuItem := TMenuItem.Create(mnuThemes);
    MenuItem.Caption := StyleName;
    MenuItem.OnClick := ThemeMenuItemClick;
    MenuItem.RadioItem := True;
    MenuItem.GroupIndex := 1;
    MenuItem.Checked := TStyleManager.ActiveStyle.Name = StyleName;
    mnuThemes.Add(MenuItem);
  end;
end;

procedure TfrmMain.ThemeMenuItemClick(Sender: TObject);
begin
  if Sender is TMenuItem then
  begin
    TStyleManager.TrySetStyle(TMenuItem(Sender).Caption);

    // Mettre à jour les coches dans le menu
    UpdateThemeMenu;

    // Sauvegarder le thème choisi dans les paramètres
    SaveSettings;
  end;
end;

procedure TfrmMain.UpdateThemeMenu;
var
  i: Integer;
begin
  for i := 0 to mnuThemes.Count - 1 do
    mnuThemes.Items[i].Checked := mnuThemes.Items[i].Caption = TStyleManager.ActiveStyle.Name;
end;
```

### 2. Ajout d'icônes et d'images

Utilisez des icônes modernes pour améliorer la lisibilité :

```pascal
procedure TfrmMain.LoadIcons;
begin
  // Chargement des icônes pour la barre d'outils
  ImageList1.Clear;

  // Ajouter les icônes à l'ImageList
  AddIconToImageList('client.png', ImageList1);
  AddIconToImageList('product.png', ImageList1);
  AddIconToImageList('order.png', ImageList1);
  AddIconToImageList('supplier.png', ImageList1);
  AddIconToImageList('category.png', ImageList1);
  AddIconToImageList('report.png', ImageList1);
  AddIconToImageList('settings.png', ImageList1);
  AddIconToImageList('exit.png', ImageList1);
end;

procedure TfrmMain.AddIconToImageList(const FileName: string; ImageList: TImageList);
var
  Bitmap: TBitmap;
  ResourcePath: string;
begin
  ResourcePath := ExtractFilePath(Application.ExeName) + 'Resources\Icons\' + FileName;

  if FileExists(ResourcePath) then
  begin
    Bitmap := TBitmap.Create;
    try
      Bitmap.LoadFromFile(ResourcePath);
      ImageList.Add(Bitmap, nil);
    finally
      Bitmap.Free;
    end;
  end;
end;
```

### 3. Utilisation d'animations et de transitions

Ajoutez des animations subtiles pour améliorer l'expérience utilisateur :

```pascal
// Unité avec classes d'animation
unit Animations;

interface

uses
  System.SysUtils, System.Classes, Vcl.Forms, Vcl.Controls,
  System.Math, Winapi.Windows, Winapi.Messages;

type
  TAnimationType = (atFadeIn, atFadeOut, atSlideLeft, atSlideRight);

  TFormAnimation = class
  private
    FForm: TForm;
    FTimer: TTimer;
    FAnimationType: TAnimationType;
    FStep: Integer;
    FMaxSteps: Integer;
    FOnFinish: TNotifyEvent;

    procedure TimerTick(Sender: TObject);
  public
    constructor Create(AForm: TForm);
    destructor Destroy; override;

    procedure StartAnimation(AType: TAnimationType; ASteps: Integer = 10);
    property OnFinish: TNotifyEvent read FOnFinish write FOnFinish;
  end;

implementation

constructor TFormAnimation.Create(AForm: TForm);
begin
  inherited Create;
  FForm := AForm;
  FTimer := TTimer.Create(nil);
  FTimer.Enabled := False;
  FTimer.Interval := 15; // ~60fps
  FTimer.OnTimer := TimerTick;
  FStep := 0;
  FMaxSteps := 10;
end;

destructor TFormAnimation.Destroy;
begin
  FTimer.Free;
  inherited;
end;

procedure TFormAnimation.StartAnimation(AType: TAnimationType; ASteps: Integer = 10);
begin
  FAnimationType := AType;
  FMaxSteps := ASteps;
  FStep := 0;

  case FAnimationType of
    atFadeIn:
      begin
        FForm.AlphaBlend := True;
        FForm.AlphaBlendValue := 0;
      end;
    atFadeOut:
      begin
        FForm.AlphaBlend := True;
        FForm.AlphaBlendValue := 255;
      end;
    atSlideLeft, atSlideRight:
      begin
        // Aucune préparation nécessaire
      end;
  end;

  FTimer.Enabled := True;
end;

procedure TFormAnimation.TimerTick(Sender: TObject);
var
  Alpha: Byte;
  NewLeft: Integer;
begin
  Inc(FStep);

  if FStep > FMaxSteps then
  begin
    FTimer.Enabled := False;

    // Finaliser l'animation
    case FAnimationType of
      atFadeIn:
        begin
          FForm.AlphaBlend := False;
        end;
      atFadeOut:
        begin
          if Assigned(FOnFinish) then
            FOnFinish(Self);
        end;
      atSlideLeft, atSlideRight:
        begin
          // Aucune finalisation nécessaire
        end;
    end;

    Exit;
  end;

  // Calculer les valeurs intermédiaires
  case FAnimationType of
    atFadeIn:
      begin
        Alpha := Round(255 * (FStep / FMaxSteps));
        FForm.AlphaBlendValue := Alpha;
      end;
    atFadeOut:
      begin
        Alpha := Round(255 * (1 - FStep / FMaxSteps));
        FForm.AlphaBlendValue := Alpha;
      end;
    atSlideLeft:
      begin
        NewLeft := Round(FForm.Width * (1 - FStep / FMaxSteps));
        FForm.Left := FForm.Left - NewLeft div FMaxSteps;
      end;
    atSlideRight:
      begin
        NewLeft := Round(FForm.Width * (FStep / FMaxSteps));
        FForm.Left := FForm.Left + NewLeft div FMaxSteps;
      end;
  end;
end;

end.

// Utilisation dans un formulaire
procedure TfrmMain.ShowTabWithAnimation(AClass: TFormClass; const ATitle: string);
var
  Form: TForm;
  Animation: TFormAnimation;
begin
  // Créer le formulaire
  Form := AClass.Create(Self);
  Form.Parent := TabSheet2;
  Form.BorderStyle := bsNone;
  Form.Align := alClient;

  // Préparer l'animation
  Animation := TFormAnimation.Create(Form);
  try
    // Configurer et démarrer l'animation
    Animation.StartAnimation(atFadeIn, 15);

    // Afficher le formulaire
    Form.Show;

    // Mettre à jour les onglets
    TabSheet2.Caption := ATitle;
    TabSheet2.TabVisible := True;
    PageControl1.ActivePage := TabSheet2;
    TabSheet2.Tag := NativeInt(Form);
  finally
    Animation.Free;
  end;
end;
```

### 4. Créer des contrôles personnalisés

Pour un aspect unique, créez des contrôles personnalisés adaptés à votre application :

```pascal
// Unité de bouton personnalisé avec effet de survol
unit CustomButton;

interface

uses
  System.SysUtils, System.Classes, Vcl.Controls, Vcl.Graphics,
  Winapi.Windows, Winapi.Messages, Vcl.ExtCtrls, Vcl.Imaging.pngimage;

type
  TButtonState = (bsNormal, bsHover, bsDown);

  TCustomButton = class(TCustomControl)
  private
    FCaption: string;
    FNormalColor: TColor;
    FHoverColor: TColor;
    FDownColor: TColor;
    FTextColor: TColor;
    FButtonState: TButtonState;
    FOnClick: TNotifyEvent;
    FImage: TPicture;
    FImageAlignment: TAlignment;

    procedure SetCaption(const Value: string);
    procedure SetNormalColor(const Value: TColor);
    procedure SetHoverColor(const Value: TColor);
    procedure SetDownColor(const Value: TColor);
    procedure SetTextColor(const Value: TColor);
    procedure SetImage(const Value: TPicture);
    procedure SetImageAlignment(const Value: TAlignment);

    procedure CMMouseEnter(var Message: TMessage); message CM_MOUSEENTER;
    procedure CMMouseLeave(var Message: TMessage); message CM_MOUSELEAVE;
  protected
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure Click; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Caption: string read FCaption write SetCaption;
    property NormalColor: TColor read FNormalColor write SetNormalColor;
    property HoverColor: TColor read FHoverColor write SetHoverColor;
    property DownColor: TColor read FDownColor write SetDownColor;
    property TextColor: TColor read FTextColor write SetTextColor;
    property Image: TPicture read FImage write SetImage;
    property ImageAlignment: TAlignment read FImageAlignment write SetImageAlignment;
    property OnClick: TNotifyEvent read FOnClick write FOnClick;
    property Align;
    property Anchors;
    property Cursor;
    property Enabled;
    property Font;
    property ParentFont;
    property ParentShowHint;
    property PopupMenu;
    property ShowHint;
    property TabOrder;
    property TabStop;
    property Visible;
  end;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('Customs', [TCustomButton]);
end;

constructor TCustomButton.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 120;
  Height := 40;
  FCaption := 'Custom Button';
  FNormalColor := $00D1B499; // Couleur de base
  FHoverColor := $00E5C9B3;  // Couleur au survol
  FDownColor := $00BDA185;   // Couleur lorsque pressé
  FTextColor := clWhite;
  FButtonState := bsNormal;
  FImage := TPicture.Create;
  FImageAlignment := taLeftJustify;

  // Style de curseur pour indiquer que c'est un bouton
  Cursor := crHandPoint;
end;

destructor TCustomButton.Destroy;
begin
  FImage.Free;
  inherited;
end;

procedure TCustomButton.SetCaption(const Value: string);
begin
  if FCaption <> Value then
  begin
    FCaption := Value;
    Invalidate; // Redessiner le contrôle
  end;
end;

procedure TCustomButton.SetNormalColor(const Value: TColor);
begin
  if FNormalColor <> Value then
  begin
    FNormalColor := Value;
    Invalidate;
  end;
end;

procedure TCustomButton.SetHoverColor(const Value: TColor);
begin
  if FHoverColor <> Value then
  begin
    FHoverColor := Value;
    Invalidate;
  end;
end;

procedure TCustomButton.SetDownColor(const Value: TColor);
begin
  if FDownColor <> Value then
  begin
    FDownColor := Value;
    Invalidate;
  end;
end;

procedure TCustomButton.SetTextColor(const Value: TColor);
begin
  if FTextColor <> Value then
  begin
    FTextColor := Value;
    Invalidate;
  end;
end;

procedure TCustomButton.SetImage(const Value: TPicture);
begin
  FImage.Assign(Value);
  Invalidate;
end;

procedure TCustomButton.SetImageAlignment(const Value: TAlignment);
begin
  if FImageAlignment <> Value then
  begin
    FImageAlignment := Value;
    Invalidate;
  end;
end;

procedure TCustomButton.CMMouseEnter(var Message: TMessage);
begin
  FButtonState := bsHover;
  Invalidate;
end;

procedure TCustomButton.CMMouseLeave(var Message: TMessage);
begin
  FButtonState := bsNormal;
  Invalidate;
end;

procedure TCustomButton.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  inherited;
  if Button = mbLeft then
  begin
    FButtonState := bsDown;
    Invalidate;
  end;
end;

procedure TCustomButton.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  InsideControl: Boolean;
begin
  inherited;
  if Button = mbLeft then
  begin
    InsideControl := PtInRect(ClientRect, Point(X, Y));
    if InsideControl then
    begin
      FButtonState := bsHover;
      Click;
    end
    else
      FButtonState := bsNormal;
    Invalidate;
  end;
end;

procedure TCustomButton.Click;
begin
  inherited;
  if Assigned(FOnClick) then
    FOnClick(Self);
end;

procedure TCustomButton.Paint;
var
  R: TRect;
  TextR: TRect;
  ButtonColor: TColor;
  TextFormat: UINT;
  ImgLeft, ImgTop: Integer;
begin
  // Déterminer la couleur du bouton selon l'état
  case FButtonState of
    bsNormal: ButtonColor := FNormalColor;
    bsHover: ButtonColor := FHoverColor;
    bsDown: ButtonColor := FDownColor;
  end;

  // Dessiner le fond du bouton
  R := ClientRect;
  Canvas.Brush.Color := ButtonColor;
  Canvas.Pen.Color := ButtonColor;
  Canvas.Rectangle(R);

  // Dessiner l'image si présente
  if Assigned(FImage.Graphic) and not FImage.Graphic.Empty then
  begin
    ImgTop := (Height - FImage.Height) div 2;

    case FImageAlignment of
      taLeftJustify: ImgLeft := 5;
      taCenter: ImgLeft := (Width - FImage.Width) div 2;
      taRightJustify: ImgLeft := Width - FImage.Width - 5;
    end;

    Canvas.Draw(ImgLeft, ImgTop, FImage.Graphic);

    // Ajuster le rectangle pour le texte
    if FImageAlignment = taLeftJustify then
      R.Left := ImgLeft + FImage.Width + 5
    else if FImageAlignment = taRightJustify then
      R.Right := ImgLeft - 5;
  end;

  // Dessiner le texte
  Canvas.Font := Font;
  Canvas.Font.Color := FTextColor;
  TextR := R;
  TextFormat := DT_CENTER or DT_VCENTER or DT_SINGLELINE;
  DrawText(Canvas.Handle, PChar(FCaption), Length(FCaption), TextR, TextFormat);
end;

end.
```

### 5. Adaptation aux différentes résolutions d'écran

L'application doit s'adapter correctement aux différentes résolutions d'écran :

```pascal
procedure TfrmMain.FormCreate(Sender: TObject);
begin
  // Régler la position et la taille du formulaire
  AdjustFormForScreen;

  // Reste du code...
end;

procedure TfrmMain.AdjustFormForScreen;
const
  DESIGN_WIDTH = 1024;
  DESIGN_HEIGHT = 768;
var
  Scale: Double;
  NewWidth, NewHeight: Integer;
begin
  // Déterminer le facteur d'échelle en fonction de la résolution de l'écran
  Scale := Min(Screen.Width / DESIGN_WIDTH, Screen.Height / DESIGN_HEIGHT);

  // Éviter une mise à l'échelle excessive
  if Scale > 1.5 then
    Scale := 1.5
  else if Scale < 0.8 then
    Scale := 0.8;

  // Calculer les nouvelles dimensions
  NewWidth := Round(DESIGN_WIDTH * Scale);
  NewHeight := Round(DESIGN_HEIGHT * Scale);

  // Appliquer les dimensions
  Width := NewWidth;
  Height := NewHeight;

  // Centrer sur l'écran
  Left := (Screen.Width - Width) div 2;
  Top := (Screen.Height - Height) div 2;

  // Si l'écran est plus petit que le minimum, utiliser WindowState wsMaximized
  if (Screen.Width < 800) or (Screen.Height < 600) then
    WindowState := wsMaximized;
end;
```

### 6. Support haute résolution et écrans HiDPI

Pour que l'application s'affiche correctement sur les écrans haute résolution modernes :

```pascal
// Dans le fichier .dpr
{$R *.res}

{$SetPEFlags IMAGE_FILE_LARGE_ADDRESS_AWARE}
{$SetPEFlags IMAGE_FILE_DLL_SUPPORTS_VA_ALLOCATION}

// Déclaration d'application compatible DPI
{$R 'app.manifest'}

// Contenu typique de app.manifest :
// <application xmlns="urn:schemas-microsoft-com:asm.v3">
//   <windowsSettings>
//     <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true/pm</dpiAware>
//     <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
//   </windowsSettings>
// </application>

// Dans le code principal
procedure TApplication.Initialize;
begin
  inherited;
  Application.MainFormOnTaskbar := True;
  Application.ScalingMode := TScalingMode.smDPI;
  Application.ScalingPixelsMode := TScalingPixelsMode.spmNone;
  Application.ScaleForPPI(Screen.PixelsPerInch);
end;
```

## Gestion des paramètres utilisateur

Pour personnaliser l'interface, implémentons un système de stockage des préférences :

```pascal
unit SettingsManager;

interface

uses
  System.SysUtils, System.Classes, System.IniFiles, Vcl.Forms;

type
  TAppSettings = class
  private
    FIniFile: TIniFile;
    FThemeName: string;
    FSidebarVisible: Boolean;
    FStartMaximized: Boolean;

    procedure SetThemeName(const Value: string);
    procedure SetSidebarVisible(const Value: Boolean);
    procedure SetStartMaximized(const Value: Boolean);
  public
    constructor Create;
    destructor Destroy; override;

    procedure Load;
    procedure Save;

    property ThemeName: string read FThemeName write SetThemeName;
    property SidebarVisible: Boolean read FSidebarVisible write SetSidebarVisible;
    property StartMaximized: Boolean read FStartMaximized write SetStartMaximized;
  end;

var
  AppSettings: TAppSettings;

implementation

constructor TAppSettings.Create;
var
  SettingsPath: string;
begin
  inherited Create;

  // Créer le dossier des paramètres s'il n'existe pas
  SettingsPath := ExtractFilePath(Application.ExeName) + 'Settings';
  if not DirectoryExists(SettingsPath) then
    ForceDirectories(SettingsPath);

  // Créer le fichier INI
  FIniFile := TIniFile.Create(SettingsPath + '\settings.ini');

  // Charger les paramètres
  Load;
end;

destructor TAppSettings.Destroy;
begin
  Save;
  FIniFile.Free;
  inherited;
end;

procedure TAppSettings.Load;
begin
  // Interface
  FThemeName := FIniFile.ReadString('Interface', 'Theme', 'Windows');
  FSidebarVisible := FIniFile.ReadBool('Interface', 'SidebarVisible', True);
  FStartMaximized := FIniFile.ReadBool('Interface', 'StartMaximized', False);
end;

procedure TAppSettings.Save;
begin
  // Interface
  FIniFile.WriteString('Interface', 'Theme', FThemeName);
  FIniFile.WriteBool('Interface', 'SidebarVisible', FSidebarVisible);
  FIniFile.WriteBool('Interface', 'StartMaximized', FStartMaximized);

  // Forcer l'écriture sur le disque
  FIniFile.UpdateFile;
end;

procedure TAppSettings.SetThemeName(const Value: string);
begin
  if FThemeName <> Value then
  begin
    FThemeName := Value;
    Save;
  end;
end;

procedure TAppSettings.SetSidebarVisible(const Value: Boolean);
begin
  if FSidebarVisible <> Value then
  begin
    FSidebarVisible := Value;
    Save;
  end;
end;

procedure TAppSettings.SetStartMaximized(const Value: Boolean);
begin
  if FStartMaximized <> Value then
  begin
    FStartMaximized := Value;
    Save;
  end;
end;

initialization
  AppSettings := TAppSettings.Create;

finalization
  AppSettings.Free;

end.
```

## Création d'une barre de notifications

Pour informer l'utilisateur des événements importants, ajoutons une barre de notifications :

```pascal
unit NotificationBar;

interface

uses
  System.SysUtils, System.Classes, Vcl.Controls, Vcl.Graphics,
  Winapi.Windows, Winapi.Messages, Vcl.ExtCtrls, Vcl.StdCtrls;

type
  TNotificationType = (ntInfo, ntWarning, ntError, ntSuccess);

  TNotificationBar = class(TPanel)
  private
    FLabel: TLabel;
    FCloseButton: TButton;
    FTimer: TTimer;
    FNotificationType: TNotificationType;
    FAutoHide: Boolean;
    FDisplayTime: Integer;

    procedure SetNotificationType(const Value: TNotificationType);
    procedure SetAutoHide(const Value: Boolean);
    procedure SetDisplayTime(const Value: Integer);
    procedure CloseButtonClick(Sender: TObject);
    procedure TimerTick(Sender: TObject);
  protected
    procedure Loaded; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure ShowNotification(const AMessage: string; AType: TNotificationType = ntInfo);
    procedure HideNotification;
  published
    property NotificationType: TNotificationType read FNotificationType write SetNotificationType;
    property AutoHide: Boolean read FAutoHide write SetAutoHide;
    property DisplayTime: Integer read FDisplayTime write SetDisplayTime;
  end;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('Customs', [TNotificationBar]);
end;

constructor TNotificationBar.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);

  // Configuration du panel
  Align := alTop;
  Height := 40;
  BevelOuter := bvNone;
  Caption := '';
  Visible := False;

  // Création du label
  FLabel := TLabel.Create(Self);
  FLabel.Parent := Self;
  FLabel.Align := alClient;
  FLabel.Alignment := taCenter;
  FLabel.Layout := tlCenter;
  FLabel.AutoSize := False;
  FLabel.Transparent := True;
  FLabel.Font.Style := [fsBold];

  // Création du bouton de fermeture
  FCloseButton := TButton.Create(Self);
  FCloseButton.Parent := Self;
  FCloseButton.Align := alRight;
  FCloseButton.Width := 40;
  FCloseButton.Caption := 'X';
  FCloseButton.OnClick := CloseButtonClick;

  // Création du timer
  FTimer := TTimer.Create(Self);
  FTimer.Enabled := False;
  FTimer.Interval := 5000; // 5 secondes par défaut
  FTimer.OnTimer := TimerTick;

  // Valeurs par défaut
  FNotificationType := ntInfo;
  FAutoHide := True;
  FDisplayTime := 5000;

  // Appliquer le style initial
  SetNotificationType(FNotificationType);
end;

destructor TNotificationBar.Destroy;
begin
  FTimer.Free;
  inherited;
end;

procedure TNotificationBar.Loaded;
begin
  inherited;
  // Configuration après chargement des propriétés
  SetNotificationType(FNotificationType);
end;

procedure TNotificationBar.SetNotificationType(const Value: TNotificationType);
begin
  FNotificationType := Value;

  // Définir les couleurs selon le type
  case FNotificationType of
    ntInfo:
      begin
        Color := $00D8F0FF; // Bleu clair
        FLabel.Font.Color := $00994C00; // Bleu foncé
      end;
    ntWarning:
      begin
        Color := $00C8FFFF; // Jaune clair
        FLabel.Font.Color := $00008CFF; // Orange foncé
      end;
    ntError:
      begin
        Color := $00C8D0FF; // Rouge clair
        FLabel.Font.Color := $00000080; // Rouge foncé
      end;
    ntSuccess:
      begin
        Color := $00D0FFD0; // Vert clair
        FLabel.Font.Color := $00006400; // Vert foncé
      end;
  end;
end;

procedure TNotificationBar.SetAutoHide(const Value: Boolean);
begin
  FAutoHide := Value;
end;

procedure TNotificationBar.SetDisplayTime(const Value: Integer);
begin
  FDisplayTime := Value;
  FTimer.Interval := FDisplayTime;
end;

procedure TNotificationBar.ShowNotification(const AMessage: string; AType: TNotificationType = ntInfo);
begin
  // Configurer le message et le type
  FLabel.Caption := AMessage;
  SetNotificationType(AType);

  // Afficher la notification
  Visible := True;
  BringToFront;

  // Démarrer le timer si AutoHide est activé
  if FAutoHide then
  begin
    FTimer.Interval := FDisplayTime;
    FTimer.Enabled := True;
  end;
end;

procedure TNotificationBar.HideNotification;
begin
  Visible := False;
  FTimer.Enabled := False;
end;

procedure TNotificationBar.CloseButtonClick(Sender: TObject);
begin
  HideNotification;
end;

procedure TNotificationBar.TimerTick(Sender: TObject);
begin
  HideNotification;
end;

end.
```

## Conclusion

L'interface utilisateur est l'élément avec lequel vos utilisateurs interagissent directement. Une interface bien conçue, intuitive et attrayante peut faire la différence entre une application appréciée et une application délaissée.

Dans cette partie, nous avons développé :

- Une interface utilisateur structurée avec un menu principal, des onglets et une barre latérale
- Des formulaires sophistiqués pour la gestion des produits et des commandes
- Un tableau de bord informatif pour visualiser les données importantes
- Des améliorations visuelles avec thèmes, icônes et animations
- Des fonctionnalités d'export pour la productivité des utilisateurs
- Une adaptation aux différentes résolutions d'écran

### Bonnes pratiques pour l'interface utilisateur

Voici quelques principes à garder à l'esprit lors de la conception d'interfaces :

1. **Cohérence** : Utilisez les mêmes conventions et éléments dans toute l'application
2. **Simplicité** : Ne surchargez pas l'interface, allez à l'essentiel
3. **Feedback** : Informez toujours l'utilisateur de ce qui se passe
4. **Tolérance aux erreurs** : Permettez à l'utilisateur de se corriger facilement
5. **Flexibilité** : Offrez différentes façons d'accomplir les mêmes tâches
6. **Performances** : Assurez-vous que l'interface reste réactive

### Prochaines étapes

Notre interface utilisateur est maintenant fonctionnelle et attrayante. Dans la section suivante (19.1.4), nous allons nous concentrer sur la création de rapports et tableaux de bord pour analyser les données de notre application de gestion.

---

*Note : De nombreux exemples de code présentés ici peuvent être améliorés et adaptés à vos besoins spécifiques. N'hésitez pas à explorer les possibilités offertes par Delphi pour créer des interfaces encore plus riches et personnalisées.*
