# 19.1.3 Interface utilisateur √©volu√©e

üîù Retour √† la [Table des mati√®res](/SOMMAIRE.md)

Apr√®s avoir cr√©√© notre base de donn√©es et impl√©ment√© les couches d'acc√®s aux donn√©es, nous allons maintenant concevoir une interface utilisateur professionnelle et ergonomique pour notre application de gestion. Une bonne interface est essentielle pour que les utilisateurs puissent interagir efficacement avec l'application.

## Objectifs de notre interface utilisateur

Notre interface doit r√©pondre √† plusieurs crit√®res :

1. **Intuitive et simple d'utilisation** : m√™me pour des utilisateurs peu familiers avec l'informatique
2. **Coh√©rente** : navigation et interactions homog√®nes dans toute l'application
3. **Responsive** : r√©active aux actions de l'utilisateur sans temps d'attente
4. **Informative** : fournir des retours clairs sur les actions effectu√©es
5. **Esth√©tique** : aspect visuel professionnel et agr√©able

## Structure globale de l'application

Commen√ßons par d√©finir la structure g√©n√©rale de notre application :

![Structure de l'application](https://via.placeholder.com/800x500)

Notre application comprendra :

- **Un formulaire principal** avec un menu et une barre d'outils
- **Des onglets** pour naviguer entre les diff√©rentes sections
- **Un tableau de bord** affichant les informations importantes
- **Des formulaires sp√©cialis√©s** pour la gestion des diff√©rentes entit√©s
- **Un syst√®me de notifications** pour informer l'utilisateur

## Cr√©ation du formulaire principal

Le formulaire principal sera la pierre angulaire de notre application. Cr√©ons-le :

1. Dans Delphi, s√©lectionnez **File > New > VCL Form**
2. Enregistrez-le sous le nom `FormMain.pas`

### Design du formulaire principal

```pascal
unit FormMain;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Menus, Vcl.ComCtrls,
  Vcl.ToolWin, Vcl.ExtCtrls, Vcl.Imaging.pngimage, System.Actions, Vcl.ActnList,
  Vcl.ImgList, System.ImageList, Vcl.StdCtrls, Vcl.Buttons, Vcl.CategoryButtons,
  Vcl.WinXCtrls;

type
  TfrmMain = class(TForm)
    MainMenu1: TMainMenu;
    mnuFichier: TMenuItem;
    mnuEdition: TMenuItem;
    mnuDonnees: TMenuItem;
    mnuRapports: TMenuItem;
    mnuAide: TMenuItem;
    mnuFichierQuitter: TMenuItem;
    mnuDonneesClients: TMenuItem;
    mnuDonneesProduits: TMenuItem;
    mnuDonneesFournisseurs: TMenuItem;
    mnuDonneesCommandes: TMenuItem;
    mnuDonneesCategories: TMenuItem;
    mnuRapportsVentes: TMenuItem;
    mnuRapportsStock: TMenuItem;
    mnuAideAPropos: TMenuItem;
    StatusBar1: TStatusBar;
    ToolBar1: TToolBar;
    pnlSidebar: TPanel;
    pnlContent: TPanel;
    splVertical: TSplitter;
    ActionList1: TActionList;
    actClientsListe: TAction;
    actProduitsListe: TAction;
    actFournisseursListe: TAction;
    actCommandesListe: TAction;
    actCategoriesListe: TAction;
    actRapportVentes: TAction;
    actRapportStock: TAction;
    actQuitter: TAction;
    ImageList1: TImageList;
    btnClients: TToolButton;
    btnProduits: TToolButton;
    btnCommandes: TToolButton;
    btnFournisseurs: TToolButton;
    btnRapports: TToolButton;
    ToolButton6: TToolButton;
    catSidebar: TCategoryButtons;
    SearchBox1: TSearchBox;
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    pnlWelcome: TPanel;
    lblWelcome: TLabel;
    btnQuickClients: TSpeedButton;
    btnQuickProduits: TSpeedButton;
    btnQuickCommandes: TSpeedButton;
    btnQuickRapports: TSpeedButton;
    TabSheet2: TTabSheet;
    procedure FormCreate(Sender: TObject);
    procedure actQuitterExecute(Sender: TObject);
    procedure actClientsListeExecute(Sender: TObject);
    procedure actProduitsListeExecute(Sender: TObject);
    procedure actFournisseursListeExecute(Sender: TObject);
    procedure actCommandesListeExecute(Sender: TObject);
    procedure actCategoriesListeExecute(Sender: TObject);
    procedure actRapportVentesExecute(Sender: TObject);
    procedure actRapportStockExecute(Sender: TObject);
    procedure catSidebarSelectedItemChange(Sender: TObject; const Category: TButtonCategory;
      const Button: TButtonItem);
    procedure FormShow(Sender: TObject);
    procedure SearchBox1InvokeSearch(Sender: TObject);
  private
    { D√©clarations priv√©es }
    FCurrentTab: TTabSheet;
    procedure InitializeSidebar;
    procedure ShowTabForm(AClass: TFormClass; const ATitle: string);
    procedure AdjustTabSheet;
    procedure UpdateStatusBar;
  public
    { D√©clarations publiques }
  end;

var
  frmMain: TfrmMain;

implementation

{$R *.dfm}

uses
  FormClientsList, FormProduitsList, FormFournisseursList, FormCommandesList,
  FormCategoriesList, FormRapportVentes, FormRapportStock, dmDatabase,
  VersionInfo;

procedure TfrmMain.FormCreate(Sender: TObject);
begin
  // Initialiser la connexion √† la base de donn√©es
  if not DataModuleDB.ConnectToDatabase then
  begin
    ShowMessage('Impossible de se connecter √† la base de donn√©es. ' +
      'Veuillez v√©rifier les param√®tres de connexion.');
    Application.Terminate;
  end;

  // Initialiser la barre lat√©rale
  InitializeSidebar;

  // Afficher les informations de version dans la barre d'√©tat
  StatusBar1.Panels[0].Text := Format('Version %s', [GetFileVersion]);
  StatusBar1.Panels[1].Text := 'Pr√™t';

  // Par d√©faut, aucun onglet actif
  FCurrentTab := nil;
end;

procedure TfrmMain.FormShow(Sender: TObject);
begin
  // Afficher le panneau d'accueil
  TabSheet1.TabVisible := True;
  TabSheet2.TabVisible := False;
  PageControl1.ActivePage := TabSheet1;

  // Mettre √† jour la barre d'√©tat
  UpdateStatusBar;
end;

procedure TfrmMain.InitializeSidebar;
var
  Category: TButtonCategory;
  Item: TButtonItem;
begin
  // Cat√©gorie Gestion
  Category := catSidebar.Categories.Add;
  Category.Caption := 'GESTION';
  Category.Color := clGradientInactiveCaption;

  Item := Category.Items.Add;
  Item.Caption := 'Clients';
  Item.ImageIndex := 0; // Index de l'image dans ImageList
  Item.Data := TObject(1); // ID unique pour l'action

  Item := Category.Items.Add;
  Item.Caption := 'Produits';
  Item.ImageIndex := 1;
  Item.Data := TObject(2);

  Item := Category.Items.Add;
  Item.Caption := 'Commandes';
  Item.ImageIndex := 2;
  Item.Data := TObject(3);

  Item := Category.Items.Add;
  Item.Caption := 'Fournisseurs';
  Item.ImageIndex := 3;
  Item.Data := TObject(4);

  Item := Category.Items.Add;
  Item.Caption := 'Cat√©gories';
  Item.ImageIndex := 4;
  Item.Data := TObject(5);

  // Cat√©gorie Rapports
  Category := catSidebar.Categories.Add;
  Category.Caption := 'RAPPORTS';
  Category.Color := clGradientInactiveCaption;

  Item := Category.Items.Add;
  Item.Caption := 'Ventes';
  Item.ImageIndex := 5;
  Item.Data := TObject(6);

  Item := Category.Items.Add;
  Item.Caption := 'Stock';
  Item.ImageIndex := 6;
  Item.Data := TObject(7);
end;

procedure TfrmMain.actQuitterExecute(Sender: TObject);
begin
  Close;
end;

procedure TfrmMain.ShowTabForm(AClass: TFormClass; const ATitle: string);
var
  Form: TForm;
  I: Integer;
  Found: Boolean;
begin
  // V√©rifier si l'onglet existe d√©j√†
  Found := False;
  for I := 0 to PageControl1.PageCount - 1 do
  begin
    if (PageControl1.Pages[I].Tag <> 0) and
       (TObject(PageControl1.Pages[I].Tag).ClassType = AClass) then
    begin
      PageControl1.ActivePage := PageControl1.Pages[I];
      Found := True;
      Break;
    end;
  end;

  if not Found then
  begin
    // Cr√©er un nouvel onglet avec le formulaire
    TabSheet2.Caption := ATitle;
    TabSheet2.TabVisible := True;
    PageControl1.ActivePage := TabSheet2;

    // Cr√©er le formulaire dans l'onglet
    Form := AClass.Create(Self);
    Form.Parent := TabSheet2;
    Form.BorderStyle := bsNone;
    Form.Align := alClient;
    Form.Show;

    // Garder une r√©f√©rence au formulaire
    TabSheet2.Tag := NativeInt(Form);

    // Cr√©er un nouvel onglet vide pour les prochaines vues
    FCurrentTab := TTabSheet.Create(PageControl1);
    FCurrentTab.PageControl := PageControl1;
    FCurrentTab.TabVisible := False;

    // Mettre √† jour TabSheet2 pour le nouvel onglet
    TabSheet2 := FCurrentTab;
  end;

  // Mettre √† jour la barre d'√©tat
  UpdateStatusBar;
end;

procedure TfrmMain.UpdateStatusBar;
begin
  if PageControl1.ActivePage = TabSheet1 then
    StatusBar1.Panels[1].Text := 'Accueil'
  else
    StatusBar1.Panels[1].Text := PageControl1.ActivePage.Caption;
end;

procedure TfrmMain.actClientsListeExecute(Sender: TObject);
begin
  ShowTabForm(TfrmClientsList, 'Clients');
end;

procedure TfrmMain.actProduitsListeExecute(Sender: TObject);
begin
  ShowTabForm(TfrmProduitsList, 'Produits');
end;

procedure TfrmMain.actFournisseursListeExecute(Sender: TObject);
begin
  ShowTabForm(TfrmFournisseursList, 'Fournisseurs');
end;

procedure TfrmMain.actCommandesListeExecute(Sender: TObject);
begin
  ShowTabForm(TfrmCommandesList, 'Commandes');
end;

procedure TfrmMain.actCategoriesListeExecute(Sender: TObject);
begin
  ShowTabForm(TfrmCategoriesList, 'Cat√©gories');
end;

procedure TfrmMain.actRapportVentesExecute(Sender: TObject);
begin
  ShowTabForm(TfrmRapportVentes, 'Rapport des ventes');
end;

procedure TfrmMain.actRapportStockExecute(Sender: TObject);
begin
  ShowTabForm(TfrmRapportStock, 'Rapport de stock');
end;

procedure TfrmMain.catSidebarSelectedItemChange(Sender: TObject;
  const Category: TButtonCategory; const Button: TButtonItem);
begin
  case Integer(Button.Data) of
    1: actClientsListe.Execute;
    2: actProduitsListe.Execute;
    3: actCommandesListe.Execute;
    4: actFournisseursListe.Execute;
    5: actCategoriesListe.Execute;
    6: actRapportVentes.Execute;
    7: actRapportStock.Execute;
  end;
end;

procedure TfrmMain.SearchBox1InvokeSearch(Sender: TObject);
var
  SearchTerm: string;
begin
  SearchTerm := Trim(SearchBox1.Text);
  if SearchTerm = '' then
    Exit;

  // Impl√©menter la recherche globale ici
  ShowMessage('Recherche de : ' + SearchTerm);
  // Vous pourriez ouvrir un formulaire de r√©sultats de recherche
end;

end.
```

## Utilisation des styles VCL

Delphi permet d'appliquer des styles visuels √† l'application pour lui donner un aspect moderne. Ajoutons cette fonctionnalit√© :

```pascal
// Dans le projet (.dpr)
program GestionCommerce;

uses
  Vcl.Forms,
  Vcl.Themes,
  Vcl.Styles,
  FormMain in 'FormMain.pas' {frmMain},
  // autres uses...

{$R *.res}

begin
  Application.Initialize;
  Application.MainFormOnTaskbar := True;

  // Chargement du style
  TStyleManager.TrySetStyle('Windows10');

  Application.CreateForm(TDataModuleDB, DataModuleDB);
  Application.CreateForm(TDataModuleBusiness, DataModuleBusiness);
  Application.CreateForm(TfrmMain, frmMain);
  Application.Run;
end.
```

Pour permettre √† l'utilisateur de choisir un style, ajoutons un menu :

```pascal
// Dans FormMain, ajouter :
mnuAffichage: TMenuItem;
mnuAffichageStyles: TMenuItem;
procedure mnuAffichageStylesClick(Sender: TObject);
// ...

// Et dans l'impl√©mentation :
procedure TfrmMain.mnuAffichageStylesClick(Sender: TObject);
var
  StyleName: string;
  MenuItem: TMenuItem;
begin
  for StyleName in TStyleManager.StyleNames do
  begin
    MenuItem := TMenuItem.Create(mnuAffichageStyles);
    MenuItem.Caption := StyleName;
    MenuItem.OnClick := StyleMenuItemClick;
    MenuItem.RadioItem := True;
    MenuItem.Checked := StyleName = TStyleManager.ActiveStyle.Name;
    mnuAffichageStyles.Add(MenuItem);
  end;
end;

procedure TfrmMain.StyleMenuItemClick(Sender: TObject);
begin
  if Sender is TMenuItem then
    TStyleManager.TrySetStyle(TMenuItem(Sender).Caption);
end;
```

## Cr√©ation d'un tableau de bord (Dashboard)

Ajoutons un tableau de bord attractif √† notre √©cran d'accueil :

```pascal
// Ajouter dans le fichier DFM ou via le designer
object pnlDashboard: TPanel
  AlignWithMargins = True
  Left = 10
  Top = 70
  Width = 580
  Height = 350
  Margins.Left = 10
  Margins.Top = 10
  Margins.Right = 10
  Margins.Bottom = 10
  Align = alClient
  BevelOuter = bvNone
  TabOrder = 1
  object FlowPanel1: TFlowPanel
    Left = 0
    Top = 0
    Width = 580
    Height = 350
    Align = alClient
    BevelOuter = bvNone
    TabOrder = 0
    object pnlStats1: TPanel
      AlignWithMargins = True
      Left = 3
      Top = 3
      Width = 180
      Height = 100
      Margins.Bottom = 10
      BevelOuter = bvNone
      Color = clSkyBlue
      ParentBackground = False
      TabOrder = 0
      object Label1: TLabel
        AlignWithMargins = True
        Left = 10
        Top = 10
        Width = 160
        Height = 19
        Margins.Left = 10
        Margins.Top = 10
        Align = alTop
        Caption = 'Clients'
        Font.Charset = DEFAULT_CHARSET
        Font.Color = clWhite
        Font.Height = -16
        Font.Name = 'Tahoma'
        Font.Style = [fsBold]
        ParentFont = False
        ExplicitWidth = 55
      end
      object lblTotalClients: TLabel
        AlignWithMargins = True
        Left = 10
        Top = 45
        Width = 160
        Height = 45
        Margins.Left = 10
        Margins.Top = 10
        Align = alClient
        Caption = '0'
        Font.Charset = DEFAULT_CHARSET
        Font.Color = clWhite
        Font.Height = -29
        Font.Name = 'Tahoma'
        Font.Style = [fsBold]
        ParentFont = False
        ExplicitWidth = 18
        ExplicitHeight = 35
      end
    end
    // Autres panneaux de statistiques similaires...
  end
end
```

Pour charger les donn√©es du tableau de bord :

```pascal
procedure TfrmMain.UpdateDashboard;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    // Nombre de clients
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text := 'SELECT COUNT(*) AS Total FROM Clients';
    Query.Open;
    lblTotalClients.Caption := Query.FieldByName('Total').AsString;
    Query.Close;

    // Nombre de produits
    Query.SQL.Text := 'SELECT COUNT(*) AS Total FROM Produits';
    Query.Open;
    lblTotalProduits.Caption := Query.FieldByName('Total').AsString;
    Query.Close;

    // Chiffre d'affaires du mois
    Query.SQL.Text :=
      'SELECT SUM(MontantTTC) AS Total FROM Commandes ' +
      'WHERE YEAR(DateCommande) = YEAR(CURRENT_DATE()) AND MONTH(DateCommande) = MONTH(CURRENT_DATE())';
    Query.Open;
    if not Query.FieldByName('Total').IsNull then
      lblCAMois.Caption := FormatFloat('#,##0.00 ‚Ç¨', Query.FieldByName('Total').AsFloat)
    else
      lblCAMois.Caption := '0,00 ‚Ç¨';
    Query.Close;

    // Commandes en attente
    Query.SQL.Text :=
      'SELECT COUNT(*) AS Total FROM Commandes WHERE Statut = ''En attente''';
    Query.Open;
    lblCommandesAttente.Caption := Query.FieldByName('Total').AsString;
    Query.Close;
  finally
    Query.Free;
  end;
end;
```

## Cr√©ation d'un formulaire de liste √©volu√©e

Am√©liorons notre formulaire de liste de produits pour le rendre plus fonctionnel :

```pascal
unit FormProduitsList;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.Grids,
  Vcl.DBGrids, Vcl.ExtCtrls, Vcl.StdCtrls, Vcl.Buttons, Vcl.ComCtrls,
  FireDAC.Comp.Client, System.Actions, Vcl.ActnList, System.ImageList,
  Vcl.ImgList, Vcl.Menus, Vcl.WinXCtrls, Vcl.DBCtrls, Vcl.Imaging.pngimage;

type
  TFilterType = (ftReference, ftDesignation, ftCategorie, ftFournisseur, ftTous);

  TfrmProduitsList = class(TForm)
    pnlTop: TPanel;
    pnlCenter: TPanel;
    pnlBottom: TPanel;
    btnAjouter: TSpeedButton;
    btnModifier: TSpeedButton;
    btnSupprimer: TSpeedButton;
    btnActualiser: TSpeedButton;
    lblTotal: TLabel;
    btnExporter: TSpeedButton;
    DBGrid1: TDBGrid;
    ActionList1: TActionList;
    actAjouter: TAction;
    actModifier: TAction;
    actSupprimer: TAction;
    actActualiser: TAction;
    actExporter: TAction;
    ImageList1: TImageList;
    DataSource1: TDataSource;
    SearchBox1: TSearchBox;
    cboFiltre: TComboBox;
    lblFiltre: TLabel;
    StatusBar1: TStatusBar;
    PanelPreview: TPanel;
    SplitterPreview: TSplitter;
    lblPreviewTitle: TLabel;
    imgProduit: TImage;
    lblReference: TLabel;
    lblDesignation: TLabel;
    lblPrix: TLabel;
    lblCategorie: TLabel;
    lblStock: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure actAjouterExecute(Sender: TObject);
    procedure actModifierExecute(Sender: TObject);
    procedure actSupprimerExecute(Sender: TObject);
    procedure actActualiserExecute(Sender: TObject);
    procedure actExporterExecute(Sender: TObject);
    procedure cboFiltreChange(Sender: TObject);
    procedure SearchBox1InvokeSearch(Sender: TObject);
    procedure DBGrid1CellClick(Column: TColumn);
    procedure FormResize(Sender: TObject);
  private
    { D√©clarations priv√©es }
    FQuery: TFDQuery;
    FFilterType: TFilterType;
    procedure LoadData(const ASearchTerm: string = '');
    procedure UpdateButtons;
    procedure UpdateTotalLabel;
    procedure PreviewProduit;
    function GetSelectedProduitID: Integer;
    procedure ExportToCSV;
    procedure AdjustGridColumns;
  public
    { D√©clarations publiques }
  end;

var
  frmProduitsList: TfrmProduitsList;

implementation

{$R *.dfm}

uses
  dmBusiness, FormProduitEdit, FormProduitDetails, Winapi.ShellAPI,
  System.UITypes, Vcl.FileCtrl, System.IOUtils, System.Types;

procedure TfrmProduitsList.FormCreate(Sender: TObject);
begin
  FFilterType := ftTous;
  cboFiltre.ItemIndex := 4; // "Tous" par d√©faut

  LoadData;
  UpdateButtons;
  AdjustGridColumns;

  // Initialiser le panneau d'aper√ßu
  PanelPreview.Width := 250;
  PreviewProduit; // Afficher le premier produit
end;

procedure TfrmProduitsList.FormDestroy(Sender: TObject);
begin
  if Assigned(FQuery) then
    FQuery.Free;
end;

procedure TfrmProduitsList.FormResize(Sender: TObject);
begin
  AdjustGridColumns;
end;

procedure TfrmProduitsList.AdjustGridColumns;
var
  TotalWidth, i: Integer;
  ColWidths: array[0..5] of Double;
  ColPercents: array[0..5] of Double;
begin
  // D√©finir les pourcentages de largeur pour chaque colonne
  ColPercents[0] := 0.08; // ID
  ColPercents[1] := 0.17; // R√©f√©rence
  ColPercents[2] := 0.35; // D√©signation
  ColPercents[3] := 0.15; // Prix
  ColPercents[4] := 0.15; // Cat√©gorie
  ColPercents[5] := 0.10; // Stock

  // Calculer la largeur totale disponible
  TotalWidth := DBGrid1.ClientWidth - 25; // 25 pour la scrollbar

  // Calculer la largeur de chaque colonne
  for i := 0 to 5 do
    ColWidths[i] := TotalWidth * ColPercents[i];

  // Appliquer les largeurs aux colonnes
  for i := 0 to 5 do
  begin
    if i < DBGrid1.Columns.Count then
      DBGrid1.Columns[i].Width := Round(ColWidths[i]);
  end;
end;

procedure TfrmProduitsList.LoadData(const ASearchTerm: string = '');
var
  SQL, WhereClause: string;
begin
  if Assigned(FQuery) then
    FQuery.Free;

  FQuery := TFDQuery.Create(nil);
  FQuery.Connection := DataModuleBusiness.ProduitRepository.Connection;

  SQL :=
    'SELECT p.ProduitID, p.Reference, p.Designation, p.PrixVente, p.TVA, ' +
    'c.NomCategorie, s.QuantiteDisponible, f.RaisonSociale AS Fournisseur ' +
    'FROM Produits p ' +
    'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
    'LEFT JOIN Stock s ON p.ProduitID = s.ProduitID ' +
    'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID';

  // Construire la clause WHERE selon le filtre et le terme de recherche
  if ASearchTerm <> '' then
  begin
    case FFilterType of
      ftReference:
        WhereClause := ' WHERE p.Reference LIKE ' + QuotedStr('%' + ASearchTerm + '%');
      ftDesignation:
        WhereClause := ' WHERE p.Designation LIKE ' + QuotedStr('%' + ASearchTerm + '%');
      ftCategorie:
        WhereClause := ' WHERE c.NomCategorie LIKE ' + QuotedStr('%' + ASearchTerm + '%');
      ftFournisseur:
        WhereClause := ' WHERE f.RaisonSociale LIKE ' + QuotedStr('%' + ASearchTerm + '%');
      ftTous:
        WhereClause := ' WHERE (p.Reference LIKE ' + QuotedStr('%' + ASearchTerm + '%') +
                       ' OR p.Designation LIKE ' + QuotedStr('%' + ASearchTerm + '%') +
                       ' OR c.NomCategorie LIKE ' + QuotedStr('%' + ASearchTerm + '%') +
                       ' OR f.RaisonSociale LIKE ' + QuotedStr('%' + ASearchTerm + '%') + ')';
    end;

    SQL := SQL + WhereClause;
  end;

  // Ajouter l'ordre de tri
  SQL := SQL + ' ORDER BY p.Designation';

  FQuery.SQL.Text := SQL;
  FQuery.Open;

  // Configurer les champs pour l'affichage
  FQuery.FieldByName('ProduitID').DisplayLabel := 'ID';
  FQuery.FieldByName('Reference').DisplayLabel := 'R√©f√©rence';
  FQuery.FieldByName('Designation').DisplayLabel := 'D√©signation';
  FQuery.FieldByName('PrixVente').DisplayLabel := 'Prix HT';
  FQuery.FieldByName('PrixVente').DisplayFormat := '#,##0.00 ‚Ç¨';
  FQuery.FieldByName('NomCategorie').DisplayLabel := 'Cat√©gorie';
  FQuery.FieldByName('QuantiteDisponible').DisplayLabel := 'Stock';
  FQuery.FieldByName('QuantiteDisponible').DisplayFormat := '#,##0';

  // Associer √† la source de donn√©es
  DataSource1.DataSet := FQuery;

  // Mettre √† jour le label de total
  UpdateTotalLabel;

  // Mettre √† jour les boutons
  UpdateButtons;

  // Afficher un aper√ßu du premier produit
  if not FQuery.IsEmpty then
    PreviewProduit;
end;

procedure TfrmProduitsList.UpdateTotalLabel;
begin
  lblTotal.Caption := Format('Total : %d produits', [FQuery.RecordCount]);
end;

procedure TfrmProduitsList.UpdateButtons;
var
  HasSelection: Boolean;
begin
  HasSelection := not FQuery.IsEmpty;

  actModifier.Enabled := HasSelection;
  actSupprimer.Enabled := HasSelection;

  if HasSelection then
    StatusBar1.Panels[0].Text := 'Produit s√©lectionn√© : ' + FQuery.FieldByName('Designation').AsString
  else
    StatusBar1.Panels[0].Text := 'Aucun produit s√©lectionn√©';
end;

procedure TfrmProduitsList.PreviewProduit;
var
  PhotoPath: string;
  Query: TFDQuery;
begin
  if FQuery.IsEmpty then
  begin
    // R√©initialiser l'aper√ßu
    lblPreviewTitle.Caption := 'Aucun produit s√©lectionn√©';
    lblReference.Caption := '';
    lblDesignation.Caption := '';
    lblPrix.Caption := '';
    lblCategorie.Caption := '';
    lblStock.Caption := '';
    imgProduit.Picture := nil;
    Exit;
  end;

procedure TfrmProduitsList.PreviewProduit;
var
  PhotoPath: string;
  Query: TFDQuery;
begin
  if FQuery.IsEmpty then
  begin
    // R√©initialiser l'aper√ßu
    lblPreviewTitle.Caption := 'Aucun produit s√©lectionn√©';
    lblReference.Caption := '';
    lblDesignation.Caption := '';
    lblPrix.Caption := '';
    lblCategorie.Caption := '';
    lblStock.Caption := '';
    imgProduit.Picture := nil;
    Exit;
  end;

  // Charger les informations d√©taill√©es du produit
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleBusiness.ProduitRepository.Connection;
    Query.SQL.Text :=
      'SELECT p.*, c.NomCategorie, s.QuantiteDisponible, f.RaisonSociale AS Fournisseur ' +
      'FROM Produits p ' +
      'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
      'LEFT JOIN Stock s ON p.ProduitID = s.ProduitID ' +
      'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
      'WHERE p.ProduitID = :ProduitID';
    Query.ParamByName('ProduitID').AsInteger := FQuery.FieldByName('ProduitID').AsInteger;
    Query.Open;

    // Mettre √† jour les labels
    lblPreviewTitle.Caption := 'Aper√ßu du produit';
    lblReference.Caption := 'R√©f : ' + Query.FieldByName('Reference').AsString;
    lblDesignation.Caption := Query.FieldByName('Designation').AsString;

    // Afficher le prix TTC
    lblPrix.Caption := 'Prix : ' + FormatFloat('#,##0.00 ‚Ç¨',
      Query.FieldByName('PrixVente').AsFloat * (1 + Query.FieldByName('TVA').AsFloat / 100));

    lblCategorie.Caption := 'Cat√©gorie : ' + Query.FieldByName('NomCategorie').AsString;

    // Afficher le stock avec une couleur selon la disponibilit√©
    if Query.FieldByName('QuantiteDisponible').AsInteger <= 0 then
    begin
      lblStock.Font.Color := clRed;
      lblStock.Caption := 'Stock : √âpuis√©';
    end
    else if Query.FieldByName('QuantiteDisponible').AsInteger < 5 then
    begin
      lblStock.Font.Color := clOrange;
      lblStock.Caption := 'Stock : ' + Query.FieldByName('QuantiteDisponible').AsString + ' (Faible)';
    end
    else
    begin
      lblStock.Font.Color := clGreen;
      lblStock.Caption := 'Stock : ' + Query.FieldByName('QuantiteDisponible').AsString;
    end;

    // Charger l'image du produit si disponible
    PhotoPath := Query.FieldByName('PhotoURL').AsString;
    if (PhotoPath <> '') and FileExists(PhotoPath) then
    begin
      try
        imgProduit.Picture.LoadFromFile(PhotoPath);
      except
        // En cas d'erreur, on affiche une image par d√©faut
        imgProduit.Picture := nil;
      end;
    end
    else
    begin
      // Image par d√©faut si aucune photo n'est disponible
      imgProduit.Picture := nil;
    end;
  finally
    Query.Free;
  end;
end;

function TfrmProduitsList.GetSelectedProduitID: Integer;
begin
  Result := 0;

  if not FQuery.IsEmpty then
    Result := FQuery.FieldByName('ProduitID').AsInteger;
end;

procedure TfrmProduitsList.DBGrid1CellClick(Column: TColumn);
begin
  PreviewProduit;
  UpdateButtons;
end;

procedure TfrmProduitsList.cboFiltreChange(Sender: TObject);
begin
  // Mettre √† jour le type de filtre
  FFilterType := TFilterType(cboFiltre.ItemIndex);

  // R√©initialiser la recherche
  SearchBox1.Text := '';

  // Recharger les donn√©es
  LoadData;
end;

procedure TfrmProduitsList.SearchBox1InvokeSearch(Sender: TObject);
begin
  LoadData(SearchBox1.Text);
end;

procedure TfrmProduitsList.actAjouterExecute(Sender: TObject);
var
  Form: TfrmProduitEdit;
begin
  Form := TfrmProduitEdit.Create(Self);
  try
    Form.InitAdd;
    if Form.ShowModal = mrOk then
    begin
      LoadData(SearchBox1.Text);
      ShowMessage('Produit ajout√© avec succ√®s !');
    end;
  finally
    Form.Free;
  end;
end;

procedure TfrmProduitsList.actModifierExecute(Sender: TObject);
var
  Form: TfrmProduitEdit;
  ID: Integer;
begin
  ID := GetSelectedProduitID;
  if ID <= 0 then
    Exit;

  Form := TfrmProduitEdit.Create(Self);
  try
    Form.InitEdit(ID);
    if Form.ShowModal = mrOk then
    begin
      LoadData(SearchBox1.Text);
      ShowMessage('Produit modifi√© avec succ√®s !');
    end;
  finally
    Form.Free;
  end;
end;

procedure TfrmProduitsList.actSupprimerExecute(Sender: TObject);
var
  ID: Integer;
  Designation: string;
begin
  ID := GetSelectedProduitID;
  if ID <= 0 then
    Exit;

  Designation := FQuery.FieldByName('Designation').AsString;

  if MessageDlg(Format('√ätes-vous s√ªr de vouloir supprimer le produit "%s" ?',
    [Designation]), mtConfirmation, [mbYes, mbNo], 0) = mrYes then
  begin
    if DataModuleBusiness.ProduitRepository.Supprimer(ID) then
    begin
      LoadData(SearchBox1.Text);
      ShowMessage('Produit supprim√© avec succ√®s !');
    end
    else
      ShowMessage('Erreur lors de la suppression du produit.');
  end;
end;

procedure TfrmProduitsList.actActualiserExecute(Sender: TObject);
begin
  SearchBox1.Text := '';
  LoadData;
end;

procedure TfrmProduitsList.ExportToCSV;
var
  SaveDialog: TSaveDialog;
  CSVFile: TextFile;
  i, j: Integer;
  Line, CellValue: string;
  OutputDir: string;
begin
  SaveDialog := TSaveDialog.Create(nil);
  try
    SaveDialog.Title := 'Exporter les produits au format CSV';
    SaveDialog.Filter := 'Fichiers CSV (*.csv)|*.csv';
    SaveDialog.DefaultExt := 'csv';
    SaveDialog.FileName := 'liste_produits_' + FormatDateTime('yyyymmdd', Now) + '.csv';

    if not SaveDialog.Execute then
      Exit;

    OutputDir := ExtractFilePath(SaveDialog.FileName);
    if not DirectoryExists(OutputDir) then
      ForceDirectories(OutputDir);

    AssignFile(CSVFile, SaveDialog.FileName);
    Rewrite(CSVFile);

    try
      // √âcrire l'en-t√™te
      Line := '';
      for i := 0 to DBGrid1.Columns.Count - 1 do
      begin
        if i > 0 then
          Line := Line + ';';
        Line := Line + '"' + DBGrid1.Columns[i].Title.Caption + '"';
      end;
      WriteLn(CSVFile, Line);

      // √âcrire les donn√©es
      FQuery.First;
      while not FQuery.Eof do
      begin
        Line := '';
        for i := 0 to DBGrid1.Columns.Count - 1 do
        begin
          if i > 0 then
            Line := Line + ';';

          CellValue := FQuery.Fields[i].AsString;
          // Remplacer les guillemets par des doubles guillemets pour CSV
          CellValue := StringReplace(CellValue, '"', '""', [rfReplaceAll]);
          Line := Line + '"' + CellValue + '"';
        end;
        WriteLn(CSVFile, Line);
        FQuery.Next;
      end;

      // Afficher un message de confirmation
      if MessageDlg('Export CSV termin√© avec succ√®s. Voulez-vous ouvrir le fichier ?',
         mtConfirmation, [mbYes, mbNo], 0) = mrYes then
      begin
        ShellExecute(0, 'open', PChar(SaveDialog.FileName), nil, nil, SW_SHOWNORMAL);
      end;
    finally
      CloseFile(CSVFile);
    end;
  finally
    SaveDialog.Free;
  end;
end;

procedure TfrmProduitsList.actExporterExecute(Sender: TObject);
begin
  ExportToCSV;
end;
```

## Cr√©ation d'un formulaire de d√©tails avec onglets

Cr√©ons maintenant un formulaire d√©taill√© pour afficher toutes les informations d'un produit, avec une interface √† onglets pour une meilleure organisation :

```pascal
unit FormProduitDetails;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ComCtrls, Vcl.ExtCtrls,
  Vcl.StdCtrls, Vcl.Imaging.pngimage, Vcl.Buttons, Data.DB, FireDAC.Comp.Client,
  Vcl.Grids, Vcl.DBGrids, System.Actions, Vcl.ActnList,
  Produit, ProduitRepository, dmDatabase, dmBusiness;

type
  TfrmProduitDetails = class(TForm)
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    TabSheet2: TTabSheet;
    TabSheet3: TTabSheet;
    TabSheet4: TTabSheet;
    pnlTop: TPanel;
    lblTitre: TLabel;
    btnClose: TSpeedButton;
    btnEdit: TSpeedButton;
    pnlInfos: TPanel;
    lblReference: TLabel;
    lblDesignation: TLabel;
    lblDescription: TLabel;
    lblPrixAchat: TLabel;
    lblPrixVente: TLabel;
    lblTVA: TLabel;
    lblCategorie: TLabel;
    lblFournisseur: TLabel;
    memoDescription: TMemo;
    imgProduit: TImage;
    lblDateCreation: TLabel;
    pnlStock: TPanel;
    lblStockDisponible: TLabel;
    lblStockMinimum: TLabel;
    lblEmplacement: TLabel;
    lblDerniereMAJ: TLabel;
    btnCommanderStock: TButton;
    DBGridMouvements: TDBGrid;
    lblMouvements: TLabel;
    pnlCommandes: TPanel;
    lblHistoriqueCommandes: TLabel;
    DBGridCommandes: TDBGrid;
    pnlStats: TPanel;
    lblStatistiques: TLabel;
    lblVentesMois: TLabel;
    lblVentesAnnee: TLabel;
    lblEvolution: TLabel;
    chartVentes: TPanel;
    ActionList1: TActionList;
    actEditer: TAction;
    actCommanderStock: TAction;
    actExportHistorique: TAction;
    btnExportHistorique: TButton;
    DataSource1: TDataSource;
    DataSource2: TDataSource;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure btnCloseClick(Sender: TObject);
    procedure actEditerExecute(Sender: TObject);
    procedure actCommanderStockExecute(Sender: TObject);
    procedure actExportHistoriqueExecute(Sender: TObject);
    procedure FormShow(Sender: TObject);
  private
    { D√©clarations priv√©es }
    FProduitID: Integer;
    FProduit: TProduit;
    FQueryMouvements: TFDQuery;
    FQueryCommandes: TFDQuery;
    procedure LoadProduit;
    procedure LoadMouvements;
    procedure LoadCommandes;
    procedure LoadStatistiques;
    procedure UpdateLabels;
  public
    { D√©clarations publiques }
    constructor Create(AOwner: TComponent; AProduitID: Integer); reintroduce;
  end;

implementation

{$R *.dfm}

uses
  FormProduitEdit, System.UITypes, Vcl.FileCtrl, System.IOUtils;

constructor TfrmProduitDetails.Create(AOwner: TComponent; AProduitID: Integer);
begin
  inherited Create(AOwner);
  FProduitID := AProduitID;
end;

procedure TfrmProduitDetails.FormCreate(Sender: TObject);
begin
  FProduit := nil;
  FQueryMouvements := nil;
  FQueryCommandes := nil;

  // Par d√©faut, on affiche le premier onglet
  PageControl1.ActivePageIndex := 0;
end;

procedure TfrmProduitDetails.FormDestroy(Sender: TObject);
begin
  if Assigned(FProduit) then
    FProduit.Free;

  if Assigned(FQueryMouvements) then
    FQueryMouvements.Free;

  if Assigned(FQueryCommandes) then
    FQueryCommandes.Free;
end;

procedure TfrmProduitDetails.FormShow(Sender: TObject);
begin
  LoadProduit;
  LoadMouvements;
  LoadCommandes;
  LoadStatistiques;
end;

procedure TfrmProduitDetails.LoadProduit;
var
  Query: TFDQuery;
begin
  // Lib√©rer l'objet pr√©c√©dent s'il existe
  if Assigned(FProduit) then
    FProduit.Free;

  // Charger le produit complet
  FProduit := DataModuleBusiness.ProduitRepository.ObtenirParID(FProduitID);

  if FProduit = nil then
  begin
    ShowMessage('Produit non trouv√© !');
    Close;
    Exit;
  end;

  // Mettre √† jour le titre
  lblTitre.Caption := FProduit.Designation;

  // Charger les informations compl√©mentaires (cat√©gorie, fournisseur, stock)
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text :=
      'SELECT p.*, c.NomCategorie, f.RaisonSociale AS NomFournisseur, ' +
      's.QuantiteDisponible, s.StockMinimum, s.Emplacement, s.DerniereMiseAJour ' +
      'FROM Produits p ' +
      'LEFT JOIN Categories c ON p.CategoryID = c.CategoryID ' +
      'LEFT JOIN Fournisseurs f ON p.FournisseurID = f.FournisseurID ' +
      'LEFT JOIN Stock s ON p.ProduitID = s.ProduitID ' +
      'WHERE p.ProduitID = :ProduitID';
    Query.ParamByName('ProduitID').AsInteger := FProduitID;
    Query.Open;

    if not Query.IsEmpty then
    begin
      // Mettre √† jour les labels avec les informations
      lblReference.Caption := 'R√©f√©rence : ' + Query.FieldByName('Reference').AsString;
      lblDesignation.Caption := Query.FieldByName('Designation').AsString;
      memoDescription.Text := Query.FieldByName('Description').AsString;
      lblPrixAchat.Caption := 'Prix d''achat : ' + FormatFloat('#,##0.00 ‚Ç¨', Query.FieldByName('PrixAchat').AsFloat);
      lblPrixVente.Caption := 'Prix de vente HT : ' + FormatFloat('#,##0.00 ‚Ç¨', Query.FieldByName('PrixVente').AsFloat);
      lblTVA.Caption := 'TVA : ' + FormatFloat('0.0 %', Query.FieldByName('TVA').AsFloat);

      // Prix TTC
      lblPrixVente.Hint := 'Prix TTC : ' + FormatFloat('#,##0.00 ‚Ç¨',
        Query.FieldByName('PrixVente').AsFloat * (1 + Query.FieldByName('TVA').AsFloat / 100));
      lblPrixVente.ShowHint := True;

      lblCategorie.Caption := 'Cat√©gorie : ' + Query.FieldByName('NomCategorie').AsString;
      lblFournisseur.Caption := 'Fournisseur : ' + Query.FieldByName('NomFournisseur').AsString;
      lblDateCreation.Caption := 'Date d''ajout : ' + FormatDateTime('dd/mm/yyyy', Query.FieldByName('DateCreation').AsDateTime);

      // Stock
      if not Query.FieldByName('QuantiteDisponible').IsNull then
      begin
        lblStockDisponible.Caption := 'Stock disponible : ' + Query.FieldByName('QuantiteDisponible').AsString;

        // Couleur selon le niveau de stock
        if Query.FieldByName('QuantiteDisponible').AsInteger <= 0 then
          lblStockDisponible.Font.Color := clRed
        else if Query.FieldByName('QuantiteDisponible').AsInteger < Query.FieldByName('StockMinimum').AsInteger then
          lblStockDisponible.Font.Color := clOrange
        else
          lblStockDisponible.Font.Color := clGreen;
      end
      else
        lblStockDisponible.Caption := 'Stock disponible : Non suivi';

      lblStockMinimum.Caption := 'Stock minimum : ' + Query.FieldByName('StockMinimum').AsString;
      lblEmplacement.Caption := 'Emplacement : ' + Query.FieldByName('Emplacement').AsString;

      if not Query.FieldByName('DerniereMiseAJour').IsNull then
        lblDerniereMAJ.Caption := 'Derni√®re mise √† jour : ' +
          FormatDateTime('dd/mm/yyyy hh:nn', Query.FieldByName('DerniereMiseAJour').AsDateTime)
      else
        lblDerniereMAJ.Caption := 'Derni√®re mise √† jour : Jamais';

      // Chargement de l'image
      if (FProduit.PhotoURL <> '') and FileExists(FProduit.PhotoURL) then
      begin
        try
          imgProduit.Picture.LoadFromFile(FProduit.PhotoURL);
        except
          // En cas d'erreur, on laisse l'image vide
        end;
      end;
    end;
  finally
    Query.Free;
  end;
end;

procedure TfrmProduitDetails.LoadMouvements;
begin
  if Assigned(FQueryMouvements) then
    FQueryMouvements.Free;

  FQueryMouvements := TFDQuery.Create(nil);
  FQueryMouvements.Connection := DataModuleDB.FDConnection;
  FQueryMouvements.SQL.Text :=
    'SELECT m.MouvementID, m.DateMouvement, m.TypeMouvement, m.Quantite, ' +
    'm.Commentaire, u.Nom AS Utilisateur ' +
    'FROM MouvementStock m ' +
    'LEFT JOIN Utilisateurs u ON m.UtilisateurID = u.UtilisateurID ' +
    'WHERE m.ProduitID = :ProduitID ' +
    'ORDER BY m.DateMouvement DESC';
  FQueryMouvements.ParamByName('ProduitID').AsInteger := FProduitID;
  FQueryMouvements.Open;

  // Configuration de l'affichage des colonnes
  DataSource1.DataSet := FQueryMouvements;

  // Titre mis √† jour avec le nombre de mouvements
  lblMouvements.Caption := Format('Historique des mouvements (%d)', [FQueryMouvements.RecordCount]);
end;

procedure TfrmProduitDetails.LoadCommandes;
begin
  if Assigned(FQueryCommandes) then
    FQueryCommandes.Free;

  FQueryCommandes := TFDQuery.Create(nil);
  FQueryCommandes.Connection := DataModuleDB.FDConnection;
  FQueryCommandes.SQL.Text :=
    'SELECT c.CommandeID, c.Reference, c.DateCommande, c.Statut, ' +
    'cl.Nom AS NomClient, l.Quantite, l.PrixUnitaire, l.Remise ' +
    'FROM Commandes c ' +
    'JOIN LignesCommande l ON c.CommandeID = l.CommandeID ' +
    'JOIN Clients cl ON c.ClientID = cl.ClientID ' +
    'WHERE l.ProduitID = :ProduitID ' +
    'ORDER BY c.DateCommande DESC';
  FQueryCommandes.ParamByName('ProduitID').AsInteger := FProduitID;
  FQueryCommandes.Open;

  // Configuration de l'affichage des colonnes
  DataSource2.DataSet := FQueryCommandes;

  // Titre mis √† jour avec le nombre de commandes
  lblHistoriqueCommandes.Caption := Format('Historique des commandes (%d)', [FQueryCommandes.RecordCount]);
end;

procedure TfrmProduitDetails.LoadStatistiques;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;

    // Ventes du mois en cours
    Query.SQL.Text :=
      'SELECT SUM(l.Quantite) AS TotalVentes, SUM(l.Quantite * l.PrixUnitaire) AS MontantTotal ' +
      'FROM LignesCommande l ' +
      'JOIN Commandes c ON l.CommandeID = c.CommandeID ' +
      'WHERE l.ProduitID = :ProduitID ' +
      'AND YEAR(c.DateCommande) = YEAR(CURRENT_DATE) ' +
      'AND MONTH(c.DateCommande) = MONTH(CURRENT_DATE) ' +
      'AND c.Statut NOT IN (''Annul√©e'')';
    Query.ParamByName('ProduitID').AsInteger := FProduitID;
    Query.Open;

    if not Query.FieldByName('TotalVentes').IsNull then
      lblVentesMois.Caption := Format('Ventes du mois : %d unit√©s / %s',
        [Query.FieldByName('TotalVentes').AsInteger,
         FormatFloat('#,##0.00 ‚Ç¨', Query.FieldByName('MontantTotal').AsFloat)])
    else
      lblVentesMois.Caption := 'Ventes du mois : 0 unit√© / 0,00 ‚Ç¨';

    Query.Close;

    // Ventes de l'ann√©e en cours
    Query.SQL.Text :=
      'SELECT SUM(l.Quantite) AS TotalVentes, SUM(l.Quantite * l.PrixUnitaire) AS MontantTotal ' +
      'FROM LignesCommande l ' +
      'JOIN Commandes c ON l.CommandeID = c.CommandeID ' +
      'WHERE l.ProduitID = :ProduitID ' +
      'AND YEAR(c.DateCommande) = YEAR(CURRENT_DATE) ' +
      'AND c.Statut NOT IN (''Annul√©e'')';
    Query.ParamByName('ProduitID').AsInteger := FProduitID;
    Query.Open;

    if not Query.FieldByName('TotalVentes').IsNull then
      lblVentesAnnee.Caption := Format('Ventes de l''ann√©e : %d unit√©s / %s',
        [Query.FieldByName('TotalVentes').AsInteger,
         FormatFloat('#,##0.00 ‚Ç¨', Query.FieldByName('MontantTotal').AsFloat)])
    else
      lblVentesAnnee.Caption := 'Ventes de l''ann√©e : 0 unit√© / 0,00 ‚Ç¨';

    Query.Close;

    // √âvolution par rapport au mois pr√©c√©dent
    Query.SQL.Text :=
      'SELECT ' +
      '(SELECT SUM(l.Quantite) FROM LignesCommande l ' +
      'JOIN Commandes c ON l.CommandeID = c.CommandeID ' +
      'WHERE l.ProduitID = :ProduitID ' +
      'AND YEAR(c.DateCommande) = YEAR(CURRENT_DATE) ' +
      'AND MONTH(c.DateCommande) = MONTH(CURRENT_DATE) ' +
      'AND c.Statut NOT IN (''Annul√©e'')) AS VentesMoisCourant, ' +

      '(SELECT SUM(l.Quantite) FROM LignesCommande l ' +
      'JOIN Commandes c ON l.CommandeID = c.CommandeID ' +
      'WHERE l.ProduitID = :ProduitID ' +
      'AND YEAR(c.DateCommande) = YEAR(DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)) ' +
      'AND MONTH(c.DateCommande) = MONTH(DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH)) ' +
      'AND c.Statut NOT IN (''Annul√©e'')) AS VentesMoisPrecedent';
    Query.ParamByName('ProduitID').AsInteger := FProduitID;
    Query.Open;

    if (not Query.FieldByName('VentesMoisCourant').IsNull) and
       (not Query.FieldByName('VentesMoisPrecedent').IsNull) and
       (Query.FieldByName('VentesMoisPrecedent').AsInteger > 0) then
    begin
      // Calculer l'√©volution en pourcentage
      var VentesMoisCourant: Integer := Query.FieldByName('VentesMoisCourant').AsInteger;
      var VentesMoisPrecedent: Integer := Query.FieldByName('VentesMoisPrecedent').AsInteger;
      var Evolution: Double := ((VentesMoisCourant - VentesMoisPrecedent) / VentesMoisPrecedent) * 100;

      if Evolution > 0 then
      begin
        lblEvolution.Caption := Format('√âvolution : +%.1f%% par rapport au mois pr√©c√©dent', [Evolution]);
        lblEvolution.Font.Color := clGreen;
      end
      else if Evolution < 0 then
      begin
        lblEvolution.Caption := Format('√âvolution : %.1f%% par rapport au mois pr√©c√©dent', [Evolution]);
        lblEvolution.Font.Color := clRed;
      end
      else
      begin
        lblEvolution.Caption := '√âvolution : stable par rapport au mois pr√©c√©dent';
        lblEvolution.Font.Color := clWindowText;
      end;
    end
    else
      lblEvolution.Caption := '√âvolution : non disponible';

    // Ici, on pourrait ajouter du code pour g√©n√©rer un graphique des ventes
    // en utilisant par exemple TeeChart ou un autre composant de graphique
  finally
    Query.Free;
  end;
end;

procedure TfrmProduitDetails.actCommanderStockExecute(Sender: TObject);
var
  Quantite: Integer;
begin
  if not InputQuery('Commander du stock', 'Quantit√© √† commander :', Quantite) then
    Exit;

  if Quantite <= 0 then
  begin
    ShowMessage('Veuillez entrer une quantit√© valide.');
    Exit;
  end;

  // Ici, on pourrait impl√©menter la cr√©ation d'une commande fournisseur
  // ou d'un mouvement de stock pr√©vu

  ShowMessage(Format('Commande de %d unit√©s effectu√©e.', [Quantite]));

  // Recharger les donn√©es
  LoadMouvements;
end;

procedure TfrmProduitDetails.actEditerExecute(Sender: TObject);
var
  Form: TfrmProduitEdit;
begin
  Form := TfrmProduitEdit.Create(Self);
  try
    Form.InitEdit(FProduitID);
    if Form.ShowModal = mrOk then
    begin
      // Recharger les donn√©es
      LoadProduit;
      LoadMouvements;
      LoadCommandes;
      LoadStatistiques;
      ShowMessage('Produit modifi√© avec succ√®s !');
    end;
  finally
    Form.Free;
  end;
end;

procedure TfrmProduitDetails.actExportHistoriqueExecute(Sender: TObject);
var
  SaveDialog: TSaveDialog;
  CSVFile: TextFile;
  i: Integer;
  Line, CellValue: string;
begin
  SaveDialog := TSaveDialog.Create(nil);
  try
    SaveDialog.Title := 'Exporter l''historique au format CSV';
    SaveDialog.Filter := 'Fichiers CSV (*.csv)|*.csv';
    SaveDialog.DefaultExt := 'csv';
    SaveDialog.FileName := 'historique_' + FProduit.Reference + '_' + FormatDateTime('yyyymmdd', Now) + '.csv';

    if not SaveDialog.Execute then
      Exit;

    AssignFile(CSVFile, SaveDialog.FileName);
    Rewrite(CSVFile);

    try
      // √âcrire l'en-t√™te
      Line := '';
      for i := 0 to DBGridMouvements.Columns.Count - 1 do
      begin
        if i > 0 then
          Line := Line + ';';
        Line := Line + '"' + DBGridMouvements.Columns[i].Title.Caption + '"';
      end;
      WriteLn(CSVFile, Line);

      // √âcrire les donn√©es
      FQueryMouvements.First;
      while not FQueryMouvements.Eof do
      begin
        Line := '';
        for i := 0 to DBGridMouvements.Columns.Count - 1 do
        begin
          if i > 0 then
            Line := Line + ';';

          CellValue := DBGridMouvements.Columns[i].Field.AsString;
          // Remplacer les guillemets par des doubles guillemets pour CSV
          CellValue := StringReplace(CellValue, '"', '""', [rfReplaceAll]);
          Line := Line + '"' + CellValue + '"';
        end;
        WriteLn(CSVFile, Line);
        FQueryMouvements.Next;
      end;

      ShowMessage('Export termin√© avec succ√®s : ' + SaveDialog.FileName);
    finally
      CloseFile(CSVFile);
    end;
  finally
    SaveDialog.Free;
  end;
end;

procedure TfrmProduitDetails.btnCloseClick(Sender: TObject);
begin
  Close;
end;
```

## Cr√©ation d'un formulaire de commande avec gestion du panier

Maintenant, cr√©ons un formulaire pour g√©rer les commandes des clients avec une interface intuitive de type "panier d'achat" :

```pascal
unit FormCommandeEdit;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls,
  Vcl.ComCtrls, Vcl.Buttons, Vcl.Grids, Vcl.DBGrids, Data.DB, FireDAC.Comp.Client,
  System.Actions, Vcl.ActnList, Vcl.Mask, Vcl.DBCtrls, JvExMask, JvToolEdit,
  JvBaseEdits, Commande, Client, dmDatabase, dmBusiness;

type
  TfrmCommandeEdit = class(TForm)
    pnlTop: TPanel;
    lblTitre: TLabel;
    pnlClient: TPanel;
    pnlBottom: TPanel;
    btnValider: TButton;
    btnAnnuler: TButton;
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    TabSheet2: TTabSheet;
    TabSheet3: TTabSheet;
    pnlClient1: TPanel;
    pnlClient2: TPanel;
    pnlClient3: TPanel;
    lblReference: TLabel;
    edtReference: TEdit;
    lblClient: TLabel;
    cboClient: TDBLookupComboBox;
    btnNouveauClient: TSpeedButton;
    lblDateCommande: TLabel;
    dtpDateCommande: TDateTimePicker;
    lblDateLivraison: TLabel;
    dtpDateLivraison: TDateTimePicker;
    lblStatut: TLabel;
    cboStatut: TComboBox;
    lblVendeur: TLabel;
    cboVendeur: TDBLookupComboBox;
    gbAdresseLivraison: TGroupBox;
    memoAdresseLivraison: TMemo;
    btnCopierAdresseClient: TButton;
    btnPrecedent1: TButton;
    btnSuivant1: TButton;
    pnlRechercherProduit: TPanel;
    lblRechercherProduit: TLabel;
    edtRechercheProduit: TEdit;
    btnRechercherProduit: TSpeedButton;
    StringGrid1: TStringGrid;
    pnlDetailsProduit: TPanel;
    lblProduitSelectionne: TLabel;
    lblPrixUnitaire: TLabel;
    lblQuantiteStock: TLabel;
    lblQuantite: TLabel;
    edtQuantite: TJvCalcEdit;
    lblRemise: TLabel;
    edtRemise: TJvCalcEdit;
    btnAjouterProduit: TButton;
    pnlLignesCommande: TPanel;
    StringGrid2: TStringGrid;
    pnlActionsLigne: TPanel;
    btnModifierLigne: TButton;
    btnSupprimerLigne: TButton;
    btnPrecedent2: TButton;
    btnSuivant2: TButton;
    pnlResume: TPanel;
    lblResume: TLabel;
    lblTotalHT: TLabel;
    lblTotalTVA: TLabel;
    lblTotalTTC: TLabel;
    lblPaiement: TLabel;
    cboPaiement: TComboBox;
    lblFraisPort: TLabel;
    edtFraisPort: TJvCalcEdit;
    memoCommentaires: TMemo;
    lblCommentaires: TLabel;
    lblAcompte: TLabel;
    edtAcompte: TJvCalcEdit;
    DataSource1: TDataSource;
    DataSource2: TDataSource;
    ActionList1: TActionList;
    actEnregistrer: TAction;
    actAnnuler: TAction;
    actRechercherProduit: TAction;
    actAjouterProduit: TAction;
    actModifierLigne: TAction;
    actSupprimerLigne: TAction;
    actNouveauClient: TAction;
    actCopierAdresseClient: TAction;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure actRechercherProduitExecute(Sender: TObject);
    procedure StringGrid1SelectCell(Sender: TObject; ACol, ARow: Integer;
      var CanSelect: Boolean);
    procedure actAjouterProduitExecute(Sender: TObject);
    procedure actModifierLigneExecute(Sender: TObject);
    procedure actSupprimerLigneExecute(Sender: TObject);
    procedure btnSuivant1Click(Sender: TObject);
    procedure btnPrecedent2Click(Sender: TObject);
    procedure btnSuivant2Click(Sender: TObject);
    procedure actEnregistrerExecute(Sender: TObject);
    procedure actAnnulerExecute(Sender: TObject);
    procedure actNouveauClientExecute(Sender: TObject);
    procedure actCopierAdresseClientExecute(Sender: TObject);
    procedure cboPaiementChange(Sender: TObject);
    procedure edtRemiseChange(Sender: TObject);
    procedure edtQuantiteChange(Sender: TObject);
    procedure edtFraisPortChange(Sender: TObject);
    procedure StringGrid2SelectCell(Sender: TObject; ACol, ARow: Integer;
      var CanSelect: Boolean);
  private
    { D√©clarations priv√©es }
    FCommande: TCommande;
    FMode: string; // 'Add' ou 'Edit'
    FProduitSelectionneID: Integer;
    FProduitSelectionnePrix: Double;
    FProduitSelectionneStock: Integer;
    FLigneSelectionnee: Integer;
    FQueryProduits: TFDQuery;

    procedure InitializeGrids;
    procedure LoadClients;
    procedure LoadVendeurs;
    procedure LoadCommande;
    procedure SaveCommande;
    procedure CalculerTotaux;
    procedure AjouterLigne(ProduitID: Integer; Reference, Designation: string;
      Quantite: Integer; PrixUnitaire, Remise: Double);
    procedure ModifierLigne(ARow: Integer; Quantite: Integer; Remise: Double);
    procedure SupprimerLigne(ARow: Integer);
    procedure MettreAJourDetailsProduit;
    function VerifierFormulaire: Boolean;
  public
    { D√©clarations publiques }
    procedure InitAdd;
    procedure InitEdit(ACommandeID: Integer);
  end;

var
  frmCommandeEdit: TfrmCommandeEdit;

implementation

{$R *.dfm}

uses
  FormClientEdit, System.Math, System.UITypes;

procedure TfrmCommandeEdit.FormCreate(Sender: TObject);
begin
  FCommande := TCommande.Create;
  FMode := 'Add';
  FProduitSelectionneID := 0;
  FProduitSelectionnePrix := 0;
  FProduitSelectionneStock := 0;
  FLigneSelectionnee := 0;
  FQueryProduits := nil;

  // Initialiser les contr√¥les
  dtpDateCommande.Date := Date;
  dtpDateLivraison.Date := Date + 7; // Par d√©faut, livraison dans 1 semaine

  // Initialiser les statuts
  cboStatut.Items.Clear;
  cboStatut.Items.Add('En attente');
  cboStatut.Items.Add('Valid√©e');
  cboStatut.Items.Add('En pr√©paration');
  cboStatut.Items.Add('Exp√©di√©e');
  cboStatut.Items.Add('Livr√©e');
  cboStatut.Items.Add('Annul√©e');
  cboStatut.ItemIndex := 0;

  // Initialiser les modes de paiement
  cboPaiement.Items.Clear;
  cboPaiement.Items.Add('Virement bancaire');
  cboPaiement.Items.Add('Carte bancaire');
  cboPaiement.Items.Add('Ch√®que');
  cboPaiement.Items.Add('Esp√®ces');
  cboPaiement.ItemIndex := 0;

  // Initialiser les grilles
  InitializeGrids;

  // Charger les clients et vendeurs
  LoadClients;
  LoadVendeurs;

  // Afficher le premier onglet
  PageControl1.ActivePageIndex := 0;
end;

procedure TfrmCommandeEdit.FormDestroy(Sender: TObject);
begin
  FCommande.Free;

  if Assigned(FQueryProduits) then
    FQueryProduits.Free;
end;

procedure TfrmCommandeEdit.InitializeGrids;
begin
  // Grille des produits (recherche)
  with StringGrid1 do
  begin
    ColCount := 5;
    RowCount := 2;
    FixedRows := 1;

    Cells[0, 0] := 'ID';
    Cells[1, 0] := 'R√©f√©rence';
    Cells[2, 0] := 'D√©signation';
    Cells[3, 0] := 'Prix HT';
    Cells[4, 0] := 'Stock';

    ColWidths[0] := 40;
    ColWidths[1] := 100;
    ColWidths[2] := 300;
    ColWidths[3] := 80;
    ColWidths[4] := 60;

    // Effacer la premi√®re ligne de donn√©es
    Cells[0, 1] := '';
    Cells[1, 1] := '';
    Cells[2, 1] := '';
    Cells[3, 1] := '';
    Cells[4, 1] := '';
  end;

  // Grille des lignes de commande
  with StringGrid2 do
  begin
    ColCount := 6;
    RowCount := 2;
    FixedRows := 1;

    Cells[0, 0] := 'ID';
    Cells[1, 0] := 'R√©f√©rence';
    Cells[2, 0] := 'D√©signation';
    Cells[3, 0] := 'Quantit√©';
    Cells[4, 0] := 'Prix unitaire';
    Cells[5, 0] := 'Total HT';

    ColWidths[0] := 40;
    ColWidths[1] := 100;
    ColWidths[2] := 300;
    ColWidths[3] := 70;
    ColWidths[4] := 90;
    ColWidths[5] := 90;

    // Effacer la premi√®re ligne de donn√©es
    Cells[0, 1] := '';
    Cells[1, 1] := '';
    Cells[2, 1] := '';
    Cells[3, 1] := '';
    Cells[4, 1] := '';
    Cells[5, 1] := '';
  end;
end;

procedure TfrmCommandeEdit.LoadClients;
var
  Query: TFDQuery;
begin
  // Charger la liste des clients pour le DBLookupComboBox
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text :=
      'SELECT ClientID, CONCAT(Nom, '' '', Prenom, IFNULL(CONCAT('' - '', Societe), '''')) AS NomComplet ' +
      'FROM Clients ORDER BY Nom, Prenom';
    Query.Open;

    DataSource1.DataSet := Query;
    cboClient.ListSource := DataSource1;
    cboClient.ListField := 'NomComplet';
    cboClient.KeyField := 'ClientID';
  except
    on E: Exception do
    begin
      ShowMessage('Erreur lors du chargement des clients : ' + E.Message);
      Query.Free;
    end;
  end;
end;

procedure TfrmCommandeEdit.LoadVendeurs;
var
  Query: TFDQuery;
begin
  // Charger la liste des vendeurs (utilisateurs)
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text :=
      'SELECT UtilisateurID, CONCAT(Nom, '' '', Prenom) AS NomComplet ' +
      'FROM Utilisateurs WHERE Actif = TRUE ORDER BY Nom, Prenom';
    Query.Open;

    DataSource2.DataSet := Query;
    cboVendeur.ListSource := DataSource2;
    cboVendeur.ListField := 'NomComplet';
    cboVendeur.KeyField := 'UtilisateurID';

    // Par d√©faut, s√©lectionner l'utilisateur courant (√† impl√©menter)
  except
    on E: Exception do
    begin
      ShowMessage('Erreur lors du chargement des vendeurs : ' + E.Message);
      Query.Free;
    end;
  end;
end;

procedure TfrmCommandeEdit.actRechercherProduitExecute(Sender: TObject);
var
  TermeRecherche: string;
  Row: Integer;
begin
  TermeRecherche := Trim(edtRechercheProduit.Text);
  if TermeRecherche = '' then
  begin
    ShowMessage('Veuillez saisir un terme de recherche.');
    Exit;
  end;

  // R√©initialiser la grille
  StringGrid1.RowCount := 2;
  for Row := 0 to StringGrid1.ColCount - 1 do
    StringGrid1.Cells[Row, 1] := '';

  // Lib√©rer la requ√™te pr√©c√©dente si existante
  if Assigned(FQueryProduits) then
    FQueryProduits.Free;

  // Cr√©er la nouvelle requ√™te
  FQueryProduits := TFDQuery.Create(nil);
  FQueryProduits.Connection := DataModuleDB.FDConnection;
  FQueryProduits.SQL.Text :=
    'SELECT p.ProduitID, p.Reference, p.Designation, p.PrixVente, ' +
    'IFNULL(s.QuantiteDisponible, 0) AS QuantiteDisponible ' +
    'FROM Produits p ' +
    'LEFT JOIN Stock s ON p.ProduitID = s.ProduitID ' +
    'WHERE p.Actif = TRUE AND ' +
    '(p.Reference LIKE :Terme OR p.Designation LIKE :Terme) ' +
    'ORDER BY p.Designation';
  FQueryProduits.ParamByName('Terme').AsString := '%' + TermeRecherche + '%';
  FQueryProduits.Open;

  // Remplir la grille avec les r√©sultats
  Row := 1;
  while not FQueryProduits.Eof do
  begin
    if Row >= StringGrid1.RowCount then
      StringGrid1.RowCount := StringGrid1.RowCount + 1;

    StringGrid1.Cells[0, Row] := FQueryProduits.FieldByName('ProduitID').AsString;
    StringGrid1.Cells[1, Row] := FQueryProduits.FieldByName('Reference').AsString;
    StringGrid1.Cells[2, Row] := FQueryProduits.FieldByName('Designation').AsString;
    StringGrid1.Cells[3, Row] := FormatFloat('#,##0.00 ‚Ç¨', FQueryProduits.FieldByName('PrixVente').AsFloat);
    StringGrid1.Cells[4, Row] := FQueryProduits.FieldByName('QuantiteDisponible').AsString;

    Inc(Row);
    FQueryProduits.Next;
  end;

  // Si aucun r√©sultat
  if FQueryProduits.RecordCount = 0 then
  begin
    ShowMessage('Aucun produit trouv√© avec ce terme de recherche.');
    StringGrid1.RowCount := 2; // Garder une ligne vide
  end;
end;

procedure TfrmCommandeEdit.StringGrid1SelectCell(Sender: TObject; ACol, ARow: Integer;
  var CanSelect: Boolean);
begin
  // S√©lection d'un produit dans la grille de recherche
  if (ARow > 0) and (ARow < StringGrid1.RowCount) and (StringGrid1.Cells[0, ARow] <> '') then
  begin
    FProduitSelectionneID := StrToIntDef(StringGrid1.Cells[0, ARow], 0);
    FProduitSelectionnePrix := StrToFloatDef(StringReplace(StringGrid1.Cells[3, ARow], ' ‚Ç¨', '', []), 0);
    FProduitSelectionneStock := StrToIntDef(StringGrid1.Cells[4, ARow], 0);

    // Mettre √† jour les informations
    MettreAJourDetailsProduit;
  end
  else
  begin
    FProduitSelectionneID := 0;
    FProduitSelectionnePrix := 0;
    FProduitSelectionneStock := 0;

    // R√©initialiser les informations
    lblProduitSelectionne.Caption := 'Aucun produit s√©lectionn√©';
    lblPrixUnitaire.Caption := 'Prix unitaire : 0,00 ‚Ç¨';
    lblQuantiteStock.Caption := 'Stock disponible : 0';
    edtQuantite.Value := 1;
    edtRemise.Value := 0;
  end;

  // Mettre √† jour le bouton d'ajout
  actAjouterProduit.Enabled := FProduitSelectionneID > 0;
end;

procedure TfrmCommandeEdit.MettreAJourDetailsProduit;
begin
  if FProduitSelectionneID > 0 then
  begin
    lblProduitSelectionne.Caption := 'Produit : ' + StringGrid1.Cells[2, StringGrid1.Selection.Top];
    lblPrixUnitaire.Caption := 'Prix unitaire : ' + FormatFloat('#,##0.00 ‚Ç¨', FProduitSelectionnePrix);
    lblQuantiteStock.Caption := 'Stock disponible : ' + IntToStr(FProduitSelectionneStock);

    // Par d√©faut, quantit√© = 1 et remise = 0%
    edtQuantite.Value := 1;
    edtRemise.Value := 0;

    // Limiter la quantit√© au stock disponible
    edtQuantite.MaxValue := FProduitSelectionneStock;

    // Mettre √† jour le bouton d'ajout
    actAjouterProduit.Enabled := (FProduitSelectionneID > 0) and (FProduitSelectionneStock > 0);
  end;
end;

procedure TfrmCommandeEdit.actAjouterProduitExecute(Sender: TObject);
var
  Quantite: Integer;
  Remise: Double;
  Reference, Designation: string;
begin
  if FProduitSelectionneID <= 0 then
  begin
    ShowMessage('Veuillez s√©lectionner un produit.');
    Exit;
  end;

  Quantite := Round(edtQuantite.Value);
  if Quantite <= 0 then
  begin
    ShowMessage('La quantit√© doit √™tre sup√©rieure √† 0.');
    edtQuantite.SetFocus;
    Exit;
  end;

  if Quantite > FProduitSelectionneStock then
  begin
    ShowMessage('La quantit√© demand√©e d√©passe le stock disponible.');
    edtQuantite.SetFocus;
    Exit;
  end;

  Remise := edtRemise.Value;
  if (Remise < 0) or (Remise > 100) then
  begin
    ShowMessage('La remise doit √™tre comprise entre 0 et 100%.');
    edtRemise.SetFocus;
    Exit;
  end;

  // R√©cup√©rer les informations du produit
  Reference := StringGrid1.Cells[1, StringGrid1.Selection.Top];
  Designation := StringGrid1.Cells[2, StringGrid1.Selection.Top];

  // Ajouter la ligne √† la grille des produits command√©s
  AjouterLigne(FProduitSelectionneID, Reference, Designation, Quantite, FProduitSelectionnePrix, Remise);

  // Recalculer les totaux
  CalculerTotaux;

  // Message de confirmation
  ShowMessage('Produit ajout√© au panier.');

  // R√©initialiser la s√©lection
  FProduitSelectionneID := 0;
  FProduitSelectionnePrix := 0;
  FProduitSelectionneStock := 0;
  lblProduitSelectionne.Caption := 'Aucun produit s√©lectionn√©';
  lblPrixUnitaire.Caption := 'Prix unitaire : 0,00 ‚Ç¨';
  lblQuantiteStock.Caption := 'Stock disponible : 0';
  edtQuantite.Value := 1;
  edtRemise.Value := 0;
  actAjouterProduit.Enabled := False;
end;

procedure TfrmCommandeEdit.AjouterLigne(ProduitID: Integer; Reference, Designation: string;
  Quantite: Integer; PrixUnitaire, Remise: Double);
var
  Row: Integer;
  TotalHT: Double;
begin
  // V√©rifier si le produit est d√©j√† dans la commande
  for Row := 1 to StringGrid2.RowCount - 1 do
  begin
    if (StringGrid2.Cells[0, Row] <> '') and
       (StrToInt(StringGrid2.Cells[0, Row]) = ProduitID) then
    begin
      // Le produit existe d√©j√†, on met √† jour la quantit√©
      Quantite := Quantite + StrToInt(StringGrid2.Cells[3, Row]);
      ModifierLigne(Row, Quantite, Remise);
      Exit;
    end;
  end;

  // Trouver la premi√®re ligne vide
  Row := 1;
  while (Row < StringGrid2.RowCount) and (StringGrid2.Cells[0, Row] <> '') do
    Inc(Row);

  // Si n√©cessaire, ajouter une nouvelle ligne
  if Row = StringGrid2.RowCount then
    StringGrid2.RowCount := StringGrid2.RowCount + 1;

  // Calculer le total HT
  TotalHT := Quantite * PrixUnitaire * (1 - Remise / 100);

  // Remplir la ligne
  StringGrid2.Cells[0, Row] := IntToStr(ProduitID);
  StringGrid2.Cells[1, Row] := Reference;
  StringGrid2.Cells[2, Row] := Designation;
  StringGrid2.Cells[3, Row] := IntToStr(Quantite);
  StringGrid2.Cells[4, Row] := FormatFloat('#,##0.00 ‚Ç¨', PrixUnitaire);
  StringGrid2.Cells[5, Row] := FormatFloat('#,##0.00 ‚Ç¨', TotalHT);

  // Tag pour stocker la remise (non visible dans la grille)
  StringGrid2.Objects[3, Row] := TObject(Round(Remise * 100)); // Stocker en centi√®mes
end;

procedure TfrmCommandeEdit.ModifierLigne(ARow: Integer; Quantite: Integer; Remise: Double);
var
  PrixUnitaire, TotalHT: Double;
begin
  // Extraire le prix unitaire
  PrixUnitaire := StrToFloatDef(StringReplace(StringGrid2.Cells[4, ARow], ' ‚Ç¨', '', []), 0);

  // Calculer le total HT
  TotalHT := Quantite * PrixUnitaire * (1 - Remise / 100);

  // Mettre √† jour la ligne
  StringGrid2.Cells[3, ARow] := IntToStr(Quantite);
  StringGrid2.Cells[5, ARow] := FormatFloat('#,##0.00 ‚Ç¨', TotalHT);

  // Stocker la remise
  StringGrid2.Objects[3, ARow] := TObject(Round(Remise * 100));
end;

procedure TfrmCommandeEdit.SupprimerLigne(ARow: Integer);
var
  i, j: Integer;
begin
  // Supprimer la ligne en d√©calant toutes les lignes suivantes
  for i := ARow to StringGrid2.RowCount - 2 do
    for j := 0 to StringGrid2.ColCount - 1 do
    begin
      StringGrid2.Cells[j, i] := StringGrid2.Cells[j, i + 1];
      if j = 3 then // Colonne avec l'objet pour la remise
        StringGrid2.Objects[j, i] := StringGrid2.Objects[j, i + 1];
    end;

  // Effacer la derni√®re ligne
  for j := 0 to StringGrid2.ColCount - 1 do
  begin
    StringGrid2.Cells[j, StringGrid2.RowCount - 1] := '';
    if j = 3 then
      StringGrid2.Objects[j, StringGrid2.RowCount - 1] := nil;
  end;

  // Si la grille ne contient plus qu'une ligne vide (en plus de l'en-t√™te), r√©duire le nombre de lignes
  if (StringGrid2.RowCount > 2) and (StringGrid2.Cells[0, StringGrid2.RowCount - 1] = '') and
     (StringGrid2.Cells[0, StringGrid2.RowCount - 2] = '') then
    StringGrid2.RowCount := StringGrid2.RowCount - 1;

  // R√©initialiser la ligne s√©lectionn√©e
  FLigneSelectionnee := 0;

  // Mettre √† jour les boutons
  actModifierLigne.Enabled := False;
  actSupprimerLigne.Enabled := False;
end;

procedure TfrmCommandeEdit.CalculerTotaux;
var
  Row: Integer;
  TotalHT, TotalTVA, TotalTTC: Double;
begin
  TotalHT := 0;

  // Calculer le total HT √† partir des lignes de commande
  for Row := 1 to StringGrid2.RowCount - 1 do
  begin
    if StringGrid2.Cells[0, Row] <> '' then
      TotalHT := TotalHT + StrToFloatDef(StringReplace(StringGrid2.Cells[5, Row], ' ‚Ç¨', '', []), 0);
  end;

  // Ajouter les frais de port
  TotalHT := TotalHT + edtFraisPort.Value;

  // Calculer la TVA (supposons 20% pour simplifier)
  TotalTVA := TotalHT * 0.2;

  // Calculer le total TTC
  TotalTTC := TotalHT + TotalTVA;

  // Mettre √† jour les labels
  lblTotalHT.Caption := 'Total HT : ' + FormatFloat('#,##0.00 ‚Ç¨', TotalHT);
  lblTotalTVA.Caption := 'TVA : ' + FormatFloat('#,##0.00 ‚Ç¨', TotalTVA);
  lblTotalTTC.Caption := 'Total TTC : ' + FormatFloat('#,##0.00 ‚Ç¨', TotalTTC);

  // Stocker dans l'objet commande
  FCommande.MontantHT := TotalHT;
  FCommande.MontantTTC := TotalTTC;
  FCommande.FraisPort := edtFraisPort.Value;

  // Mettre √† jour le reste √† payer
  if edtAcompte.Value > 0 then
  begin
    var ResteAPayer := TotalTTC - edtAcompte.Value;
    lblTotalTTC.Caption := lblTotalTTC.Caption + ' (Reste √† payer : ' +
      FormatFloat('#,##0.00 ‚Ç¨', ResteAPayer) + ')';
  end;
end;

procedure TfrmCommandeEdit.StringGrid2SelectCell(Sender: TObject; ACol, ARow: Integer;
  var CanSelect: Boolean);
begin
  // S√©lection d'une ligne dans la grille des produits command√©s
  if (ARow > 0) and (ARow < StringGrid2.RowCount) and (StringGrid2.Cells[0, ARow] <> '') then
  begin
    FLigneSelectionnee := ARow;

    // Activer les boutons d'action
    actModifierLigne.Enabled := True;
    actSupprimerLigne.Enabled := True;
  end
  else
  begin
    FLigneSelectionnee := 0;

    // D√©sactiver les boutons d'action
    actModifierLigne.Enabled := False;
    actSupprimerLigne.Enabled := False;
  end;
end;

procedure TfrmCommandeEdit.actModifierLigneExecute(Sender: TObject);
var
  Quantite: Integer;
  Remise: Double;
  ProduitID: Integer;
begin
  if FLigneSelectionnee <= 0 then
    Exit;

  // R√©cup√©rer les valeurs actuelles
  ProduitID := StrToIntDef(StringGrid2.Cells[0, FLigneSelectionnee], 0);
  Quantite := StrToIntDef(StringGrid2.Cells[3, FLigneSelectionnee], 0);

  // La remise est stock√©e dans l'objet associ√© √† la cellule
  Remise := Integer(StringGrid2.Objects[3, FLigneSelectionnee]) / 100;

  // Demander les nouvelles valeurs
  if InputQuery('Modifier la ligne', 'Nouvelle quantit√© :', Quantite) and
     InputQuery('Modifier la ligne', 'Nouvelle remise (%) :', Remise) then
  begin
    if Quantite <= 0 then
    begin
      ShowMessage('La quantit√© doit √™tre sup√©rieure √† 0.');
      Exit;
    end;

    if (Remise < 0) or (Remise > 100) then
    begin
      ShowMessage('La remise doit √™tre comprise entre 0 et 100%.');
      Exit;
    end;

    // Mettre √† jour la ligne
    ModifierLigne(FLigneSelectionnee, Quantite, Remise);

    // Recalculer les totaux
    CalculerTotaux;
  end;
end;

procedure TfrmCommandeEdit.actSupprimerLigneExecute(Sender: TObject);
begin
  if FLigneSelectionnee <= 0 then
    Exit;

  if MessageDlg('√ätes-vous s√ªr de vouloir supprimer cette ligne ?',
    mtConfirmation, [mbYes, mbNo], 0) = mrYes then
  begin
    // Supprimer la ligne
    SupprimerLigne(FLigneSelectionnee);

    // Recalculer les totaux
    CalculerTotaux;
  end;
end;

procedure TfrmCommandeEdit.btnSuivant1Click(Sender: TObject);
begin
  // Valider les informations du premier onglet
  if Trim(edtReference.Text) = '' then
  begin
    ShowMessage('Veuillez saisir une r√©f√©rence pour la commande.');
    edtReference.SetFocus;
    Exit;
  end;

  if cboClient.KeyValue = null then
  begin
    ShowMessage('Veuillez s√©lectionner un client.');
    cboClient.SetFocus;
    Exit;
  end;

  if cboVendeur.KeyValue = null then
  begin
    ShowMessage('Veuillez s√©lectionner un vendeur.');
    cboVendeur.SetFocus;
    Exit;
  end;

  // Passer √† l'onglet suivant
  PageControl1.ActivePageIndex := 1;
end;

procedure TfrmCommandeEdit.btnPrecedent2Click(Sender: TObject);
begin
  // Revenir √† l'onglet pr√©c√©dent
  PageControl1.ActivePageIndex := 0;
end;

procedure TfrmCommandeEdit.btnSuivant2Click(Sender: TObject);
begin
  // V√©rifier qu'il y a au moins une ligne de commande
  if (StringGrid2.RowCount <= 2) and (StringGrid2.Cells[0, 1] = '') then
  begin
    ShowMessage('Veuillez ajouter au moins un produit √† la commande.');
    Exit;
  end;

  // Passer √† l'onglet suivant
  PageControl1.ActivePageIndex := 2;

  // Recalculer les totaux
  CalculerTotaux;
end;

procedure TfrmCommandeEdit.actNouveauClientExecute(Sender: TObject);
var
  Form: TfrmClientEdit;
begin
  Form := TfrmClientEdit.Create(Self);
  try
    Form.InitAdd;
    if Form.ShowModal = mrOk then
    begin
      // Recharger la liste des clients
      LoadClients;

      // S√©lectionner le nouveau client
      cboClient.KeyValue := Form.ClientID;
    end;
  finally
    Form.Free;
  end;
end;

procedure TfrmCommandeEdit.actCopierAdresseClientExecute(Sender: TObject);
var
  Query: TFDQuery;
  ClientID: Integer;
  Adresse: string;
begin
  if cboClient.KeyValue = null then
  begin
    ShowMessage('Veuillez d''abord s√©lectionner un client.');
    Exit;
  end;

  ClientID := Integer(cboClient.KeyValue);

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text :=
      'SELECT CONCAT(Nom, '' '', Prenom, CHAR(13), Adresse, CHAR(13), CodePostal, '' '', Ville) AS AdresseComplete ' +
      'FROM Clients WHERE ClientID = :ClientID';
    Query.ParamByName('ClientID').AsInteger := ClientID;
    Query.Open;

    if not Query.IsEmpty then
    begin
      Adresse := Query.FieldByName('AdresseComplete').AsString;
      memoAdresseLivraison.Text := Adresse;
    end;
  finally
    Query.Free;
  end;
end;

procedure TfrmCommandeEdit.edtQuantiteChange(Sender: TObject);
begin
  // Mettre √† jour le bouton d'ajout
  actAjouterProduit.Enabled := (FProduitSelectionneID > 0) and (edtQuantite.Value > 0);
end;

procedure TfrmCommandeEdit.edtRemiseChange(Sender: TObject);
begin
  // S'assurer que la remise est entre 0 et 100%
  if edtRemise.Value < 0 then
    edtRemise.Value := 0
  else if edtRemise.Value > 100 then
    edtRemise.Value := 100;
end;

procedure TfrmCommandeEdit.edtFraisPortChange(Sender: TObject);
begin
  // Recalculer les totaux
  CalculerTotaux;
end;

procedure TfrmCommandeEdit.cboPaiementChange(Sender: TObject);
begin
  // Activer/d√©sactiver le champ d'acompte selon le mode de paiement
  edtAcompte.Enabled := cboPaiement.ItemIndex > 0; // Tous sauf "Virement bancaire"

  if not edtAcompte.Enabled then
    edtAcompte.Value := 0;

  // Recalculer les totaux
  CalculerTotaux;
end;

procedure TfrmCommandeEdit.InitAdd;
begin
  FMode := 'Add';

  // D√©finir le titre
  lblTitre.Caption := 'Nouvelle commande';

  // G√©n√©rer une r√©f√©rence automatique
  edtReference.Text := 'CMD-' + FormatDateTime('yyyymmdd-hhnn', Now);

  // Initialiser les valeurs par d√©faut
  dtpDateCommande.Date := Date;
  dtpDateLivraison.Date := Date + 7;
  cboStatut.ItemIndex := 0; // En attente
  memoAdresseLivraison.Clear;

  // R√©initialiser la grille des produits
  StringGrid2.RowCount := 2;
  StringGrid2.Cells[0, 1] := '';
  StringGrid2.Cells[1, 1] := '';
  StringGrid2.Cells[2, 1] := '';
  StringGrid2.Cells[3, 1] := '';
  StringGrid2.Cells[4, 1] := '';
  StringGrid2.Cells[5, 1] := '';

  // R√©initialiser les totaux
  edtFraisPort.Value := 0;
  edtAcompte.Value := 0;
  memoCommentaires.Clear;

  CalculerTotaux;
end;

procedure TfrmCommandeEdit.InitEdit(ACommandeID: Integer);
begin
  FMode := 'Edit';

  // R√©cup√©rer la commande
  FCommande.Free;
  FCommande := DataModuleBusiness.CommandeRepository.ObtenirParID(ACommandeID);

  if FCommande = nil then
  begin
    ShowMessage('Commande non trouv√©e !');
    FCommande := TCommande.Create;
    Close;
    Exit;
  end;

  // D√©finir le titre
  lblTitre.Caption := 'Modifier la commande ' + FCommande.Reference;

  // Charger les informations de la commande
  LoadCommande;
end;

procedure TfrmCommandeEdit.LoadCommande;
var
  Query: TFDQuery;
  Row: Integer;
begin
  // Remplir les champs avec les informations de la commande
  edtReference.Text := FCommande.Reference;
  cboClient.KeyValue := FCommande.ClientID;
  dtpDateCommande.Date := FCommande.DateCommande;
  dtpDateLivraison.Date := FCommande.DateLivraison;

  // Trouver l'index du statut
  for Row := 0 to cboStatut.Items.Count - 1 do
  begin
    if cboStatut.Items[Row] = FCommande.Statut then
    begin
      cboStatut.ItemIndex := Row;
      Break;
    end;
  end;

  cboVendeur.KeyValue := FCommande.UtilisateurID;
  memoAdresseLivraison.Text := FCommande.AdresseLivraison;

  // Trouver l'index du mode de paiement
  for Row := 0 to cboPaiement.Items.Count - 1 do
  begin
    if cboPaiement.Items[Row] = FCommande.ModePaiement then
    begin
      cboPaiement.ItemIndex := Row;
      Break;
    end;
  end;

  edtFraisPort.Value := FCommande.FraisPort;
  memoCommentaires.Text := FCommande.Commentaires;

  // Charger les lignes de commande
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := DataModuleDB.FDConnection;
    Query.SQL.Text :=
      'SELECT l.*, p.Reference, p.Designation ' +
      'FROM LignesCommande l ' +
      'JOIN Produits p ON l.ProduitID = p.ProduitID ' +
      'WHERE l.CommandeID = :CommandeID ' +
      'ORDER BY l.LigneID';
    Query.ParamByName('CommandeID').AsInteger := FCommande.CommandeID;
    Query.Open;

    // R√©initialiser la grille
    StringGrid2.RowCount := 2;
    for Row := 0 to StringGrid2.ColCount - 1 do
      StringGrid2.Cells[Row, 1] := '';

    // Remplir la grille avec les lignes de commande
    Row := 1;
    while not Query.Eof do
    begin
      if Row >= StringGrid2.RowCount then
        StringGrid2.RowCount := StringGrid2.RowCount + 1;

      StringGrid2.Cells[0, Row] := Query.FieldByName('ProduitID').AsString;
      StringGrid2.Cells[1, Row] := Query.FieldByName('Reference').AsString;
      StringGrid2.Cells[2, Row] := Query.FieldByName('Designation').AsString;
      StringGrid2.Cells[3, Row] := Query.FieldByName('Quantite').AsString;
      StringGrid2.Cells[4, Row] := FormatFloat('#,##0.00 ‚Ç¨', Query.FieldByName('PrixUnitaire').AsFloat);

      // Calculer le total HT de la ligne
      var Quantite: Integer := Query.FieldByName('Quantite').AsInteger;
      var PrixUnitaire: Double := Query.FieldByName('PrixUnitaire').AsFloat;
      var Remise: Double := Query.FieldByName('Remise').AsFloat;
      var TotalHT: Double := Quantite * PrixUnitaire * (1 - Remise / 100);

      StringGrid2.Cells[5, Row] := FormatFloat('#,##0.00 ‚Ç¨', TotalHT);

      // Stocker la remise
      StringGrid2.Objects[3, Row] := TObject(Round(Remise * 100));

      Inc(Row);
      Query.Next;
    end;
  finally
    Query.Free;
  end;

  // Calculer les totaux
  CalculerTotaux;
end;

procedure TfrmCommandeEdit.SaveCommande;
var
  Query: TFDQuery;
  Row: Integer;
  CommandeID: Integer;
begin
  // Mettre √† jour les propri√©t√©s de la commande
  FCommande.Reference := edtReference.Text;
  FCommande.ClientID := Integer(cboClient.KeyValue);
  FCommande.DateCommande := dtpDateCommande.Date;
  FCommande.DateLivraison := dtpDateLivraison.Date;
  FCommande.Statut := cboStatut.Text;
  FCommande.UtilisateurID := Integer(cboVendeur.KeyValue);
  FCommande.AdresseLivraison := memoAdresseLivraison.Text;
  FCommande.ModePaiement := cboPaiement.Text;
  FCommande.FraisPort := edtFraisPort.Value;
  FCommande.Commentaires := memoCommentaires.Text;

  // Recalculer les totaux pour s'assurer qu'ils sont √† jour
  CalculerTotaux;

  try
    // D√©marrer une transaction
    DataModuleDB.FDTransaction.StartTransaction;

    try
      // Enregistrer l'en-t√™te de la commande
      if FMode = 'Add' then
      begin
        // Ins√©rer une nouvelle commande
        Query := TFDQuery.Create(nil);
        try
          Query.Connection := DataModuleDB.FDConnection;
          Query.SQL.Text :=
            'INSERT INTO Commandes (Reference, ClientID, DateCommande, DateLivraison, ' +
            'Statut, MontantHT, MontantTTC, FraisPort, AdresseLivraison, UtilisateurID, ' +
            'ModePaiement, Commentaires) ' +
            'VALUES (:Reference, :ClientID, :DateCommande, :DateLivraison, ' +
            ':Statut, :MontantHT, :MontantTTC, :FraisPort, :AdresseLivraison, :UtilisateurID, ' +
            ':ModePaiement, :Commentaires)';

          Query.ParamByName('Reference').AsString := FCommande.Reference;
          Query.ParamByName('ClientID').AsInteger := FCommande.ClientID;
          Query.ParamByName('DateCommande').AsDate := FCommande.DateCommande;
          Query.ParamByName('DateLivraison').AsDate := FCommande.DateLivraison;
          Query.ParamByName('Statut').AsString := FCommande.Statut;
          Query.ParamByName('MontantHT').AsFloat := FCommande.MontantHT;
          Query.ParamByName('MontantTTC').AsFloat := FCommande.MontantTTC;
          Query.ParamByName('FraisPort').AsFloat := FCommande.FraisPort;
          Query.ParamByName('AdresseLivraison').AsString := FCommande.AdresseLivraison;
          Query.ParamByName('UtilisateurID').AsInteger := FCommande.UtilisateurID;
          Query.ParamByName('ModePaiement').AsString := FCommande.ModePaiement;
          Query.ParamByName('Commentaires').AsString := FCommande.Commentaires;

          Query.ExecSQL;

          // R√©cup√©rer l'ID de la commande cr√©√©e
          CommandeID := DataModuleDB.FDConnection.GetLastAutoGenValue('CommandeID');
          FCommande.CommandeID := CommandeID;
        finally
          Query.Free;
        end;
      end
      else
      begin
        // Mettre √† jour une commande existante
        Query := TFDQuery.Create(nil);
        try
          Query.Connection := DataModuleDB.FDConnection;
          Query.SQL.Text :=
            'UPDATE Commandes SET ' +
            'Reference = :Reference, ' +
            'ClientID = :ClientID, ' +
            'DateCommande = :DateCommande, ' +
            'DateLivraison = :DateLivraison, ' +
            'Statut = :Statut, ' +
            'MontantHT = :MontantHT, ' +
            'MontantTTC = :MontantTTC, ' +
            'FraisPort = :FraisPort, ' +
            'AdresseLivraison = :AdresseLivraison, ' +
            'UtilisateurID = :UtilisateurID, ' +
            'ModePaiement = :ModePaiement, ' +
            'Commentaires = :Commentaires ' +
            'WHERE CommandeID = :CommandeID';

          Query.ParamByName('Reference').AsString := FCommande.Reference;
          Query.ParamByName('ClientID').AsInteger := FCommande.ClientID;
          Query.ParamByName('DateCommande').AsDate := FCommande.DateCommande;
          Query.ParamByName('DateLivraison').AsDate := FCommande.DateLivraison;
          Query.ParamByName('Statut').AsString := FCommande.Statut;
          Query.ParamByName('MontantHT').AsFloat := FCommande.MontantHT;
          Query.ParamByName('MontantTTC').AsFloat := FCommande.MontantTTC;
          Query.ParamByName('FraisPort').AsFloat := FCommande.FraisPort;
          Query.ParamByName('AdresseLivraison').AsString := FCommande.AdresseLivraison;
          Query.ParamByName('UtilisateurID').AsInteger := FCommande.UtilisateurID;
          Query.ParamByName('ModePaiement').AsString := FCommande.ModePaiement;
          Query.ParamByName('Commentaires').AsString := FCommande.Commentaires;
          Query.ParamByName('CommandeID').AsInteger := FCommande.CommandeID;

          Query.ExecSQL;

          CommandeID := FCommande.CommandeID;

          // Supprimer les anciennes lignes de commande
          Query.SQL.Text := 'DELETE FROM LignesCommande WHERE CommandeID = :CommandeID';
          Query.ParamByName('CommandeID').AsInteger := CommandeID;
          Query.ExecSQL;
        finally
          Query.Free;
        end;
      end;

      // Ins√©rer les lignes de commande
      Query := TFDQuery.Create(nil);
      try
        Query.Connection := DataModuleDB.FDConnection;
        Query.SQL.Text :=
          'INSERT INTO LignesCommande (CommandeID, ProduitID, Quantite, PrixUnitaire, Remise) ' +
          'VALUES (:CommandeID, :ProduitID, :Quantite, :PrixUnitaire, :Remise)';

        for Row := 1 to StringGrid2.RowCount - 1 do
        begin
          if StringGrid2.Cells[0, Row] = '' then
            Continue;

          var ProduitID: Integer := StrToInt(StringGrid2.Cells[0, Row]);
          var Quantite: Integer := StrToInt(StringGrid2.Cells[3, Row]);
          var PrixUnitaire: Double := StrToFloatDef(StringReplace(StringGrid2.Cells[4, Row], ' ‚Ç¨', '', []), 0);
          var Remise: Double := Integer(StringGrid2.Objects[3, Row]) / 100;

          Query.ParamByName('CommandeID').AsInteger := CommandeID;
          Query.ParamByName('ProduitID').AsInteger := ProduitID;
          Query.ParamByName('Quantite').AsInteger := Quantite;
          Query.ParamByName('PrixUnitaire').AsFloat := PrixUnitaire;
          Query.ParamByName('Remise').AsFloat := Remise;

          Query.ExecSQL;
        end;
      finally
        Query.Free;
      end;

      // Valider la transaction
      DataModuleDB.FDTransaction.Commit;

      ModalResult := mrOk;
    except
      on E: Exception do
      begin
        // Annuler la transaction en cas d'erreur
        DataModuleDB.FDTransaction.Rollback;
        ShowMessage('Erreur lors de l''enregistrement de la commande : ' + E.Message);
      end;
    end;
  except
    on E: Exception do
      ShowMessage('Erreur de transaction : ' + E.Message);
  end;
end;

function TfrmCommandeEdit.VerifierFormulaire: Boolean;
begin
  Result := False;

  // V√©rifier les informations de base
  if Trim(edtReference.Text) = '' then
  begin
    ShowMessage('Veuillez saisir une r√©f√©rence pour la commande.');
    PageControl1.ActivePageIndex := 0;
    edtReference.SetFocus;
    Exit;
  end;

  if cboClient.KeyValue = null then
  begin
    ShowMessage('Veuillez s√©lectionner un client.');
    PageControl1.ActivePageIndex := 0;
    cboClient.SetFocus;
    Exit;
  end;

  if cboVendeur.KeyValue = null then
  begin
    ShowMessage('Veuillez s√©lectionner un vendeur.');
    PageControl1.ActivePageIndex := 0;
    cboVendeur.SetFocus;
    Exit;
  end;

  // V√©rifier qu'il y a au moins une ligne de commande
  if (StringGrid2.RowCount <= 2) and (StringGrid2.Cells[0, 1] = '') then
  begin
    ShowMessage('Veuillez ajouter au moins un produit √† la commande.');
    PageControl1.ActivePageIndex := 1;
    Exit;
  end;

  // V√©rifier l'adresse de livraison
  if Trim(memoAdresseLivraison.Text) = '' then
  begin
    ShowMessage('Veuillez saisir une adresse de livraison.');
    PageControl1.ActivePageIndex := 0;
    memoAdresseLivraison.SetFocus;
    Exit;
  end;

  Result := True;
end;

procedure TfrmCommandeEdit.actEnregistrerExecute(Sender: TObject);
begin
  if not VerifierFormulaire then
    Exit;

  SaveCommande;
end;

procedure TfrmCommandeEdit.actAnnulerExecute(Sender: TObject);
begin
  // Demander confirmation si des modifications ont √©t√© apport√©es
  if (StringGrid2.RowCount > 2) or (StringGrid2.Cells[0, 1] <> '') then
  begin
    if MessageDlg('Annuler les modifications ?', mtConfirmation, [mbYes, mbNo], 0) = mrYes then
      ModalResult := mrCancel;
  end
  else
    ModalResult := mrCancel;
end;
```

## Am√©liorations visuelles pour une interface moderne

Pour finaliser notre interface utilisateur √©volu√©e, ajoutons quelques am√©liorations visuelles qui rendront notre application plus attrayante et professionnelle :

### 1. Utilisation de th√®mes visuels

Delphi inclut un syst√®me de th√®mes visuels qui peut transformer l'apparence de l'application. Pour impl√©menter un s√©lecteur de th√®mes, cr√©ez un nouveau menu dans le formulaire principal :

```pascal
procedure TfrmMain.InitializeThemes;
var
  StyleName: string;
  MenuItem: TMenuItem;
begin
  // Vider le menu existant
  mnuThemes.Clear;

  // Ajouter un √©l√©ment par style disponible
  for StyleName in TStyleManager.StyleNames do
  begin
    MenuItem := TMenuItem.Create(mnuThemes);
    MenuItem.Caption := StyleName;
    MenuItem.OnClick := ThemeMenuItemClick;
    MenuItem.RadioItem := True;
    MenuItem.GroupIndex := 1;
    MenuItem.Checked := TStyleManager.ActiveStyle.Name = StyleName;
    mnuThemes.Add(MenuItem);
  end;
end;

procedure TfrmMain.ThemeMenuItemClick(Sender: TObject);
begin
  if Sender is TMenuItem then
  begin
    TStyleManager.TrySetStyle(TMenuItem(Sender).Caption);

    // Mettre √† jour les coches dans le menu
    UpdateThemeMenu;

    // Sauvegarder le th√®me choisi dans les param√®tres
    SaveSettings;
  end;
end;

procedure TfrmMain.UpdateThemeMenu;
var
  i: Integer;
begin
  for i := 0 to mnuThemes.Count - 1 do
    mnuThemes.Items[i].Checked := mnuThemes.Items[i].Caption = TStyleManager.ActiveStyle.Name;
end;
```

### 2. Ajout d'ic√¥nes et d'images

Utilisez des ic√¥nes modernes pour am√©liorer la lisibilit√© :

```pascal
procedure TfrmMain.LoadIcons;
begin
  // Chargement des ic√¥nes pour la barre d'outils
  ImageList1.Clear;

  // Ajouter les ic√¥nes √† l'ImageList
  AddIconToImageList('client.png', ImageList1);
  AddIconToImageList('product.png', ImageList1);
  AddIconToImageList('order.png', ImageList1);
  AddIconToImageList('supplier.png', ImageList1);
  AddIconToImageList('category.png', ImageList1);
  AddIconToImageList('report.png', ImageList1);
  AddIconToImageList('settings.png', ImageList1);
  AddIconToImageList('exit.png', ImageList1);
end;

procedure TfrmMain.AddIconToImageList(const FileName: string; ImageList: TImageList);
var
  Bitmap: TBitmap;
  ResourcePath: string;
begin
  ResourcePath := ExtractFilePath(Application.ExeName) + 'Resources\Icons\' + FileName;

  if FileExists(ResourcePath) then
  begin
    Bitmap := TBitmap.Create;
    try
      Bitmap.LoadFromFile(ResourcePath);
      ImageList.Add(Bitmap, nil);
    finally
      Bitmap.Free;
    end;
  end;
end;
```

### 3. Utilisation d'animations et de transitions

Ajoutez des animations subtiles pour am√©liorer l'exp√©rience utilisateur :

```pascal
// Unit√© avec classes d'animation
unit Animations;

interface

uses
  System.SysUtils, System.Classes, Vcl.Forms, Vcl.Controls,
  System.Math, Winapi.Windows, Winapi.Messages;

type
  TAnimationType = (atFadeIn, atFadeOut, atSlideLeft, atSlideRight);

  TFormAnimation = class
  private
    FForm: TForm;
    FTimer: TTimer;
    FAnimationType: TAnimationType;
    FStep: Integer;
    FMaxSteps: Integer;
    FOnFinish: TNotifyEvent;

    procedure TimerTick(Sender: TObject);
  public
    constructor Create(AForm: TForm);
    destructor Destroy; override;

    procedure StartAnimation(AType: TAnimationType; ASteps: Integer = 10);
    property OnFinish: TNotifyEvent read FOnFinish write FOnFinish;
  end;

implementation

constructor TFormAnimation.Create(AForm: TForm);
begin
  inherited Create;
  FForm := AForm;
  FTimer := TTimer.Create(nil);
  FTimer.Enabled := False;
  FTimer.Interval := 15; // ~60fps
  FTimer.OnTimer := TimerTick;
  FStep := 0;
  FMaxSteps := 10;
end;

destructor TFormAnimation.Destroy;
begin
  FTimer.Free;
  inherited;
end;

procedure TFormAnimation.StartAnimation(AType: TAnimationType; ASteps: Integer = 10);
begin
  FAnimationType := AType;
  FMaxSteps := ASteps;
  FStep := 0;

  case FAnimationType of
    atFadeIn:
      begin
        FForm.AlphaBlend := True;
        FForm.AlphaBlendValue := 0;
      end;
    atFadeOut:
      begin
        FForm.AlphaBlend := True;
        FForm.AlphaBlendValue := 255;
      end;
    atSlideLeft, atSlideRight:
      begin
        // Aucune pr√©paration n√©cessaire
      end;
  end;

  FTimer.Enabled := True;
end;

procedure TFormAnimation.TimerTick(Sender: TObject);
var
  Alpha: Byte;
  NewLeft: Integer;
begin
  Inc(FStep);

  if FStep > FMaxSteps then
  begin
    FTimer.Enabled := False;

    // Finaliser l'animation
    case FAnimationType of
      atFadeIn:
        begin
          FForm.AlphaBlend := False;
        end;
      atFadeOut:
        begin
          if Assigned(FOnFinish) then
            FOnFinish(Self);
        end;
      atSlideLeft, atSlideRight:
        begin
          // Aucune finalisation n√©cessaire
        end;
    end;

    Exit;
  end;

  // Calculer les valeurs interm√©diaires
  case FAnimationType of
    atFadeIn:
      begin
        Alpha := Round(255 * (FStep / FMaxSteps));
        FForm.AlphaBlendValue := Alpha;
      end;
    atFadeOut:
      begin
        Alpha := Round(255 * (1 - FStep / FMaxSteps));
        FForm.AlphaBlendValue := Alpha;
      end;
    atSlideLeft:
      begin
        NewLeft := Round(FForm.Width * (1 - FStep / FMaxSteps));
        FForm.Left := FForm.Left - NewLeft div FMaxSteps;
      end;
    atSlideRight:
      begin
        NewLeft := Round(FForm.Width * (FStep / FMaxSteps));
        FForm.Left := FForm.Left + NewLeft div FMaxSteps;
      end;
  end;
end;

end.

// Utilisation dans un formulaire
procedure TfrmMain.ShowTabWithAnimation(AClass: TFormClass; const ATitle: string);
var
  Form: TForm;
  Animation: TFormAnimation;
begin
  // Cr√©er le formulaire
  Form := AClass.Create(Self);
  Form.Parent := TabSheet2;
  Form.BorderStyle := bsNone;
  Form.Align := alClient;

  // Pr√©parer l'animation
  Animation := TFormAnimation.Create(Form);
  try
    // Configurer et d√©marrer l'animation
    Animation.StartAnimation(atFadeIn, 15);

    // Afficher le formulaire
    Form.Show;

    // Mettre √† jour les onglets
    TabSheet2.Caption := ATitle;
    TabSheet2.TabVisible := True;
    PageControl1.ActivePage := TabSheet2;
    TabSheet2.Tag := NativeInt(Form);
  finally
    Animation.Free;
  end;
end;
```

### 4. Cr√©er des contr√¥les personnalis√©s

Pour un aspect unique, cr√©ez des contr√¥les personnalis√©s adapt√©s √† votre application :

```pascal
// Unit√© de bouton personnalis√© avec effet de survol
unit CustomButton;

interface

uses
  System.SysUtils, System.Classes, Vcl.Controls, Vcl.Graphics,
  Winapi.Windows, Winapi.Messages, Vcl.ExtCtrls, Vcl.Imaging.pngimage;

type
  TButtonState = (bsNormal, bsHover, bsDown);

  TCustomButton = class(TCustomControl)
  private
    FCaption: string;
    FNormalColor: TColor;
    FHoverColor: TColor;
    FDownColor: TColor;
    FTextColor: TColor;
    FButtonState: TButtonState;
    FOnClick: TNotifyEvent;
    FImage: TPicture;
    FImageAlignment: TAlignment;

    procedure SetCaption(const Value: string);
    procedure SetNormalColor(const Value: TColor);
    procedure SetHoverColor(const Value: TColor);
    procedure SetDownColor(const Value: TColor);
    procedure SetTextColor(const Value: TColor);
    procedure SetImage(const Value: TPicture);
    procedure SetImageAlignment(const Value: TAlignment);

    procedure CMMouseEnter(var Message: TMessage); message CM_MOUSEENTER;
    procedure CMMouseLeave(var Message: TMessage); message CM_MOUSELEAVE;
  protected
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure Click; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Caption: string read FCaption write SetCaption;
    property NormalColor: TColor read FNormalColor write SetNormalColor;
    property HoverColor: TColor read FHoverColor write SetHoverColor;
    property DownColor: TColor read FDownColor write SetDownColor;
    property TextColor: TColor read FTextColor write SetTextColor;
    property Image: TPicture read FImage write SetImage;
    property ImageAlignment: TAlignment read FImageAlignment write SetImageAlignment;
    property OnClick: TNotifyEvent read FOnClick write FOnClick;
    property Align;
    property Anchors;
    property Cursor;
    property Enabled;
    property Font;
    property ParentFont;
    property ParentShowHint;
    property PopupMenu;
    property ShowHint;
    property TabOrder;
    property TabStop;
    property Visible;
  end;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('Customs', [TCustomButton]);
end;

constructor TCustomButton.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 120;
  Height := 40;
  FCaption := 'Custom Button';
  FNormalColor := $00D1B499; // Couleur de base
  FHoverColor := $00E5C9B3;  // Couleur au survol
  FDownColor := $00BDA185;   // Couleur lorsque press√©
  FTextColor := clWhite;
  FButtonState := bsNormal;
  FImage := TPicture.Create;
  FImageAlignment := taLeftJustify;

  // Style de curseur pour indiquer que c'est un bouton
  Cursor := crHandPoint;
end;

destructor TCustomButton.Destroy;
begin
  FImage.Free;
  inherited;
end;

procedure TCustomButton.SetCaption(const Value: string);
begin
  if FCaption <> Value then
  begin
    FCaption := Value;
    Invalidate; // Redessiner le contr√¥le
  end;
end;

procedure TCustomButton.SetNormalColor(const Value: TColor);
begin
  if FNormalColor <> Value then
  begin
    FNormalColor := Value;
    Invalidate;
  end;
end;

procedure TCustomButton.SetHoverColor(const Value: TColor);
begin
  if FHoverColor <> Value then
  begin
    FHoverColor := Value;
    Invalidate;
  end;
end;

procedure TCustomButton.SetDownColor(const Value: TColor);
begin
  if FDownColor <> Value then
  begin
    FDownColor := Value;
    Invalidate;
  end;
end;

procedure TCustomButton.SetTextColor(const Value: TColor);
begin
  if FTextColor <> Value then
  begin
    FTextColor := Value;
    Invalidate;
  end;
end;

procedure TCustomButton.SetImage(const Value: TPicture);
begin
  FImage.Assign(Value);
  Invalidate;
end;

procedure TCustomButton.SetImageAlignment(const Value: TAlignment);
begin
  if FImageAlignment <> Value then
  begin
    FImageAlignment := Value;
    Invalidate;
  end;
end;

procedure TCustomButton.CMMouseEnter(var Message: TMessage);
begin
  FButtonState := bsHover;
  Invalidate;
end;

procedure TCustomButton.CMMouseLeave(var Message: TMessage);
begin
  FButtonState := bsNormal;
  Invalidate;
end;

procedure TCustomButton.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  inherited;
  if Button = mbLeft then
  begin
    FButtonState := bsDown;
    Invalidate;
  end;
end;

procedure TCustomButton.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  InsideControl: Boolean;
begin
  inherited;
  if Button = mbLeft then
  begin
    InsideControl := PtInRect(ClientRect, Point(X, Y));
    if InsideControl then
    begin
      FButtonState := bsHover;
      Click;
    end
    else
      FButtonState := bsNormal;
    Invalidate;
  end;
end;

procedure TCustomButton.Click;
begin
  inherited;
  if Assigned(FOnClick) then
    FOnClick(Self);
end;

procedure TCustomButton.Paint;
var
  R: TRect;
  TextR: TRect;
  ButtonColor: TColor;
  TextFormat: UINT;
  ImgLeft, ImgTop: Integer;
begin
  // D√©terminer la couleur du bouton selon l'√©tat
  case FButtonState of
    bsNormal: ButtonColor := FNormalColor;
    bsHover: ButtonColor := FHoverColor;
    bsDown: ButtonColor := FDownColor;
  end;

  // Dessiner le fond du bouton
  R := ClientRect;
  Canvas.Brush.Color := ButtonColor;
  Canvas.Pen.Color := ButtonColor;
  Canvas.Rectangle(R);

  // Dessiner l'image si pr√©sente
  if Assigned(FImage.Graphic) and not FImage.Graphic.Empty then
  begin
    ImgTop := (Height - FImage.Height) div 2;

    case FImageAlignment of
      taLeftJustify: ImgLeft := 5;
      taCenter: ImgLeft := (Width - FImage.Width) div 2;
      taRightJustify: ImgLeft := Width - FImage.Width - 5;
    end;

    Canvas.Draw(ImgLeft, ImgTop, FImage.Graphic);

    // Ajuster le rectangle pour le texte
    if FImageAlignment = taLeftJustify then
      R.Left := ImgLeft + FImage.Width + 5
    else if FImageAlignment = taRightJustify then
      R.Right := ImgLeft - 5;
  end;

  // Dessiner le texte
  Canvas.Font := Font;
  Canvas.Font.Color := FTextColor;
  TextR := R;
  TextFormat := DT_CENTER or DT_VCENTER or DT_SINGLELINE;
  DrawText(Canvas.Handle, PChar(FCaption), Length(FCaption), TextR, TextFormat);
end;

end.
```

### 5. Adaptation aux diff√©rentes r√©solutions d'√©cran

L'application doit s'adapter correctement aux diff√©rentes r√©solutions d'√©cran :

```pascal
procedure TfrmMain.FormCreate(Sender: TObject);
begin
  // R√©gler la position et la taille du formulaire
  AdjustFormForScreen;

  // Reste du code...
end;

procedure TfrmMain.AdjustFormForScreen;
const
  DESIGN_WIDTH = 1024;
  DESIGN_HEIGHT = 768;
var
  Scale: Double;
  NewWidth, NewHeight: Integer;
begin
  // D√©terminer le facteur d'√©chelle en fonction de la r√©solution de l'√©cran
  Scale := Min(Screen.Width / DESIGN_WIDTH, Screen.Height / DESIGN_HEIGHT);

  // √âviter une mise √† l'√©chelle excessive
  if Scale > 1.5 then
    Scale := 1.5
  else if Scale < 0.8 then
    Scale := 0.8;

  // Calculer les nouvelles dimensions
  NewWidth := Round(DESIGN_WIDTH * Scale);
  NewHeight := Round(DESIGN_HEIGHT * Scale);

  // Appliquer les dimensions
  Width := NewWidth;
  Height := NewHeight;

  // Centrer sur l'√©cran
  Left := (Screen.Width - Width) div 2;
  Top := (Screen.Height - Height) div 2;

  // Si l'√©cran est plus petit que le minimum, utiliser WindowState wsMaximized
  if (Screen.Width < 800) or (Screen.Height < 600) then
    WindowState := wsMaximized;
end;
```

### 6. Support haute r√©solution et √©crans HiDPI

Pour que l'application s'affiche correctement sur les √©crans haute r√©solution modernes :

```pascal
// Dans le fichier .dpr
{$R *.res}

{$SetPEFlags IMAGE_FILE_LARGE_ADDRESS_AWARE}
{$SetPEFlags IMAGE_FILE_DLL_SUPPORTS_VA_ALLOCATION}

// D√©claration d'application compatible DPI
{$R 'app.manifest'}

// Contenu typique de app.manifest :
// <application xmlns="urn:schemas-microsoft-com:asm.v3">
//   <windowsSettings>
//     <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true/pm</dpiAware>
//     <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
//   </windowsSettings>
// </application>

// Dans le code principal
procedure TApplication.Initialize;
begin
  inherited;
  Application.MainFormOnTaskbar := True;
  Application.ScalingMode := TScalingMode.smDPI;
  Application.ScalingPixelsMode := TScalingPixelsMode.spmNone;
  Application.ScaleForPPI(Screen.PixelsPerInch);
end;
```

## Gestion des param√®tres utilisateur

Pour personnaliser l'interface, impl√©mentons un syst√®me de stockage des pr√©f√©rences :

```pascal
unit SettingsManager;

interface

uses
  System.SysUtils, System.Classes, System.IniFiles, Vcl.Forms;

type
  TAppSettings = class
  private
    FIniFile: TIniFile;
    FThemeName: string;
    FSidebarVisible: Boolean;
    FStartMaximized: Boolean;

    procedure SetThemeName(const Value: string);
    procedure SetSidebarVisible(const Value: Boolean);
    procedure SetStartMaximized(const Value: Boolean);
  public
    constructor Create;
    destructor Destroy; override;

    procedure Load;
    procedure Save;

    property ThemeName: string read FThemeName write SetThemeName;
    property SidebarVisible: Boolean read FSidebarVisible write SetSidebarVisible;
    property StartMaximized: Boolean read FStartMaximized write SetStartMaximized;
  end;

var
  AppSettings: TAppSettings;

implementation

constructor TAppSettings.Create;
var
  SettingsPath: string;
begin
  inherited Create;

  // Cr√©er le dossier des param√®tres s'il n'existe pas
  SettingsPath := ExtractFilePath(Application.ExeName) + 'Settings';
  if not DirectoryExists(SettingsPath) then
    ForceDirectories(SettingsPath);

  // Cr√©er le fichier INI
  FIniFile := TIniFile.Create(SettingsPath + '\settings.ini');

  // Charger les param√®tres
  Load;
end;

destructor TAppSettings.Destroy;
begin
  Save;
  FIniFile.Free;
  inherited;
end;

procedure TAppSettings.Load;
begin
  // Interface
  FThemeName := FIniFile.ReadString('Interface', 'Theme', 'Windows');
  FSidebarVisible := FIniFile.ReadBool('Interface', 'SidebarVisible', True);
  FStartMaximized := FIniFile.ReadBool('Interface', 'StartMaximized', False);
end;

procedure TAppSettings.Save;
begin
  // Interface
  FIniFile.WriteString('Interface', 'Theme', FThemeName);
  FIniFile.WriteBool('Interface', 'SidebarVisible', FSidebarVisible);
  FIniFile.WriteBool('Interface', 'StartMaximized', FStartMaximized);

  // Forcer l'√©criture sur le disque
  FIniFile.UpdateFile;
end;

procedure TAppSettings.SetThemeName(const Value: string);
begin
  if FThemeName <> Value then
  begin
    FThemeName := Value;
    Save;
  end;
end;

procedure TAppSettings.SetSidebarVisible(const Value: Boolean);
begin
  if FSidebarVisible <> Value then
  begin
    FSidebarVisible := Value;
    Save;
  end;
end;

procedure TAppSettings.SetStartMaximized(const Value: Boolean);
begin
  if FStartMaximized <> Value then
  begin
    FStartMaximized := Value;
    Save;
  end;
end;

initialization
  AppSettings := TAppSettings.Create;

finalization
  AppSettings.Free;

end.
```

## Cr√©ation d'une barre de notifications

Pour informer l'utilisateur des √©v√©nements importants, ajoutons une barre de notifications :

```pascal
unit NotificationBar;

interface

uses
  System.SysUtils, System.Classes, Vcl.Controls, Vcl.Graphics,
  Winapi.Windows, Winapi.Messages, Vcl.ExtCtrls, Vcl.StdCtrls;

type
  TNotificationType = (ntInfo, ntWarning, ntError, ntSuccess);

  TNotificationBar = class(TPanel)
  private
    FLabel: TLabel;
    FCloseButton: TButton;
    FTimer: TTimer;
    FNotificationType: TNotificationType;
    FAutoHide: Boolean;
    FDisplayTime: Integer;

    procedure SetNotificationType(const Value: TNotificationType);
    procedure SetAutoHide(const Value: Boolean);
    procedure SetDisplayTime(const Value: Integer);
    procedure CloseButtonClick(Sender: TObject);
    procedure TimerTick(Sender: TObject);
  protected
    procedure Loaded; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure ShowNotification(const AMessage: string; AType: TNotificationType = ntInfo);
    procedure HideNotification;
  published
    property NotificationType: TNotificationType read FNotificationType write SetNotificationType;
    property AutoHide: Boolean read FAutoHide write SetAutoHide;
    property DisplayTime: Integer read FDisplayTime write SetDisplayTime;
  end;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('Customs', [TNotificationBar]);
end;

constructor TNotificationBar.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);

  // Configuration du panel
  Align := alTop;
  Height := 40;
  BevelOuter := bvNone;
  Caption := '';
  Visible := False;

  // Cr√©ation du label
  FLabel := TLabel.Create(Self);
  FLabel.Parent := Self;
  FLabel.Align := alClient;
  FLabel.Alignment := taCenter;
  FLabel.Layout := tlCenter;
  FLabel.AutoSize := False;
  FLabel.Transparent := True;
  FLabel.Font.Style := [fsBold];

  // Cr√©ation du bouton de fermeture
  FCloseButton := TButton.Create(Self);
  FCloseButton.Parent := Self;
  FCloseButton.Align := alRight;
  FCloseButton.Width := 40;
  FCloseButton.Caption := 'X';
  FCloseButton.OnClick := CloseButtonClick;

  // Cr√©ation du timer
  FTimer := TTimer.Create(Self);
  FTimer.Enabled := False;
  FTimer.Interval := 5000; // 5 secondes par d√©faut
  FTimer.OnTimer := TimerTick;

  // Valeurs par d√©faut
  FNotificationType := ntInfo;
  FAutoHide := True;
  FDisplayTime := 5000;

  // Appliquer le style initial
  SetNotificationType(FNotificationType);
end;

destructor TNotificationBar.Destroy;
begin
  FTimer.Free;
  inherited;
end;

procedure TNotificationBar.Loaded;
begin
  inherited;
  // Configuration apr√®s chargement des propri√©t√©s
  SetNotificationType(FNotificationType);
end;

procedure TNotificationBar.SetNotificationType(const Value: TNotificationType);
begin
  FNotificationType := Value;

  // D√©finir les couleurs selon le type
  case FNotificationType of
    ntInfo:
      begin
        Color := $00D8F0FF; // Bleu clair
        FLabel.Font.Color := $00994C00; // Bleu fonc√©
      end;
    ntWarning:
      begin
        Color := $00C8FFFF; // Jaune clair
        FLabel.Font.Color := $00008CFF; // Orange fonc√©
      end;
    ntError:
      begin
        Color := $00C8D0FF; // Rouge clair
        FLabel.Font.Color := $00000080; // Rouge fonc√©
      end;
    ntSuccess:
      begin
        Color := $00D0FFD0; // Vert clair
        FLabel.Font.Color := $00006400; // Vert fonc√©
      end;
  end;
end;

procedure TNotificationBar.SetAutoHide(const Value: Boolean);
begin
  FAutoHide := Value;
end;

procedure TNotificationBar.SetDisplayTime(const Value: Integer);
begin
  FDisplayTime := Value;
  FTimer.Interval := FDisplayTime;
end;

procedure TNotificationBar.ShowNotification(const AMessage: string; AType: TNotificationType = ntInfo);
begin
  // Configurer le message et le type
  FLabel.Caption := AMessage;
  SetNotificationType(AType);

  // Afficher la notification
  Visible := True;
  BringToFront;

  // D√©marrer le timer si AutoHide est activ√©
  if FAutoHide then
  begin
    FTimer.Interval := FDisplayTime;
    FTimer.Enabled := True;
  end;
end;

procedure TNotificationBar.HideNotification;
begin
  Visible := False;
  FTimer.Enabled := False;
end;

procedure TNotificationBar.CloseButtonClick(Sender: TObject);
begin
  HideNotification;
end;

procedure TNotificationBar.TimerTick(Sender: TObject);
begin
  HideNotification;
end;

end.
```

## Conclusion

L'interface utilisateur est l'√©l√©ment avec lequel vos utilisateurs interagissent directement. Une interface bien con√ßue, intuitive et attrayante peut faire la diff√©rence entre une application appr√©ci√©e et une application d√©laiss√©e.

Dans cette partie, nous avons d√©velopp√© :

- Une interface utilisateur structur√©e avec un menu principal, des onglets et une barre lat√©rale
- Des formulaires sophistiqu√©s pour la gestion des produits et des commandes
- Un tableau de bord informatif pour visualiser les donn√©es importantes
- Des am√©liorations visuelles avec th√®mes, ic√¥nes et animations
- Des fonctionnalit√©s d'export pour la productivit√© des utilisateurs
- Une adaptation aux diff√©rentes r√©solutions d'√©cran

### Bonnes pratiques pour l'interface utilisateur

Voici quelques principes √† garder √† l'esprit lors de la conception d'interfaces :

1. **Coh√©rence** : Utilisez les m√™mes conventions et √©l√©ments dans toute l'application
2. **Simplicit√©** : Ne surchargez pas l'interface, allez √† l'essentiel
3. **Feedback** : Informez toujours l'utilisateur de ce qui se passe
4. **Tol√©rance aux erreurs** : Permettez √† l'utilisateur de se corriger facilement
5. **Flexibilit√©** : Offrez diff√©rentes fa√ßons d'accomplir les m√™mes t√¢ches
6. **Performances** : Assurez-vous que l'interface reste r√©active

### Prochaines √©tapes

Notre interface utilisateur est maintenant fonctionnelle et attrayante. Dans la section suivante (19.1.4), nous allons nous concentrer sur la cr√©ation de rapports et tableaux de bord pour analyser les donn√©es de notre application de gestion.

---

*Note : De nombreux exemples de code pr√©sent√©s ici peuvent √™tre am√©lior√©s et adapt√©s √† vos besoins sp√©cifiques. N'h√©sitez pas √† explorer les possibilit√©s offertes par Delphi pour cr√©er des interfaces encore plus riches et personnalis√©es.*

‚è≠Ô∏è [Rapports et tableaux de bord](19-projets-avances/01.4-rapports-tableaux-de-bord.md)
