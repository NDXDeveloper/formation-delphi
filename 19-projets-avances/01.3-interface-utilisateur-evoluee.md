üîù Retour au [Sommaire](/SOMMAIRE.md)

# 19.1.3 Interface utilisateur √©volu√©e

## Introduction

Une interface utilisateur bien con√ßue est cruciale pour le succ√®s d'une application. Elle doit √™tre intuitive, r√©active, esth√©tique et offrir une excellente exp√©rience utilisateur. Dans ce chapitre, nous allons cr√©er des interfaces professionnelles en utilisant la VCL (Visual Component Library) de Delphi et en exploitant les couches d'acc√®s aux donn√©es que nous avons d√©velopp√©es.

## Principes de conception d'interface

### 1. Les fondamentaux de l'UX (User Experience)

**Clart√©** : L'utilisateur doit comprendre imm√©diatement ce qu'il peut faire et comment le faire.

**Coh√©rence** : Les √©l√©ments similaires doivent se comporter de mani√®re similaire dans toute l'application.

**Feedback** : Chaque action de l'utilisateur doit avoir une r√©ponse visible (message, changement visuel, son).

**Efficacit√©** : Minimiser le nombre de clics et d'√©tapes n√©cessaires pour accomplir une t√¢che.

**Pr√©vention des erreurs** : Valider les donn√©es en temps r√©el et guider l'utilisateur.

**Accessibilit√©** : L'interface doit √™tre utilisable par tous, y compris les personnes avec des besoins sp√©cifiques.

### 2. Organisation visuelle

**Hi√©rarchie visuelle** : Les √©l√©ments importants doivent √™tre plus visibles (taille, couleur, position).

**Espacement** : Utilisez des marges et des espacements g√©n√©reux pour a√©rer l'interface.

**Alignement** : Alignez les contr√¥les pour cr√©er une structure visuelle claire.

**Groupement** : Regroupez les √©l√©ments li√©s dans des panels ou des GroupBox.

**Couleurs** : Utilisez une palette de couleurs coh√©rente et professionnelle.

## Architecture de l'interface

### Structure de l'application

Notre application de gestion aura la structure suivante :

```
FormPrincipal (MDI Parent ou avec navigation)
‚îú‚îÄ‚îÄ Menu principal
‚îú‚îÄ‚îÄ Barre d'outils
‚îú‚îÄ‚îÄ Zone de contenu (pages ou formulaires enfants)
‚îÇ   ‚îú‚îÄ‚îÄ FormClients
‚îÇ   ‚îú‚îÄ‚îÄ FormProduits
‚îÇ   ‚îú‚îÄ‚îÄ FormCommandes
‚îÇ   ‚îú‚îÄ‚îÄ FormFactures
‚îÇ   ‚îî‚îÄ‚îÄ FormStatistiques
‚îî‚îÄ‚îÄ Barre d'√©tat
```

## Cr√©ation du formulaire principal

### 1. Le formulaire principal (MainForm)

Le formulaire principal est le point d'entr√©e de l'application.

```pascal
unit uFormMain;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,
  Vcl.Menus, Vcl.ComCtrls, Vcl.ToolWin, Vcl.ExtCtrls, Vcl.StdCtrls,
  Vcl.Imaging.pngimage, uDMConnection;

type
  TFormMain = class(TForm)
    MainMenu: TMainMenu;
    StatusBar: TStatusBar;
    ToolBar: TToolBar;
    PageControl: TPageControl;

    // Menu items
    mnuFichier: TMenuItem;
    mnuQuitter: TMenuItem;
    mnuGestion: TMenuItem;
    mnuClients: TMenuItem;
    mnuProduits: TMenuItem;
    mnuCommandes: TMenuItem;
    mnuFactures: TMenuItem;
    mnuOutils: TMenuItem;
    mnuParametres: TMenuItem;
    mnuAide: TMenuItem;
    mnuAPropos: TMenuItem;

    // Toolbar buttons
    btnClients: TToolButton;
    btnProduits: TToolButton;
    btnCommandes: TToolButton;
    btnSeparator1: TToolButton;
    btnParametres: TToolButton;

    // ImageList pour les ic√¥nes
    ImageList: TImageList;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure mnuClientsClick(Sender: TObject);
    procedure mnuProduitsClick(Sender: TObject);
    procedure mnuCommandesClick(Sender: TObject);
    procedure mnuQuitterClick(Sender: TObject);
    procedure mnuAProposClick(Sender: TObject);
  private
    FCurrentTabSheet: TTabSheet;
    procedure CreateTab(const ACaption: string; AFormClass: TFormClass);
    procedure UpdateStatusBar(const AMessage: string);
    function FindTabByCaption(const ACaption: string): TTabSheet;
  public
    procedure ShowClientsForm;
    procedure ShowProduitsForm;
    procedure ShowCommandesForm;
  end;

var
  FormMain: TFormMain;

implementation

{$R *.dfm}

uses
  uFormClients, uFormProduits, uFormCommandes, uFormAbout;

{ TFormMain }

procedure TFormMain.FormCreate(Sender: TObject);
begin
  // Connexion √† la base de donn√©es
  try
    if not dmConnection.Connect then
    begin
      ShowMessage('Impossible de se connecter √† la base de donn√©es');
      Application.Terminate;
      Exit;
    end;

    UpdateStatusBar('Connect√© √† la base de donn√©es');

    // Configuration de la fen√™tre
    Self.Caption := 'Gestion Commerciale - v1.0';
    Self.WindowState := wsMaximized;

    // Configuration du PageControl
    PageControl.Align := alClient;
    PageControl.TabPosition := tpTop;

  except
    on E: Exception do
    begin
      ShowMessage('Erreur lors de l''initialisation : ' + E.Message);
      Application.Terminate;
    end;
  end;
end;

procedure TFormMain.FormDestroy(Sender: TObject);
begin
  dmConnection.Disconnect;
end;

procedure TFormMain.CreateTab(const ACaption: string; AFormClass: TFormClass);
var
  TabSheet: TTabSheet;
  Form: TForm;
begin
  // V√©rifier si l'onglet existe d√©j√†
  TabSheet := FindTabByCaption(ACaption);

  if not Assigned(TabSheet) then
  begin
    // Cr√©er un nouvel onglet
    TabSheet := TTabSheet.Create(PageControl);
    TabSheet.PageControl := PageControl;
    TabSheet.Caption := ACaption;

    // Cr√©er le formulaire dans l'onglet
    Form := AFormClass.Create(TabSheet);
    Form.Parent := TabSheet;
    Form.Align := alClient;
    Form.BorderStyle := bsNone;
    Form.Show;
  end;

  // Activer l'onglet
  PageControl.ActivePage := TabSheet;
  FCurrentTabSheet := TabSheet;
  UpdateStatusBar('Module : ' + ACaption);
end;

function TFormMain.FindTabByCaption(const ACaption: string): TTabSheet;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to PageControl.PageCount - 1 do
  begin
    if PageControl.Pages[I].Caption = ACaption then
    begin
      Result := PageControl.Pages[I];
      Break;
    end;
  end;
end;

procedure TFormMain.UpdateStatusBar(const AMessage: string);
begin
  if StatusBar.Panels.Count > 0 then
    StatusBar.Panels[0].Text := AMessage
  else
    StatusBar.SimpleText := AMessage;
end;

procedure TFormMain.ShowClientsForm;
begin
  CreateTab('Gestion des clients', TFormClients);
end;

procedure TFormMain.ShowProduitsForm;
begin
  CreateTab('Gestion des produits', TFormProduits);
end;

procedure TFormMain.ShowCommandesForm;
begin
  CreateTab('Gestion des commandes', TFormCommandes);
end;

procedure TFormMain.mnuClientsClick(Sender: TObject);
begin
  ShowClientsForm;
end;

procedure TFormMain.mnuProduitsClick(Sender: TObject);
begin
  ShowProduitsForm;
end;

procedure TFormMain.mnuCommandesClick(Sender: TObject);
begin
  ShowCommandesForm;
end;

procedure TFormMain.mnuQuitterClick(Sender: TObject);
begin
  Close;
end;

procedure TFormMain.mnuAProposClick(Sender: TObject);
var
  FormAbout: TFormAbout;
begin
  FormAbout := TFormAbout.Create(Self);
  try
    FormAbout.ShowModal;
  finally
    FormAbout.Free;
  end;
end;

end.
```

## Formulaire de liste avec recherche

### 1. Formulaire de gestion des clients (avanc√©)

Cr√©ons un formulaire moderne avec toutes les fonctionnalit√©s attendues.

```pascal
unit uFormClients;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,
  Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Grids, Vcl.ComCtrls, Vcl.Buttons,
  System.Generics.Collections, Data.DB, Vcl.DBGrids,
  FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Param,
  FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,
  FireDAC.Comp.DataSet, FireDAC.Comp.Client,
  uClient, uClientRepository, uDMConnection;

type
  TFormClients = class(TForm)
    // Panels de structure
    pnlTop: TPanel;
    pnlBottom: TPanel;
    pnlCenter: TPanel;

    // Barre de recherche
    lblRecherche: TLabel;
    edtRecherche: TEdit;
    btnRechercher: TSpeedButton;
    btnRafraichir: TSpeedButton;

    // Filtres
    lblFiltreType: TLabel;
    cboFiltreType: TComboBox;
    chkClientsActifs: TCheckBox;

    // Boutons d'action
    btnNouveau: TButton;
    btnModifier: TButton;
    btnSupprimer: TButton;
    btnExporter: TButton;

    // Grille de donn√©es
    DBGrid: TDBGrid;

    // Composants FireDAC
    FDQuery: TFDQuery;
    DataSource: TDataSource;

    // Pagination
    lblPagination: TLabel;
    btnPagePrecedente: TSpeedButton;
    btnPageSuivante: TSpeedButton;
    edtPage: TEdit;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure btnNouveauClick(Sender: TObject);
    procedure btnModifierClick(Sender: TObject);
    procedure btnSupprimerClick(Sender: TObject);
    procedure btnRechercherClick(Sender: TObject);
    procedure btnRafraichirClick(Sender: TObject);
    procedure btnExporterClick(Sender: TObject);
    procedure DBGridDblClick(Sender: TObject);
    procedure edtRechercheKeyPress(Sender: TObject; var Key: Char);
    procedure cboFiltreTypeChange(Sender: TObject);
    procedure chkClientsActifsClick(Sender: TObject);
  private
    FRepository: TClientRepository;
    FPageActuelle: Integer;
    FNombreParPage: Integer;
    FTotalClients: Integer;

    procedure ConfigurerGrille;
    procedure ChargerClients;
    procedure AppliquerFiltres;
    procedure UpdatePagination;
    function GetClientSelectionne: Integer;
    procedure ExporterVersExcel;
  public
    { D√©clarations publiques }
  end;

var
  FormClients: TFormClients;

implementation

{$R *.dfm}

uses
  uFormClientEdit, System.UITypes, Vcl.Clipbrd, ComObj;

{ TFormClients }

procedure TFormClients.FormCreate(Sender: TObject);
begin
  FRepository := TClientRepository.Create(dmConnection);
  FPageActuelle := 1;
  FNombreParPage := 50;

  // Configuration des composants
  ConfigurerGrille;

  // Remplir le combo de filtres
  cboFiltreType.Items.Clear;
  cboFiltreType.Items.Add('Tous');
  cboFiltreType.Items.Add('Particuliers');
  cboFiltreType.Items.Add('Entreprises');
  cboFiltreType.ItemIndex := 0;

  chkClientsActifs.Checked := True;

  // Charger les donn√©es
  ChargerClients;
end;

procedure TFormClients.FormDestroy(Sender: TObject);
begin
  FRepository.Free;
end;

procedure TFormClients.ConfigurerGrille;
begin
  // Configuration de la requ√™te FireDAC
  FDQuery.Connection := dmConnection.FDConnection;
  DataSource.DataSet := FDQuery;
  DBGrid.DataSource := DataSource;

  // Options de la grille
  DBGrid.Options := DBGrid.Options + [dgRowSelect, dgAlwaysShowSelection];
  DBGrid.ReadOnly := True;

  // Personnalisation de l'apparence
  DBGrid.Font.Size := 10;
  DBGrid.FixedColor := clBtnFace;
  DBGrid.Color := clWhite;
  DBGrid.AlternatingRowBackground := $00F5F5F5;
end;

procedure TFormClients.ChargerClients;
var
  SQL: string;
  Offset: Integer;
begin
  Screen.Cursor := crHourGlass;
  try
    // Construction de la requ√™te SQL
    SQL := 'SELECT ' +
           '  id_client, ' +
           '  code_client AS "Code", ' +
           '  nom AS "Nom", ' +
           '  prenom AS "Pr√©nom", ' +
           '  raison_sociale AS "Raison Sociale", ' +
           '  type_client AS "Type", ' +
           '  email AS "Email", ' +
           '  telephone AS "T√©l√©phone", ' +
           '  ville AS "Ville", ' +
           '  actif AS "Actif" ' +
           'FROM CLIENTS ' +
           'WHERE 1=1 ';

    // Appliquer les filtres
    if chkClientsActifs.Checked then
      SQL := SQL + 'AND actif = 1 ';

    case cboFiltreType.ItemIndex of
      1: SQL := SQL + 'AND type_client = ''particulier'' ';
      2: SQL := SQL + 'AND type_client = ''entreprise'' ';
    end;

    if Trim(edtRecherche.Text) <> '' then
    begin
      SQL := SQL +
        'AND (nom LIKE :search ' +
        'OR prenom LIKE :search ' +
        'OR raison_sociale LIKE :search ' +
        'OR email LIKE :search ' +
        'OR code_client LIKE :search) ';
    end;

    SQL := SQL + 'ORDER BY nom, prenom ';

    // Pagination
    Offset := (FPageActuelle - 1) * FNombreParPage;
    SQL := SQL + Format('LIMIT %d OFFSET %d', [FNombreParPage, Offset]);

    // Ex√©cution de la requ√™te
    FDQuery.Close;
    FDQuery.SQL.Text := SQL;

    if Trim(edtRecherche.Text) <> '' then
      FDQuery.ParamByName('search').AsString := '%' + edtRecherche.Text + '%';

    FDQuery.Open;

    // Masquer la colonne ID
    if FDQuery.Fields.Count > 0 then
      FDQuery.Fields[0].Visible := False;

    // Mise √† jour de la pagination
    UpdatePagination;

  finally
    Screen.Cursor := crDefault;
  end;
end;

procedure TFormClients.UpdatePagination;
var
  CountSQL: string;
  CountQuery: TFDQuery;
  TotalPages: Integer;
begin
  // Compter le nombre total de clients
  CountSQL := 'SELECT COUNT(*) AS total FROM CLIENTS WHERE 1=1 ';

  if chkClientsActifs.Checked then
    CountSQL := CountSQL + 'AND actif = 1 ';

  case cboFiltreType.ItemIndex of
    1: CountSQL := CountSQL + 'AND type_client = ''particulier'' ';
    2: CountSQL := CountSQL + 'AND type_client = ''entreprise'' ';
  end;

  if Trim(edtRecherche.Text) <> '' then
  begin
    CountSQL := CountSQL +
      'AND (nom LIKE :search ' +
      'OR prenom LIKE :search ' +
      'OR raison_sociale LIKE :search ' +
      'OR email LIKE :search ' +
      'OR code_client LIKE :search) ';
  end;

  CountQuery := TFDQuery.Create(nil);
  try
    CountQuery.Connection := dmConnection.FDConnection;
    CountQuery.SQL.Text := CountSQL;

    if Trim(edtRecherche.Text) <> '' then
      CountQuery.ParamByName('search').AsString := '%' + edtRecherche.Text + '%';

    CountQuery.Open;
    FTotalClients := CountQuery.FieldByName('total').AsInteger;

    TotalPages := (FTotalClients + FNombreParPage - 1) div FNombreParPage;

    lblPagination.Caption := Format('Page %d sur %d (%d clients)',
      [FPageActuelle, TotalPages, FTotalClients]);

    btnPagePrecedente.Enabled := (FPageActuelle > 1);
    btnPageSuivante.Enabled := (FPageActuelle < TotalPages);
  finally
    CountQuery.Free;
  end;
end;

function TFormClients.GetClientSelectionne: Integer;
begin
  Result := 0;
  if not FDQuery.IsEmpty then
    Result := FDQuery.FieldByName('id_client').AsInteger;
end;

procedure TFormClients.AppliquerFiltres;
begin
  FPageActuelle := 1;
  ChargerClients;
end;

procedure TFormClients.btnNouveauClick(Sender: TObject);
var
  FormEdit: TFormClientEdit;
begin
  FormEdit := TFormClientEdit.Create(Self);
  try
    FormEdit.ClientId := 0; // Nouveau client
    if FormEdit.ShowModal = mrOk then
      ChargerClients;
  finally
    FormEdit.Free;
  end;
end;

procedure TFormClients.btnModifierClick(Sender: TObject);
var
  FormEdit: TFormClientEdit;
  ClientId: Integer;
begin
  ClientId := GetClientSelectionne;

  if ClientId = 0 then
  begin
    MessageDlg('Veuillez s√©lectionner un client √† modifier',
      mtInformation, [mbOK], 0);
    Exit;
  end;

  FormEdit := TFormClientEdit.Create(Self);
  try
    FormEdit.ClientId := ClientId;
    if FormEdit.ShowModal = mrOk then
      ChargerClients;
  finally
    FormEdit.Free;
  end;
end;

procedure TFormClients.btnSupprimerClick(Sender: TObject);
var
  ClientId: Integer;
  Client: TClient;
begin
  ClientId := GetClientSelectionne;

  if ClientId = 0 then
  begin
    MessageDlg('Veuillez s√©lectionner un client √† supprimer',
      mtInformation, [mbOK], 0);
    Exit;
  end;

  Client := FRepository.GetClient(ClientId);
  try
    if MessageDlg(
      Format('√ätes-vous s√ªr de vouloir supprimer le client "%s" ?',
        [Client.GetNomComplet]),
      mtConfirmation, [mbYes, mbNo], 0) = mrYes then
    begin
      try
        if FRepository.DeleteClient(ClientId) then
        begin
          MessageDlg('Client supprim√© avec succ√®s', mtInformation, [mbOK], 0);
          ChargerClients;
        end
        else
          MessageDlg('Erreur lors de la suppression', mtError, [mbOK], 0);
      except
        on E: Exception do
          MessageDlg('Erreur : ' + E.Message, mtError, [mbOK], 0);
      end;
    end;
  finally
    Client.Free;
  end;
end;

procedure TFormClients.btnRechercherClick(Sender: TObject);
begin
  AppliquerFiltres;
end;

procedure TFormClients.btnRafraichirClick(Sender: TObject);
begin
  ChargerClients;
end;

procedure TFormClients.btnExporterClick(Sender: TObject);
begin
  ExporterVersExcel;
end;

procedure TFormClients.DBGridDblClick(Sender: TObject);
begin
  btnModifierClick(Sender);
end;

procedure TFormClients.edtRechercheKeyPress(Sender: TObject; var Key: Char);
begin
  if Key = #13 then // Touche Entr√©e
  begin
    Key := #0;
    btnRechercherClick(Sender);
  end;
end;

procedure TFormClients.cboFiltreTypeChange(Sender: TObject);
begin
  AppliquerFiltres;
end;

procedure TFormClients.chkClientsActifsClick(Sender: TObject);
begin
  AppliquerFiltres;
end;

procedure TFormClients.ExporterVersExcel;
var
  Excel, Workbook, Worksheet: OleVariant;
  Row, Col: Integer;
begin
  if FDQuery.IsEmpty then
  begin
    MessageDlg('Aucune donn√©e √† exporter', mtInformation, [mbOK], 0);
    Exit;
  end;

  Screen.Cursor := crHourGlass;
  try
    // Cr√©er une instance d'Excel
    try
      Excel := CreateOleObject('Excel.Application');
    except
      MessageDlg('Excel n''est pas install√© sur cet ordinateur',
        mtError, [mbOK], 0);
      Exit;
    end;

    Excel.Visible := True;
    Workbook := Excel.Workbooks.Add;
    Worksheet := Workbook.Worksheets[1];
    Worksheet.Name := 'Clients';

    // En-t√™tes de colonnes
    for Col := 0 to FDQuery.FieldCount - 1 do
    begin
      if FDQuery.Fields[Col].Visible then
        Worksheet.Cells[1, Col + 1] := FDQuery.Fields[Col].DisplayLabel;
    end;

    // Donn√©es
    Row := 2;
    FDQuery.First;
    while not FDQuery.Eof do
    begin
      for Col := 0 to FDQuery.FieldCount - 1 do
      begin
        if FDQuery.Fields[Col].Visible then
          Worksheet.Cells[Row, Col + 1] := FDQuery.Fields[Col].AsString;
      end;
      Inc(Row);
      FDQuery.Next;
    end;

    // Formatage
    Worksheet.Columns.AutoFit;
    Worksheet.Range['A1', Worksheet.Cells[1, FDQuery.FieldCount]].Font.Bold := True;

    MessageDlg('Export vers Excel r√©ussi', mtInformation, [mbOK], 0);

  finally
    Screen.Cursor := crDefault;
  end;
end;

end.
```

## Formulaire d'√©dition avec validation

### 1. Formulaire d'√©dition de client

```pascal
unit uFormClientEdit;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,
  Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.ComCtrls, Vcl.Mask,
  uClient, uClientRepository, uDMConnection;

type
  TFormClientEdit = class(TForm)
    pnlTop: TPanel;
    pnlBottom: TPanel;
    pnlCenter: TPanel;

    // Titre
    lblTitre: TLabel;

    // Informations g√©n√©rales
    grpInformations: TGroupBox;
    lblCodeClient: TLabel;
    edtCodeClient: TEdit;
    lblTypeClient: TLabel;
    cboTypeClient: TComboBox;

    // Particulier
    lblNom: TLabel;
    edtNom: TEdit;
    lblPrenom: TLabel;
    edtPrenom: TEdit;

    // Entreprise
    lblRaisonSociale: TLabel;
    edtRaisonSociale: TEdit;

    // Contact
    grpContact: TGroupBox;
    lblEmail: TLabel;
    edtEmail: TEdit;
    lblTelephone: TLabel;
    edtTelephone: TMaskEdit;

    // Adresse
    grpAdresse: TGroupBox;
    lblAdresse: TLabel;
    memoAdresse: TMemo;
    lblCodePostal: TLabel;
    edtCodePostal: TEdit;
    lblVille: TLabel;
    edtVille: TEdit;
    lblPays: TLabel;
    cboPays: TComboBox;

    // Options
    chkActif: TCheckBox;

    // Boutons
    btnEnregistrer: TButton;
    btnAnnuler: TButton;

    // Indicateurs de validation
    imgNomValid: TImage;
    imgEmailValid: TImage;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure btnEnregistrerClick(Sender: TObject);
    procedure btnAnnulerClick(Sender: TObject);
    procedure cboTypeClientChange(Sender: TObject);
    procedure edtNomExit(Sender: TObject);
    procedure edtEmailExit(Sender: TObject);
    procedure edtCodePostalKeyPress(Sender: TObject; var Key: Char);
  private
    FRepository: TClientRepository;
    FClient: TClient;
    FClientId: Integer;
    FModified: Boolean;

    procedure ChargerClient;
    procedure SauvegarderClient;
    function ValiderFormulaire: Boolean;
    procedure ValiderChamp(AEdit: TEdit; AImage: TImage; AValide: Boolean);
    procedure AfficherErreurs(AErrors: TStringList);
    procedure AjusterInterface;
    procedure SetModified;
  public
    property ClientId: Integer read FClientId write FClientId;
  end;

var
  FormClientEdit: TFormClientEdit;

implementation

{$R *.dfm}

uses
  System.UITypes, System.RegularExpressions;

{ TFormClientEdit }

procedure TFormClientEdit.FormCreate(Sender: TObject);
begin
  FRepository := TClientRepository.Create(dmConnection);
  FClient := TClient.Create;
  FModified := False;

  // Remplir les combos
  cboTypeClient.Items.Clear;
  cboTypeClient.Items.Add('Particulier');
  cboTypeClient.Items.Add('Entreprise');
  cboTypeClient.ItemIndex := 0;

  cboPays.Items.Clear;
  cboPays.Items.Add('France');
  cboPays.Items.Add('Belgique');
  cboPays.Items.Add('Suisse');
  cboPays.Items.Add('Luxembourg');
  cboPays.Items.Add('Canada');
  cboPays.ItemIndex := 0;

  // Configuration du MaskEdit pour le t√©l√©phone
  edtTelephone.EditMask := '00 00 00 00 00;1; ';
end;

procedure TFormClientEdit.FormDestroy(Sender: TObject);
begin
  FClient.Free;
  FRepository.Free;
end;

procedure TFormClientEdit.FormShow(Sender: TObject);
begin
  if FClientId > 0 then
  begin
    lblTitre.Caption := 'Modifier un client';
    ChargerClient;
  end
  else
  begin
    lblTitre.Caption := 'Nouveau client';
    edtCodeClient.Text := FRepository.GenerateClientCode;
    edtCodeClient.Enabled := False;
  end;

  AjusterInterface;
end;

procedure TFormClientEdit.ChargerClient;
begin
  try
    FClient.Free;
    FClient := FRepository.GetClient(FClientId);

    // Remplir les champs
    edtCodeClient.Text := FClient.CodeClient;

    if FClient.TypeClient = tcEntreprise then
      cboTypeClient.ItemIndex := 1
    else
      cboTypeClient.ItemIndex := 0;

    edtNom.Text := FClient.Nom;
    edtPrenom.Text := FClient.Prenom;
    edtRaisonSociale.Text := FClient.RaisonSociale;
    edtEmail.Text := FClient.Email;
    edtTelephone.Text := FClient.Telephone;
    memoAdresse.Text := FClient.Adresse;
    edtCodePostal.Text := FClient.CodePostal;
    edtVille.Text := FClient.Ville;
    cboPays.Text := FClient.Pays;
    chkActif.Checked := FClient.Actif;

    AjusterInterface;
    FModified := False;

  except
    on E: Exception do
    begin
      MessageDlg('Erreur lors du chargement du client : ' + E.Message,
        mtError, [mbOK], 0);
      Close;
    end;
  end;
end;

procedure TFormClientEdit.SauvegarderClient;
begin
  // R√©cup√©rer les valeurs des champs
  FClient.CodeClient := edtCodeClient.Text;

  if cboTypeClient.ItemIndex = 1 then
    FClient.TypeClient := tcEntreprise
  else
    FClient.TypeClient := tcParticulier;

  FClient.Nom := edtNom.Text;
  FClient.Prenom := edtPrenom.Text;
  FClient.RaisonSociale := edtRaisonSociale.Text;
  FClient.Email := edtEmail.Text;
  FClient.Telephone := edtTelephone.Text;
  FClient.Adresse := memoAdresse.Text;
  FClient.CodePostal := edtCodePostal.Text;
  FClient.Ville := edtVille.Text;
  FClient.Pays := cboPays.Text;
  FClient.Actif := chkActif.Checked;

  try
    if FRepository.SaveClient(FClient) then
    begin
      MessageDlg('Client enregistr√© avec succ√®s', mtInformation, [mbOK], 0);
      ModalResult := mrOk;
    end
    else
      MessageDlg('Erreur lors de l''enregistrement', mtError, [mbOK], 0);
  except
    on E: Exception do
      MessageDlg('Erreur : ' + E.Message, mtError, [mbOK], 0);
  end;
end;

function TFormClientEdit.ValiderFormulaire: Boolean;
var
  Errors: TStringList;
begin
  Errors := TStringList.Create;
  try
    Result := FRepository.ValidateClient(FClient, Errors);

    if not Result then
      AfficherErreurs(Errors);
  finally
    Errors.Free;
  end;
end;

procedure TFormClientEdit.ValiderChamp(AEdit: TEdit; AImage: TImage;
  AValide: Boolean);
begin
  if not Assigned(AImage) then
    Exit;

  if AValide then
  begin
    AEdit.Color := clWindow;
    AImage.Visible := True;
    // D√©finir l'ic√¥ne de validation (coche verte)
  end
  else
  begin
    AEdit.Color := $00E0E0FF; // Rouge clair
    AImage.Visible := False;
  end;
end;

procedure TFormClientEdit.AfficherErreurs(AErrors: TStringList);
var
  Message: string;
  I: Integer;
begin
  if AErrors.Count = 0 then
    Exit;

  Message := 'Veuillez corriger les erreurs suivantes :' + sLineBreak + sLineBreak;

  for I := 0 to AErrors.Count - 1 do
    Message := Message + '‚Ä¢ ' + AErrors[I] + sLineBreak;

  MessageDlg(Message, mtWarning, [mbOK], 0);
end;

procedure TFormClientEdit.AjusterInterface;
var
  EstEntreprise: Boolean;
begin
  EstEntreprise := (cboTypeClient.ItemIndex = 1);

  // Afficher/masquer les champs selon le type
  lblNom.Visible := not EstEntreprise;
  edtNom.Visible := not EstEntreprise;
  lblPrenom.Visible := not EstEntreprise;
  edtPrenom.Visible := not EstEntreprise;

  lblRaisonSociale.Visible := EstEntreprise;
  edtRaisonSociale.Visible := EstEntreprise;

  // Ajuster les labels
  if EstEntreprise then
    lblNom.Caption := 'Contact :'
  else
    lblNom.Caption := 'Nom * :';
end;

procedure TFormClientEdit.SetModified;
begin
  FModified := True;
end;

procedure TFormClientEdit.cboTypeClientChange(Sender: TObject);
begin
  AjusterInterface;
  SetModified;
end;

procedure TFormClientEdit.edtNomExit(Sender: TObject);
var
  Valide: Boolean;
begin
  Valide := (Trim(edtNom.Text) <> '');
  ValiderChamp(edtNom, imgNomValid, Valide);
end;

procedure TFormClientEdit.edtEmailExit(Sender: TObject);
var
  Valide: Boolean;
  EmailRegex: TRegEx;
begin
  if Trim(edtEmail.Text) = '' then
  begin
    ValiderChamp(edtEmail, imgEmailValid, True);
    Exit;
  end;

  // Validation format email
  EmailRegex := TRegEx.Create('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$');
  Valide := EmailRegex.IsMatch(edtEmail.Text);

  ValiderChamp(edtEmail, imgEmailValid, Valide);
end;

procedure TFormClientEdit.edtCodePostalKeyPress(Sender: TObject; var Key: Char);
begin
  // N'accepter que les chiffres
  if not CharInSet(Key, ['0'..'9', #8, #13]) then
    Key := #0;
end;

procedure TFormClientEdit.btnEnregistrerClick(Sender: TObject);
begin
  // Mettre √† jour l'objet Client avec les valeurs des champs
  FClient.Nom := edtNom.Text;
  FClient.Email := edtEmail.Text;
  // ... autres champs

  if ValiderFormulaire then
    SauvegarderClient;
end;

procedure TFormClientEdit.btnAnnulerClick(Sender: TObject);
begin
  if FModified then
  begin
    if MessageDlg('Des modifications ont √©t√© effectu√©es. Voulez-vous vraiment quitter sans enregistrer ?',
      mtConfirmation, [mbYes, mbNo], 0) = mrYes then
      ModalResult := mrCancel;
  end
  else
    ModalResult := mrCancel;
end;

end.
```

## Composants avanc√©s

### 1. Barre de progression pour les op√©rations longues

```pascal
procedure TFormImport.ImporterClients;
var
  ProgressForm: TForm;
  ProgressBar: TProgressBar;
  lblStatus: TLabel;
  I, Total: Integer;
begin
  // Cr√©er un formulaire de progression
  ProgressForm := TForm.Create(Self);
  try
    ProgressForm.BorderStyle := bsDialog;
    ProgressForm.Caption := 'Import en cours...';
    ProgressForm.Width := 400;
    ProgressForm.Height := 150;
    ProgressForm.Position := poOwnerFormCenter;

    lblStatus := TLabel.Create(ProgressForm);
    lblStatus.Parent := ProgressForm;
    lblStatus.Left := 20;
    lblStatus.Top := 20;
    lblStatus.Caption := 'Initialisation...';

    ProgressBar := TProgressBar.Create(ProgressForm);
    ProgressBar.Parent := ProgressForm;
    ProgressBar.Left := 20;
    ProgressBar.Top := 50;
    ProgressBar.Width := 360;

    ProgressForm.Show;
    Application.ProcessMessages;

    Total := ListeClients.Count;
    ProgressBar.Max := Total;

    for I := 0 to Total - 1 do
    begin
      lblStatus.Caption := Format('Import du client %d sur %d...', [I + 1, Total]);
      ProgressBar.Position := I + 1;
      Application.ProcessMessages;

      // Importer le client
      ImporterClient(ListeClients[I]);
    end;

    lblStatus.Caption := 'Import termin√© !';
    ShowMessage(Format('%d clients import√©s avec succ√®s', [Total]));

  finally
    ProgressForm.Free;
  end;
end;
```

### 2. Notifications toast modernes

```pascal
unit uNotifications;

interface

uses
  Vcl.Forms, Vcl.StdCtrls, Vcl.ExtCtrls, System.Classes, Vcl.Graphics,
  Winapi.Windows;

type
  TNotificationType = (ntInfo, ntSuccess, ntWarning, ntError);

  TNotificationHelper = class
  public
    class procedure Show(const AMessage: string;
      AType: TNotificationType = ntInfo); static;
  end;

implementation

uses
  System.SysUtils;

class procedure TNotificationHelper.Show(const AMessage: string;
  AType: TNotificationType);
var
  NotifForm: TForm;
  Panel: TPanel;
  Label1: TLabel;
  Timer: TTimer;
begin
  NotifForm := TForm.Create(nil);
  NotifForm.BorderStyle := bsNone;
  NotifForm.Width := 300;
  NotifForm.Height := 80;
  NotifForm.Position := poDesigned;
  NotifForm.Left := Screen.Width - NotifForm.Width - 20;
  NotifForm.Top := Screen.Height - NotifForm.Height - 60;
  NotifForm.AlphaBlend := True;
  NotifForm.AlphaBlendValue := 230;

  Panel := TPanel.Create(NotifForm);
  Panel.Parent := NotifForm;
  Panel.Align := alClient;
  Panel.BevelOuter := bvNone;
  Panel.BorderWidth := 2;

  // Couleurs selon le type
  case AType of
    ntInfo:
      begin
        Panel.Color := $00FFF4E6;
        Panel.Font.Color := $00D68910;
      end;
    ntSuccess:
      begin
        Panel.Color := $00E8F5E9;
        Panel.Font.Color := $002E7D32;
      end;
    ntWarning:
      begin
        Panel.Color := $00FFF3E0;
        Panel.Font.Color := $00E65100;
      end;
    ntError:
      begin
        Panel.Color := $00FFEBEE;
        Panel.Font.Color := $00C62828;
      end;
  end;

  Label1 := TLabel.Create(Panel);
  Label1.Parent := Panel;
  Label1.Align := alClient;
  Label1.Alignment := taCenter;
  Label1.Layout := tlCenter;
  Label1.Caption := AMessage;
  Label1.Font.Size := 10;
  Label1.Font.Style := [fsBold];
  Label1.WordWrap := True;

  Timer := TTimer.Create(NotifForm);
  Timer.Interval := 3000;
  Timer.OnTimer := procedure(Sender: TObject)
    begin
      NotifForm.Close;
      NotifForm.Free;
    end;
  Timer.Enabled := True;

  NotifForm.Show;
end;

end.
```

Utilisation :
```pascal
TNotificationHelper.Show('Client enregistr√© avec succ√®s', ntSuccess);
TNotificationHelper.Show('Erreur de connexion', ntError);
```

### 3. Tableaux de bord avec graphiques

```pascal
unit uFormDashboard;

interface

uses
  Winapi.Windows, System.SysUtils, System.Classes, Vcl.Controls,
  Vcl.Forms, Vcl.ExtCtrls, Vcl.StdCtrls, Vcl.ComCtrls,
  VCLTee.TeEngine, VCLTee.Series, VCLTee.TeeProcs, VCLTee.Chart;

type
  TFormDashboard = class(TForm)
    pnlStats: TPanel;
    pnlCharts: TPanel;

    // Cartes statistiques
    pnlClientCount: TPanel;
    lblClientCount: TLabel;
    lblClientLabel: TLabel;

    pnlRevenueMonth: TPanel;
    lblRevenueMonth: TLabel;
    lblRevenueLabel: TLabel;

    pnlOrdersToday: TPanel;
    lblOrdersToday: TLabel;
    lblOrdersLabel: TLabel;

    // Graphiques
    chartVentes: TChart;
    seriesVentes: TLineSeries;

    chartTopProduits: TChart;
    seriesTopProduits: TBarSeries;

    procedure FormCreate(Sender: TObject);
    procedure FormShow(Sender: TObject);
  private
    procedure LoadStatistics;
    procedure LoadCharts;
    procedure StyleStatCard(APanel: TPanel; AColor: TColor);
  public
    { D√©clarations publiques }
  end;

implementation

{$R *.dfm}

uses
  uDMConnection, FireDAC.Comp.Client, Graphics;

procedure TFormDashboard.FormCreate(Sender: TObject);
begin
  // Style des cartes
  StyleStatCard(pnlClientCount, $00FFD54F);
  StyleStatCard(pnlRevenueMonth, $0081C784);
  StyleStatCard(pnlOrdersToday, $0064B5F6);
end;

procedure TFormDashboard.FormShow(Sender: TObject);
begin
  LoadStatistics;
  LoadCharts;
end;

procedure TFormDashboard.StyleStatCard(APanel: TPanel; AColor: TColor);
begin
  APanel.Color := AColor;
  APanel.BevelOuter := bvNone;
  APanel.BorderWidth := 1;
  APanel.Padding.SetBounds(10, 10, 10, 10);
end;

procedure TFormDashboard.LoadStatistics;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := dmConnection.FDConnection;

    // Nombre de clients
    Query.SQL.Text := 'SELECT COUNT(*) AS total FROM CLIENTS WHERE actif = 1';
    Query.Open;
    lblClientCount.Caption := Query.FieldByName('total').AsString;
    Query.Close;

    // Chiffre d'affaires du mois
    Query.SQL.Text :=
      'SELECT SUM(montant_ttc) AS total ' +
      'FROM FACTURES ' +
      'WHERE MONTH(date_facture) = MONTH(CURDATE()) ' +
      'AND YEAR(date_facture) = YEAR(CURDATE())';
    Query.Open;
    lblRevenueMonth.Caption := FormatFloat('#,##0.00 ‚Ç¨',
      Query.FieldByName('total').AsFloat);
    Query.Close;

    // Commandes du jour
    Query.SQL.Text :=
      'SELECT COUNT(*) AS total ' +
      'FROM COMMANDES ' +
      'WHERE DATE(date_commande) = CURDATE()';
    Query.Open;
    lblOrdersToday.Caption := Query.FieldByName('total').AsString;

  finally
    Query.Free;
  end;
end;

procedure TFormDashboard.LoadCharts;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := dmConnection.FDConnection;

    // Graphique des ventes des 30 derniers jours
    seriesVentes.Clear;
    Query.SQL.Text :=
      'SELECT DATE(date_commande) AS jour, SUM(montant_ttc) AS total ' +
      'FROM COMMANDES ' +
      'WHERE date_commande >= DATE_SUB(CURDATE(), INTERVAL 30 DAY) ' +
      'GROUP BY DATE(date_commande) ' +
      'ORDER BY jour';
    Query.Open;

    while not Query.Eof do
    begin
      seriesVentes.AddXY(
        Query.FieldByName('jour').AsDateTime,
        Query.FieldByName('total').AsFloat
      );
      Query.Next;
    end;
    Query.Close;

    // Graphique des top produits
    seriesTopProduits.Clear;
    Query.SQL.Text :=
      'SELECT p.nom_produit, SUM(lc.quantite) AS total ' +
      'FROM LIGNES_COMMANDE lc ' +
      'INNER JOIN PRODUITS p ON lc.id_produit = p.id_produit ' +
      'GROUP BY p.id_produit, p.nom_produit ' +
      'ORDER BY total DESC ' +
      'LIMIT 10';
    Query.Open;

    while not Query.Eof do
    begin
      seriesTopProduits.Add(
        Query.FieldByName('total').AsFloat,
        Query.FieldByName('nom_produit').AsString,
        clTeeColor
      );
      Query.Next;
    end;

  finally
    Query.Free;
  end;
end;

end.
```

## Styles visuels VCL

### Application de th√®mes modernes

```pascal
procedure TFormMain.FormCreate(Sender: TObject);
begin
  // Appliquer un style VCL moderne
  TStyleManager.TrySetStyle('Windows11 Modern Dark');

  // Ou charger un style personnalis√©
  if FileExists('MonStyle.vsf') then
    TStyleManager.LoadFromFile('MonStyle.vsf');
end;
```

## Bonnes pratiques d'interface

### 1. Raccourcis clavier

```pascal
procedure TFormClients.FormCreate(Sender: TObject);
begin
  // D√©finir les raccourcis
  btnNouveau.Hint := 'Nouveau client (Ctrl+N)';
  btnModifier.Hint := 'Modifier (Ctrl+M)';
  btnSupprimer.Hint := 'Supprimer (Suppr)';
end;

procedure TFormClients.FormKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Shift = [ssCtrl] then
  begin
    case Key of
      Ord('N'): btnNouveauClick(nil);
      Ord('M'): btnModifierClick(nil);
      Ord('F'): edtRecherche.SetFocus;
    end;
  end
  else if Key = VK_DELETE then
    btnSupprimerClick(nil)
  else if Key = VK_F5 then
    btnRafraichirClick(nil);
end;
```

### 2. M√©morisation de la position des fen√™tres

```pascal
procedure TFormClients.FormCreate(Sender: TObject);
var
  IniFile: TIniFile;
begin
  IniFile := TIniFile.Create(ChangeFileExt(Application.ExeName, '.ini'));
  try
    Left := IniFile.ReadInteger('FormClients', 'Left', Left);
    Top := IniFile.ReadInteger('FormClients', 'Top', Top);
    Width := IniFile.ReadInteger('FormClients', 'Width', Width);
    Height := IniFile.ReadInteger('FormClients', 'Height', Height);
  finally
    IniFile.Free;
  end;
end;

procedure TFormClients.FormClose(Sender: TObject; var Action: TCloseAction);
var
  IniFile: TIniFile;
begin
  IniFile := TIniFile.Create(ChangeFileExt(Application.ExeName, '.ini'));
  try
    IniFile.WriteInteger('FormClients', 'Left', Left);
    IniFile.WriteInteger('FormClients', 'Top', Top);
    IniFile.WriteInteger('FormClients', 'Width', Width);
    IniFile.WriteInteger('FormClients', 'Height', Height);
  finally
    IniFile.Free;
  end;
end;
```

### 3. Accessibilit√©

```pascal
procedure ConfigurerAccessibilite;
begin
  // D√©finir les TabOrder correctement
  edtNom.TabOrder := 0;
  edtPrenom.TabOrder := 1;
  edtEmail.TabOrder := 2;

  // Associer les labels aux contr√¥les
  lblNom.FocusControl := edtNom;
  lblPrenom.FocusControl := edtPrenom;
  lblEmail.FocusControl := edtEmail;

  // D√©finir les Hints
  btnEnregistrer.ShowHint := True;
  btnEnregistrer.Hint := 'Enregistrer les modifications (Ctrl+S)';
end;
```

## Conclusion

Une interface utilisateur √©volu√©e n√©cessite :
- Une architecture claire et modulaire
- Des composants bien configur√©s et personnalis√©s
- Des validations en temps r√©el
- Un feedback visuel constant
- Une navigation intuitive
- Des raccourcis clavier
- Une coh√©rence visuelle
- Une attention √† l'accessibilit√©

Les interfaces modernes combinent esth√©tique et fonctionnalit√© pour offrir la meilleure exp√©rience utilisateur possible.

Dans le prochain chapitre, nous verrons comment cr√©er des rapports et des tableaux de bord pour exploiter toutes ces donn√©es.

‚è≠Ô∏è [Rapports et tableaux de bord](/19-projets-avances/01.4-rapports-tableaux-de-bord.md)
