üîù Retour au [Sommaire](/SOMMAIRE.md)

# 19.1.4 Rapports et tableaux de bord

## Introduction

Les rapports et les tableaux de bord sont des outils essentiels pour toute application de gestion. Ils permettent de visualiser, d'analyser et de pr√©senter les donn√©es de mani√®re claire et professionnelle. Dans ce chapitre, nous allons apprendre √† cr√©er des rapports sophistiqu√©s et des tableaux de bord interactifs avec Delphi.

## Types de rapports

### 1. Rapports simples
- Listes de donn√©es (clients, produits, commandes)
- Rapports avec en-t√™tes et pieds de page
- Rapports avec totaux et sous-totaux

### 2. Rapports complexes
- Rapports avec regroupements multiples
- Rapports ma√Ætre-d√©tail
- Rapports avec graphiques int√©gr√©s
- Rapports multi-colonnes

### 3. Rapports analytiques
- Tableaux crois√©s dynamiques
- Analyses comparatives
- Tendances et pr√©visions

### 4. Documents officiels
- Factures
- Bons de commande
- Devis
- Bordereaux de livraison

## Composants d'impression natifs de Delphi

### 1. TPrinter et TPrintDialog

Delphi fournit des composants de base pour l'impression directe.

```pascal
unit uSimplePrint;

interface

uses
  Winapi.Windows, System.SysUtils, System.Classes, Vcl.Graphics,
  Vcl.Printers, Vcl.Dialogs;

type
  TSimplePrinter = class
  private
    FMarginLeft: Integer;
    FMarginTop: Integer;
    FMarginRight: Integer;
    FMarginBottom: Integer;
    FCurrentY: Integer;
    FLineHeight: Integer;
  public
    constructor Create;

    procedure BeginDoc(const ATitle: string);
    procedure EndDoc;
    procedure NewPage;
    procedure PrintLine(const AText: string; AFontStyle: TFontStyles = []);
    procedure PrintTitle(const AText: string);
    procedure PrintHeader;
    procedure PrintFooter(APageNumber: Integer);
    procedure DrawLine(Y: Integer);

    property MarginLeft: Integer read FMarginLeft write FMarginLeft;
    property MarginTop: Integer read FMarginTop write FMarginTop;
    property MarginRight: Integer read FMarginRight write FMarginRight;
    property MarginBottom: Integer read FMarginBottom write FMarginBottom;
  end;

implementation

{ TSimplePrinter }

constructor TSimplePrinter.Create;
begin
  inherited Create;
  FMarginLeft := 100;
  FMarginTop := 100;
  FMarginRight := 100;
  FMarginBottom := 100;
  FLineHeight := 50;
end;

procedure TSimplePrinter.BeginDoc(const ATitle: string);
begin
  Printer.Title := ATitle;
  Printer.BeginDoc;
  FCurrentY := FMarginTop;
end;

procedure TSimplePrinter.EndDoc;
begin
  Printer.EndDoc;
end;

procedure TSimplePrinter.NewPage;
begin
  Printer.NewPage;
  FCurrentY := FMarginTop;
end;

procedure TSimplePrinter.PrintLine(const AText: string; AFontStyle: TFontStyles);
begin
  Printer.Canvas.Font.Style := AFontStyle;
  Printer.Canvas.TextOut(FMarginLeft, FCurrentY, AText);
  Inc(FCurrentY, FLineHeight);

  // Nouvelle page si n√©cessaire
  if FCurrentY > (Printer.PageHeight - FMarginBottom) then
    NewPage;
end;

procedure TSimplePrinter.PrintTitle(const AText: string);
begin
  Printer.Canvas.Font.Size := 16;
  Printer.Canvas.Font.Style := [fsBold];
  Printer.Canvas.TextOut(FMarginLeft, FCurrentY, AText);
  Inc(FCurrentY, FLineHeight * 2);
  Printer.Canvas.Font.Size := 10;
  Printer.Canvas.Font.Style := [];
end;

procedure TSimplePrinter.PrintHeader;
begin
  Printer.Canvas.Font.Size := 12;
  Printer.Canvas.Font.Style := [fsBold];
  Printer.Canvas.TextOut(FMarginLeft, FMarginTop, 'Mon Entreprise');
  Printer.Canvas.Font.Size := 8;
  Printer.Canvas.Font.Style := [];
  Printer.Canvas.TextOut(FMarginLeft, FMarginTop + 30, '123 Rue de la Gestion');
  Printer.Canvas.TextOut(FMarginLeft, FMarginTop + 45, '75000 Paris');

  DrawLine(FMarginTop + 70);
  Inc(FCurrentY, 100);
end;

procedure TSimplePrinter.PrintFooter(APageNumber: Integer);
var
  FooterY: Integer;
  FooterText: string;
begin
  FooterY := Printer.PageHeight - FMarginBottom + 20;
  DrawLine(FooterY - 10);

  FooterText := Format('Page %d - Imprim√© le %s',
    [APageNumber, FormatDateTime('dd/mm/yyyy √† hh:nn', Now)]);
  Printer.Canvas.Font.Size := 8;
  Printer.Canvas.TextOut(FMarginLeft, FooterY, FooterText);
end;

procedure TSimplePrinter.DrawLine(Y: Integer);
begin
  Printer.Canvas.MoveTo(FMarginLeft, Y);
  Printer.Canvas.LineTo(Printer.PageWidth - FMarginRight, Y);
end;

end.
```

### 2. Utilisation du TPrinter pour une liste de clients

```pascal
procedure ImprimerListeClients(AClients: TList<TClient>);
var
  SimplePrinter: TSimplePrinter;
  Client: TClient;
  PrintDialog: TPrintDialog;
  PageNumber: Integer;
begin
  PrintDialog := TPrintDialog.Create(nil);
  try
    if not PrintDialog.Execute then
      Exit;

    SimplePrinter := TSimplePrinter.Create;
    try
      SimplePrinter.BeginDoc('Liste des clients');
      SimplePrinter.PrintHeader;
      SimplePrinter.PrintTitle('LISTE DES CLIENTS');

      SimplePrinter.PrintLine('', []);
      SimplePrinter.PrintLine('Code      Nom                    Email                     Ville', [fsBold]);
      SimplePrinter.DrawLine(SimplePrinter.FCurrentY);
      Inc(SimplePrinter.FCurrentY, 20);

      PageNumber := 1;

      for Client in AClients do
      begin
        SimplePrinter.PrintLine(
          Format('%-10s %-20s %-25s %s', [
            Client.CodeClient,
            Client.GetNomComplet,
            Client.Email,
            Client.Ville
          ])
        );

        // G√©rer les sauts de page
        if SimplePrinter.FCurrentY > (Printer.PageHeight - SimplePrinter.MarginBottom - 100) then
        begin
          SimplePrinter.PrintFooter(PageNumber);
          SimplePrinter.NewPage;
          SimplePrinter.PrintHeader;
          Inc(PageNumber);
        end;
      end;

      SimplePrinter.PrintFooter(PageNumber);
      SimplePrinter.EndDoc;

      ShowMessage('Impression termin√©e');

    finally
      SimplePrinter.Free;
    end;
  finally
    PrintDialog.Free;
  end;
end;
```

## Aper√ßu avant impression

### 1. Cr√©ation d'un composant d'aper√ßu

```pascal
unit uPrintPreview;

interface

uses
  Winapi.Windows, System.SysUtils, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls,
  Vcl.ComCtrls, Vcl.Buttons;

type
  TFormPrintPreview = class(TForm)
    ScrollBox: TScrollBox;
    ImagePreview: TImage;
    pnlToolbar: TPanel;
    btnPrint: TButton;
    btnClose: TButton;
    btnZoomIn: TSpeedButton;
    btnZoomOut: TSpeedButton;
    btnZoomFit: TSpeedButton;
    lblZoom: TLabel;
    trackZoom: TTrackBar;

    procedure FormCreate(Sender: TObject);
    procedure btnPrintClick(Sender: TObject);
    procedure btnCloseClick(Sender: TObject);
    procedure btnZoomInClick(Sender: TObject);
    procedure btnZoomOutClick(Sender: TObject);
    procedure btnZoomFitClick(Sender: TObject);
    procedure trackZoomChange(Sender: TObject);
  private
    FBitmap: TBitmap;
    FZoomLevel: Integer;
    procedure RenderPreview;
    procedure UpdateZoomDisplay;
  public
    procedure LoadFromMetafile(AMetafile: TMetafile);
    property ZoomLevel: Integer read FZoomLevel write FZoomLevel;
  end;

implementation

{$R *.dfm}

uses
  Vcl.Printers;

{ TFormPrintPreview }

procedure TFormPrintPreview.FormCreate(Sender: TObject);
begin
  FBitmap := TBitmap.Create;
  FZoomLevel := 100;

  trackZoom.Min := 25;
  trackZoom.Max := 200;
  trackZoom.Position := FZoomLevel;

  UpdateZoomDisplay;
end;

procedure TFormPrintPreview.LoadFromMetafile(AMetafile: TMetafile);
var
  Scale: Double;
begin
  // Cr√©er un bitmap √† partir du m√©tafile
  FBitmap.Width := AMetafile.Width;
  FBitmap.Height := AMetafile.Height;
  FBitmap.Canvas.Draw(0, 0, AMetafile);

  RenderPreview;
end;

procedure TFormPrintPreview.RenderPreview;
var
  NewWidth, NewHeight: Integer;
begin
  // Calculer les nouvelles dimensions selon le zoom
  NewWidth := Round(FBitmap.Width * FZoomLevel / 100);
  NewHeight := Round(FBitmap.Height * FZoomLevel / 100);

  // Redimensionner l'image d'aper√ßu
  ImagePreview.Picture.Bitmap.Width := NewWidth;
  ImagePreview.Picture.Bitmap.Height := NewHeight;
  ImagePreview.Picture.Bitmap.Canvas.StretchDraw(
    Rect(0, 0, NewWidth, NewHeight),
    FBitmap
  );

  ImagePreview.Width := NewWidth;
  ImagePreview.Height := NewHeight;
end;

procedure TFormPrintPreview.UpdateZoomDisplay;
begin
  lblZoom.Caption := Format('Zoom: %d%%', [FZoomLevel]);
end;

procedure TFormPrintPreview.btnZoomInClick(Sender: TObject);
begin
  if FZoomLevel < 200 then
  begin
    Inc(FZoomLevel, 25);
    trackZoom.Position := FZoomLevel;
    RenderPreview;
    UpdateZoomDisplay;
  end;
end;

procedure TFormPrintPreview.btnZoomOutClick(Sender: TObject);
begin
  if FZoomLevel > 25 then
  begin
    Dec(FZoomLevel, 25);
    trackZoom.Position := FZoomLevel;
    RenderPreview;
    UpdateZoomDisplay;
  end;
end;

procedure TFormPrintPreview.btnZoomFitClick(Sender: TObject);
var
  ScaleWidth, ScaleHeight, Scale: Double;
begin
  ScaleWidth := ScrollBox.Width / FBitmap.Width;
  ScaleHeight := ScrollBox.Height / FBitmap.Height;
  Scale := Min(ScaleWidth, ScaleHeight);

  FZoomLevel := Round(Scale * 100);
  trackZoom.Position := FZoomLevel;
  RenderPreview;
  UpdateZoomDisplay;
end;

procedure TFormPrintPreview.trackZoomChange(Sender: TObject);
begin
  FZoomLevel := trackZoom.Position;
  RenderPreview;
  UpdateZoomDisplay;
end;

procedure TFormPrintPreview.btnPrintClick(Sender: TObject);
var
  PrintDialog: TPrintDialog;
begin
  PrintDialog := TPrintDialog.Create(Self);
  try
    if PrintDialog.Execute then
    begin
      // Imprimer le document
      ShowMessage('Document envoy√© √† l''imprimante');
      Close;
    end;
  finally
    PrintDialog.Free;
  end;
end;

procedure TFormPrintPreview.btnCloseClick(Sender: TObject);
begin
  Close;
end;

end.
```

## FastReport : Solution professionnelle

FastReport est un g√©n√©rateur de rapports puissant int√©gr√© √† Delphi.

### 1. Configuration de FastReport

```pascal
unit uReportManager;

interface

uses
  System.SysUtils, System.Classes, FireDAC.Comp.Client,
  frxClass, frxDBSet, frxExportPDF, frxExportXLS, frxExportCSV;

type
  TReportManager = class
  private
    FReport: TfrxReport;
    FDataSet: TfrxDBDataset;
    FPDFExport: TfrxPDFExport;
    FExcelExport: TfrxXLSExport;
    FCSVExport: TfrxCSVExport;
  public
    constructor Create;
    destructor Destroy; override;

    procedure LoadTemplate(const AFileName: string);
    procedure SetDataSource(ADataSet: TFDQuery);
    procedure Preview;
    procedure Print;
    procedure ExportToPDF(const AFileName: string);
    procedure ExportToExcel(const AFileName: string);
    procedure ExportToCSV(const AFileName: string);
    procedure SetVariable(const AName: string; const AValue: Variant);
  end;

implementation

{ TReportManager }

constructor TReportManager.Create;
begin
  inherited Create;

  FReport := TfrxReport.Create(nil);
  FDataSet := TfrxDBDataset.Create(nil);
  FPDFExport := TfrxPDFExport.Create(nil);
  FExcelExport := TfrxXLSExport.Create(nil);
  FCSVExport := TfrxCSVExport.Create(nil);

  // Configuration de l'export PDF
  FPDFExport.ShowDialog := False;
  FPDFExport.ShowProgress := True;
  FPDFExport.OverwritePrompt := True;

  // Configuration de l'export Excel
  FExcelExport.ShowDialog := False;
  FExcelExport.ShowProgress := True;
  FExcelExport.OverwritePrompt := True;
end;

destructor TReportManager.Destroy;
begin
  FReport.Free;
  FDataSet.Free;
  FPDFExport.Free;
  FExcelExport.Free;
  FCSVExport.Free;
  inherited;
end;

procedure TReportManager.LoadTemplate(const AFileName: string);
begin
  if not FileExists(AFileName) then
    raise Exception.CreateFmt('Fichier de rapport introuvable : %s', [AFileName]);

  FReport.LoadFromFile(AFileName);
end;

procedure TReportManager.SetDataSource(ADataSet: TFDQuery);
begin
  FDataSet.DataSet := ADataSet;
  FReport.DataSets.Clear;
  FReport.DataSets.Add(FDataSet);
end;

procedure TReportManager.Preview;
begin
  FReport.ShowReport;
end;

procedure TReportManager.Print;
begin
  FReport.PrepareReport;
  FReport.Print;
end;

procedure TReportManager.ExportToPDF(const AFileName: string);
begin
  FReport.PrepareReport;
  FPDFExport.FileName := AFileName;
  FReport.Export(FPDFExport);
end;

procedure TReportManager.ExportToExcel(const AFileName: string);
begin
  FReport.PrepareReport;
  FExcelExport.FileName := AFileName;
  FReport.Export(FExcelExport);
end;

procedure TReportManager.ExportToCSV(const AFileName: string);
begin
  FReport.PrepareReport;
  FCSVExport.FileName := AFileName;
  FReport.Export(FCSVExport);
end;

procedure TReportManager.SetVariable(const AName: string; const AValue: Variant);
begin
  FReport.Variables[AName] := AValue;
end;

end.
```

### 2. Utilisation de FastReport pour un rapport de clients

```pascal
procedure GenererRapportClients;
var
  ReportManager: TReportManager;
  Query: TFDQuery;
  SaveDialog: TSaveDialog;
begin
  ReportManager := TReportManager.Create;
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := dmConnection.FDConnection;
    Query.SQL.Text :=
      'SELECT ' +
      '  code_client, nom, prenom, raison_sociale, ' +
      '  email, telephone, ville, pays ' +
      'FROM CLIENTS ' +
      'WHERE actif = 1 ' +
      'ORDER BY nom, prenom';
    Query.Open;

    // Charger le mod√®le de rapport
    ReportManager.LoadTemplate('Reports\ListeClients.fr3');

    // D√©finir les variables
    ReportManager.SetVariable('TitreRapport', 'Liste des clients actifs');
    ReportManager.SetVariable('DateImpression', DateToStr(Now));
    ReportManager.SetVariable('NombreClients', Query.RecordCount);

    // Associer les donn√©es
    ReportManager.SetDataSource(Query);

    // Choix de l'action
    case MessageDlg('Que souhaitez-vous faire ?', mtConfirmation,
      [mbYes, mbNo, mbCancel], 0) of

      mrYes: // Aper√ßu
        ReportManager.Preview;

      mrNo: // Export PDF
        begin
          SaveDialog := TSaveDialog.Create(nil);
          try
            SaveDialog.Filter := 'Fichiers PDF (*.pdf)|*.pdf';
            SaveDialog.DefaultExt := 'pdf';
            SaveDialog.FileName := 'ListeClients_' + FormatDateTime('yyyymmdd', Now);

            if SaveDialog.Execute then
            begin
              ReportManager.ExportToPDF(SaveDialog.FileName);
              ShowMessage('Rapport export√© avec succ√®s');
            end;
          finally
            SaveDialog.Free;
          end;
        end;

      mrCancel: // Impression directe
        ReportManager.Print;
    end;

  finally
    Query.Free;
    ReportManager.Free;
  end;
end;
```

## G√©n√©ration de factures

### 1. Classe pour g√©n√©rer une facture

```pascal
unit uFactureGenerator;

interface

uses
  System.SysUtils, System.Classes, Vcl.Graphics, Vcl.Printers,
  uFacture, uClient, uLigneFacture;

type
  TFactureGenerator = class
  private
    FFacture: TFacture;
    FClient: TClient;
    FCurrentY: Integer;
    FMarginLeft: Integer;
    FMarginTop: Integer;
    FColumnX1, FColumnX2, FColumnX3, FColumnX4, FColumnX5: Integer;

    procedure PrintHeader;
    procedure PrintClientInfo;
    procedure PrintFactureInfo;
    procedure PrintTableHeader;
    procedure PrintLignes;
    procedure PrintTotaux;
    procedure PrintFooter;
    procedure DrawLine(Y: Integer; Thickness: Integer = 1);
    procedure SetupColumns;
  public
    constructor Create(AFacture: TFacture; AClient: TClient);

    procedure Generate;
    procedure Preview;
    procedure ExportToPDF(const AFileName: string);
  end;

implementation

uses
  Winapi.Windows;

{ TFactureGenerator }

constructor TFactureGenerator.Create(AFacture: TFacture; AClient: TClient);
begin
  inherited Create;
  FFacture := AFacture;
  FClient := AClient;
  FMarginLeft := 100;
  FMarginTop := 100;
  SetupColumns;
end;

procedure TFactureGenerator.SetupColumns;
var
  PageWidth: Integer;
begin
  PageWidth := Printer.PageWidth;
  FColumnX1 := FMarginLeft; // Description
  FColumnX2 := PageWidth - 500; // Quantit√©
  FColumnX3 := PageWidth - 400; // Prix unitaire
  FColumnX4 := PageWidth - 300; // TVA
  FColumnX5 := PageWidth - 200; // Total
end;

procedure TFactureGenerator.Generate;
begin
  Printer.Title := 'Facture ' + FFacture.NumeroFacture;
  Printer.BeginDoc;
  try
    FCurrentY := FMarginTop;

    PrintHeader;
    PrintClientInfo;
    PrintFactureInfo;
    PrintTableHeader;
    PrintLignes;
    PrintTotaux;
    PrintFooter;

  finally
    Printer.EndDoc;
  end;
end;

procedure TFactureGenerator.PrintHeader;
begin
  // Logo et informations de l'entreprise
  Printer.Canvas.Font.Size := 18;
  Printer.Canvas.Font.Style := [fsBold];
  Printer.Canvas.Font.Color := clNavy;
  Printer.Canvas.TextOut(FMarginLeft, FCurrentY, 'VOTRE ENTREPRISE');

  Printer.Canvas.Font.Size := 10;
  Printer.Canvas.Font.Style := [];
  Printer.Canvas.Font.Color := clBlack;
  Inc(FCurrentY, 60);

  Printer.Canvas.TextOut(FMarginLeft, FCurrentY, '123 Rue du Commerce');
  Inc(FCurrentY, 25);
  Printer.Canvas.TextOut(FMarginLeft, FCurrentY, '75000 PARIS');
  Inc(FCurrentY, 25);
  Printer.Canvas.TextOut(FMarginLeft, FCurrentY, 'T√©l : 01 23 45 67 89');
  Inc(FCurrentY, 25);
  Printer.Canvas.TextOut(FMarginLeft, FCurrentY, 'Email : contact@entreprise.fr');
  Inc(FCurrentY, 25);
  Printer.Canvas.TextOut(FMarginLeft, FCurrentY, 'SIRET : 123 456 789 00012');

  Inc(FCurrentY, 60);
end;

procedure TFactureGenerator.PrintClientInfo;
var
  RightX: Integer;
begin
  RightX := Printer.PageWidth - 300;

  // Adresse de facturation
  Printer.Canvas.Font.Size := 10;
  Printer.Canvas.Font.Style := [fsBold];
  Printer.Canvas.TextOut(RightX, FCurrentY, 'FACTUR√â √Ä :');
  Inc(FCurrentY, 30);

  Printer.Canvas.Font.Style := [];
  Printer.Canvas.TextOut(RightX, FCurrentY, FClient.GetNomComplet);
  Inc(FCurrentY, 25);

  if FClient.Adresse <> '' then
  begin
    Printer.Canvas.TextOut(RightX, FCurrentY, FClient.Adresse);
    Inc(FCurrentY, 25);
  end;

  Printer.Canvas.TextOut(RightX, FCurrentY,
    Format('%s %s', [FClient.CodePostal, FClient.Ville]));
  Inc(FCurrentY, 25);

  if FClient.Pays <> 'France' then
  begin
    Printer.Canvas.TextOut(RightX, FCurrentY, FClient.Pays);
    Inc(FCurrentY, 25);
  end;

  Inc(FCurrentY, 40);
end;

procedure TFactureGenerator.PrintFactureInfo;
begin
  FCurrentY := FMarginTop + 300;

  // Titre de la facture
  Printer.Canvas.Font.Size := 20;
  Printer.Canvas.Font.Style := [fsBold];
  Printer.Canvas.Font.Color := clNavy;
  Printer.Canvas.TextOut(FMarginLeft, FCurrentY, 'FACTURE');

  Inc(FCurrentY, 60);
  Printer.Canvas.Font.Size := 12;
  Printer.Canvas.Font.Style := [];
  Printer.Canvas.Font.Color := clBlack;

  // Informations de la facture
  Printer.Canvas.TextOut(FMarginLeft, FCurrentY,
    'Facture N¬∞ : ' + FFacture.NumeroFacture);
  Inc(FCurrentY, 30);

  Printer.Canvas.TextOut(FMarginLeft, FCurrentY,
    'Date : ' + DateToStr(FFacture.DateFacture));
  Inc(FCurrentY, 30);

  Printer.Canvas.TextOut(FMarginLeft, FCurrentY,
    '√âch√©ance : ' + DateToStr(FFacture.DateEcheance));
  Inc(FCurrentY, 30);

  if FFacture.NumeroCommande <> '' then
  begin
    Printer.Canvas.TextOut(FMarginLeft, FCurrentY,
      'Commande N¬∞ : ' + FFacture.NumeroCommande);
    Inc(FCurrentY, 30);
  end;

  Inc(FCurrentY, 40);
  DrawLine(FCurrentY, 2);
  Inc(FCurrentY, 40);
end;

procedure TFactureGenerator.PrintTableHeader;
begin
  Printer.Canvas.Font.Size := 10;
  Printer.Canvas.Font.Style := [fsBold];
  Printer.Canvas.Brush.Color := $00F0F0F0;

  // Dessiner le fond de l'en-t√™te
  Printer.Canvas.FillRect(Rect(
    FMarginLeft,
    FCurrentY - 5,
    Printer.PageWidth - FMarginLeft,
    FCurrentY + 35
  ));

  // En-t√™tes de colonnes
  Printer.Canvas.TextOut(FColumnX1 + 10, FCurrentY, 'Description');
  Printer.Canvas.TextOut(FColumnX2, FCurrentY, 'Qt√©');
  Printer.Canvas.TextOut(FColumnX3, FCurrentY, 'P.U. HT');
  Printer.Canvas.TextOut(FColumnX4, FCurrentY, 'TVA');
  Printer.Canvas.TextOut(FColumnX5, FCurrentY, 'Total TTC');

  Inc(FCurrentY, 40);
  DrawLine(FCurrentY);
  Inc(FCurrentY, 20);

  Printer.Canvas.Font.Style := [];
  Printer.Canvas.Brush.Color := clWhite;
end;

procedure TFactureGenerator.PrintLignes;
var
  Ligne: TLigneFacture;
  Description: string;
begin
  Printer.Canvas.Font.Size := 9;

  for Ligne in FFacture.Lignes do
  begin
    // V√©rifier si on d√©passe la page
    if FCurrentY > (Printer.PageHeight - 400) then
    begin
      Printer.NewPage;
      FCurrentY := FMarginTop;
      PrintTableHeader;
    end;

    // Description
    Description := Ligne.NomProduit;
    Printer.Canvas.TextOut(FColumnX1 + 10, FCurrentY, Description);

    // Quantit√©
    Printer.Canvas.TextOut(FColumnX2, FCurrentY,
      IntToStr(Ligne.Quantite));

    // Prix unitaire HT
    Printer.Canvas.TextOut(FColumnX3, FCurrentY,
      FormatFloat('#,##0.00', Ligne.PrixUnitaire));

    // Taux TVA
    Printer.Canvas.TextOut(FColumnX4, FCurrentY,
      FormatFloat('0.0', Ligne.TauxTVA) + '%');

    // Total TTC
    Printer.Canvas.TextOut(FColumnX5, FCurrentY,
      FormatFloat('#,##0.00', Ligne.MontantLigneTTC));

    Inc(FCurrentY, 30);
  end;

  Inc(FCurrentY, 20);
  DrawLine(FCurrentY);
  Inc(FCurrentY, 30);
end;

procedure TFactureGenerator.PrintTotaux;
var
  LabelX, ValueX: Integer;
begin
  LabelX := Printer.PageWidth - 400;
  ValueX := Printer.PageWidth - 200;

  Printer.Canvas.Font.Size := 10;

  // Total HT
  Printer.Canvas.TextOut(LabelX, FCurrentY, 'Total HT :');
  Printer.Canvas.TextOut(ValueX, FCurrentY,
    FormatFloat('#,##0.00', FFacture.MontantHT) + ' ‚Ç¨');
  Inc(FCurrentY, 30);

  // TVA
  Printer.Canvas.TextOut(LabelX, FCurrentY, 'TVA :');
  Printer.Canvas.TextOut(ValueX, FCurrentY,
    FormatFloat('#,##0.00', FFacture.MontantTVA) + ' ‚Ç¨');
  Inc(FCurrentY, 30);

  // Ligne de s√©paration
  DrawLine(FCurrentY);
  Inc(FCurrentY, 10);

  // Total TTC
  Printer.Canvas.Font.Size := 14;
  Printer.Canvas.Font.Style := [fsBold];
  Printer.Canvas.TextOut(LabelX, FCurrentY, 'Total TTC :');
  Printer.Canvas.TextOut(ValueX, FCurrentY,
    FormatFloat('#,##0.00', FFacture.MontantTTC) + ' ‚Ç¨');

  Printer.Canvas.Font.Size := 10;
  Printer.Canvas.Font.Style := [];
  Inc(FCurrentY, 50);
end;

procedure TFactureGenerator.PrintFooter;
var
  FooterY: Integer;
begin
  FooterY := Printer.PageHeight - 200;

  // Conditions de paiement
  Printer.Canvas.Font.Size := 9;
  Printer.Canvas.Font.Style := [fsItalic];

  Printer.Canvas.TextOut(FMarginLeft, FooterY,
    'Conditions de paiement : Paiement √† r√©ception');
  Inc(FooterY, 25);

  Printer.Canvas.TextOut(FMarginLeft, FooterY,
    'Mode de paiement : ' + FFacture.ModePaiement);
  Inc(FooterY, 25);

  if FFacture.Notes <> '' then
  begin
    Printer.Canvas.TextOut(FMarginLeft, FooterY,
      'Notes : ' + FFacture.Notes);
    Inc(FooterY, 25);
  end;

  Inc(FooterY, 30);
  DrawLine(FooterY);
  Inc(FooterY, 20);

  Printer.Canvas.Font.Size := 8;
  Printer.Canvas.Font.Style := [];
  Printer.Canvas.TextOut(FMarginLeft, FooterY,
    'TVA non applicable, article 293 B du CGI');
end;

procedure TFactureGenerator.DrawLine(Y: Integer; Thickness: Integer);
var
  I: Integer;
begin
  for I := 0 to Thickness - 1 do
  begin
    Printer.Canvas.MoveTo(FMarginLeft, Y + I);
    Printer.Canvas.LineTo(Printer.PageWidth - FMarginLeft, Y + I);
  end;
end;

procedure TFactureGenerator.Preview;
begin
  // Cr√©er un aper√ßu (√† impl√©menter avec TFormPrintPreview)
  Generate;
end;

procedure TFactureGenerator.ExportToPDF(const AFileName: string);
begin
  // Utiliser un composant d'export PDF
  // Exemple avec FastReport ou un autre outil
  Generate;
end;

end.
```

## Tableaux de bord avec TeeChart

### 1. Configuration de TeeChart

```pascal
unit uDashboardCharts;

interface

uses
  System.SysUtils, System.Classes, Vcl.Controls, Vcl.Forms,
  VCLTee.TeEngine, VCLTee.Series, VCLTee.TeeProcs, VCLTee.Chart,
  VCLTee.TeeGDIPlus, FireDAC.Comp.Client, Data.DB;

type
  TDashboardCharts = class
  private
    FConnection: TFDConnection;
  public
    constructor Create(AConnection: TFDConnection);

    // Graphiques de ventes
    procedure CreateVentesParMoisChart(AChart: TChart);
    procedure CreateVentesParCategorieChart(AChart: TChart);
    procedure CreateEvolutionCAChart(AChart: TChart);

    // Graphiques de produits
    procedure CreateTopProduitsChart(AChart: TChart; ATop: Integer = 10);
    procedure CreateStockChart(AChart: TChart);

    // Graphiques clients
    procedure CreateRepartitionClientsChart(AChart: TChart);
    procedure CreateTopClientsChart(AChart: TChart; ATop: Integer = 10);

    // Utilitaires
    procedure StyleChart(AChart: TChart; const ATitle: string);
  end;

implementation

uses
  Vcl.Graphics;

{ TDashboardCharts }

constructor TDashboardCharts.Create(AConnection: TFDConnection);
begin
  inherited Create;
  FConnection := AConnection;
end;

procedure TDashboardCharts.StyleChart(AChart: TChart; const ATitle: string);
begin
  AChart.Title.Text.Text := ATitle;
  AChart.Title.Font.Size := 12;
  AChart.Title.Font.Style := [fsBold];
  AChart.Title.Font.Color := clNavy;

  AChart.Legend.Visible := True;
  AChart.Legend.Alignment := laBottom;
  AChart.Legend.LegendStyle := lsSeries;

  AChart.View3D := False;
  AChart.Gradient.Visible := True;
  AChart.Gradient.StartColor := clWhite;
  AChart.Gradient.EndColor := $00F5F5F5;

  AChart.BevelOuter := bvNone;
  AChart.Color := clWhite;
end;

procedure TDashboardCharts.CreateVentesParMoisChart(AChart: TChart);
var
  Query: TFDQuery;
  Series: TBarSeries;
begin
  StyleChart(AChart, 'Ventes par mois (12 derniers mois)');

  AChart.SeriesList.Clear;
  Series := TBarSeries.Create(AChart);
  Series.ParentChart := AChart;
  Series.Marks.Visible := True;
  Series.Marks.Style := smsValue;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection;
    Query.SQL.Text :=
      'SELECT ' +
      '  DATE_FORMAT(date_commande, ''%Y-%m'') AS mois, ' +
      '  DATE_FORMAT(date_commande, ''%b %Y'') AS mois_nom, ' +
      '  SUM(montant_ttc) AS total ' +
      'FROM COMMANDES ' +
      'WHERE date_commande >= DATE_SUB(CURDATE(), INTERVAL 12 MONTH) ' +
      'GROUP BY DATE_FORMAT(date_commande, ''%Y-%m''), ' +
      '         DATE_FORMAT(date_commande, ''%b %Y'') ' +
      'ORDER BY mois';
    Query.Open;

    while not Query.Eof do
    begin
      Series.Add(
        Query.FieldByName('total').AsFloat,
        Query.FieldByName('mois_nom').AsString,
        clTeeColor
      );
      Query.Next;
    end;
  finally
    Query.Free;
  end;
end;

procedure TDashboardCharts.CreateVentesParCategorieChart(AChart: TChart);
var
  Query: TFDQuery;
  Series: TPieSeries;
begin
  StyleChart(AChart, 'R√©partition des ventes par cat√©gorie');

  AChart.SeriesList.Clear;
  Series := TPieSeries.Create(AChart);
  Series.ParentChart := AChart;
  Series.Marks.Visible := True;
  Series.Marks.Style := smsLabelPercent;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection;
    Query.SQL.Text :=
      'SELECT ' +
      '  c.nom_categorie, ' +
      '  SUM(lc.montant_ligne_ttc) AS total ' +
      'FROM LIGNES_COMMANDE lc ' +
      'INNER JOIN PRODUITS p ON lc.id_produit = p.id_produit ' +
      'INNER JOIN CATEGORIES c ON p.id_categorie = c.id_categorie ' +
      'INNER JOIN COMMANDES cmd ON lc.id_commande = cmd.id_commande ' +
      'WHERE cmd.date_commande >= DATE_SUB(CURDATE(), INTERVAL 12 MONTH) ' +
      'GROUP BY c.id_categorie, c.nom_categorie ' +
      'ORDER BY total DESC';
    Query.Open;

    while not Query.Eof do
    begin
      Series.Add(
        Query.FieldByName('total').AsFloat,
        Query.FieldByName('nom_categorie').AsString,
        clTeeColor
      );
      Query.Next;
    end;
  finally
    Query.Free;
  end;
end;

procedure TDashboardCharts.CreateEvolutionCAChart(AChart: TChart);
var
  Query: TFDQuery;
  Series: TLineSeries;
begin
  StyleChart(AChart, '√âvolution du chiffre d''affaires');

  AChart.SeriesList.Clear;
  Series := TLineSeries.Create(AChart);
  Series.ParentChart := AChart;
  Series.Marks.Visible := False;
  Series.LinePen.Width := 2;
  Series.Pointer.Visible := True;
  Series.Pointer.Style := psCircle;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection;
    Query.SQL.Text :=
      'SELECT ' +
      '  DATE(date_commande) AS jour, ' +
      '  SUM(montant_ttc) AS total ' +
      'FROM COMMANDES ' +
      'WHERE date_commande >= DATE_SUB(CURDATE(), INTERVAL 30 DAY) ' +
      'GROUP BY DATE(date_commande) ' +
      'ORDER BY jour';
    Query.Open;

    while not Query.Eof do
    begin
      Series.AddXY(
        Query.FieldByName('jour').AsDateTime,
        Query.FieldByName('total').AsFloat
      );
      Query.Next;
    end;
  finally
    Query.Free;
  end;
end;

procedure TDashboardCharts.CreateTopProduitsChart(AChart: TChart; ATop: Integer);
var
  Query: TFDQuery;
  Series: THorizBarSeries;
begin
  StyleChart(AChart, Format('Top %d des produits', [ATop]));

  AChart.SeriesList.Clear;
  Series := THorizBarSeries.Create(AChart);
  Series.ParentChart := AChart;
  Series.Marks.Visible := True;
  Series.Marks.Style := smsValue;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection;
    Query.SQL.Text :=
      'SELECT ' +
      '  p.nom_produit, ' +
      '  SUM(lc.quantite) AS total_vendu ' +
      'FROM LIGNES_COMMANDE lc ' +
      'INNER JOIN PRODUITS p ON lc.id_produit = p.id_produit ' +
      'INNER JOIN COMMANDES c ON lc.id_commande = c.id_commande ' +
      'WHERE c.date_commande >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH) ' +
      'GROUP BY p.id_produit, p.nom_produit ' +
      'ORDER BY total_vendu DESC ' +
      'LIMIT :top';
    Query.ParamByName('top').AsInteger := ATop;
    Query.Open;

    while not Query.Eof do
    begin
      Series.Add(
        Query.FieldByName('total_vendu').AsFloat,
        Query.FieldByName('nom_produit').AsString,
        clTeeColor
      );
      Query.Next;
    end;
  finally
    Query.Free;
  end;
end;

procedure TDashboardCharts.CreateStockChart(AChart: TChart);
var
  Query: TFDQuery;
  SeriesStock, SeriesMin: TBarSeries;
begin
  StyleChart(AChart, '√âtat des stocks');

  AChart.SeriesList.Clear;

  // S√©rie pour le stock actuel
  SeriesStock := TBarSeries.Create(AChart);
  SeriesStock.ParentChart := AChart;
  SeriesStock.Title := 'Stock actuel';
  SeriesStock.Marks.Visible := True;

  // S√©rie pour le stock minimum
  SeriesMin := TBarSeries.Create(AChart);
  SeriesMin.ParentChart := AChart;
  SeriesMin.Title := 'Stock minimum';
  SeriesMin.Color := clRed;
  SeriesMin.Marks.Visible := False;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection;
    Query.SQL.Text :=
      'SELECT ' +
      '  nom_produit, ' +
      '  quantite_stock, ' +
      '  stock_minimum ' +
      'FROM PRODUITS ' +
      'WHERE actif = 1 ' +
      'AND (quantite_stock < stock_minimum * 1.5) ' +
      'ORDER BY quantite_stock / stock_minimum ' +
      'LIMIT 15';
    Query.Open;

    while not Query.Eof do
    begin
      SeriesStock.Add(
        Query.FieldByName('quantite_stock').AsFloat,
        Query.FieldByName('nom_produit').AsString,
        clTeeColor
      );

      SeriesMin.Add(
        Query.FieldByName('stock_minimum').AsFloat,
        '',
        clRed
      );

      Query.Next;
    end;
  finally
    Query.Free;
  end;
end;

procedure TDashboardCharts.CreateRepartitionClientsChart(AChart: TChart);
var
  Query: TFDQuery;
  Series: TPieSeries;
begin
  StyleChart(AChart, 'R√©partition des clients');

  AChart.SeriesList.Clear;
  Series := TPieSeries.Create(AChart);
  Series.ParentChart := AChart;
  Series.Marks.Visible := True;
  Series.Marks.Style := smsLabelPercent;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection;
    Query.SQL.Text :=
      'SELECT ' +
      '  type_client, ' +
      '  COUNT(*) AS nombre ' +
      'FROM CLIENTS ' +
      'WHERE actif = 1 ' +
      'GROUP BY type_client';
    Query.Open;

    while not Query.Eof do
    begin
      Series.Add(
        Query.FieldByName('nombre').AsFloat,
        Query.FieldByName('type_client').AsString,
        clTeeColor
      );
      Query.Next;
    end;
  finally
    Query.Free;
  end;
end;

procedure TDashboardCharts.CreateTopClientsChart(AChart: TChart; ATop: Integer);
var
  Query: TFDQuery;
  Series: THorizBarSeries;
begin
  StyleChart(AChart, Format('Top %d des clients', [ATop]));

  AChart.SeriesList.Clear;
  Series := THorizBarSeries.Create(AChart);
  Series.ParentChart := AChart;
  Series.Marks.Visible := True;
  Series.Marks.Style := smsValue;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FConnection;
    Query.SQL.Text :=
      'SELECT ' +
      '  c.nom, ' +
      '  c.prenom, ' +
      '  c.raison_sociale, ' +
      '  SUM(cmd.montant_ttc) AS ca_total ' +
      'FROM CLIENTS c ' +
      'INNER JOIN COMMANDES cmd ON c.id_client = cmd.id_client ' +
      'WHERE cmd.date_commande >= DATE_SUB(CURDATE(), INTERVAL 12 MONTH) ' +
      'GROUP BY c.id_client, c.nom, c.prenom, c.raison_sociale ' +
      'ORDER BY ca_total DESC ' +
      'LIMIT :top';
    Query.ParamByName('top').AsInteger := ATop;
    Query.Open;

    while not Query.Eof do
    begin
      var NomClient: string;
      if Query.FieldByName('raison_sociale').AsString <> '' then
        NomClient := Query.FieldByName('raison_sociale').AsString
      else
        NomClient := Query.FieldByName('prenom').AsString + ' ' +
                     Query.FieldByName('nom').AsString;

      Series.Add(
        Query.FieldByName('ca_total').AsFloat,
        NomClient,
        clTeeColor
      );
      Query.Next;
    end;
  finally
    Query.Free;
  end;
end;

end.
```

### 2. Formulaire de tableau de bord complet

```pascal
unit uFormDashboardComplete;

interface

uses
  Winapi.Windows, System.SysUtils, System.Classes, Vcl.Controls,
  Vcl.Forms, Vcl.ExtCtrls, Vcl.StdCtrls, Vcl.ComCtrls,
  VCLTee.TeEngine, VCLTee.Series, VCLTee.TeeProcs, VCLTee.Chart,
  uDashboardCharts, uDMConnection;

type
  TFormDashboardComplete = class(TForm)
    pnlTop: TPanel;
    pnlKPI: TPanel;
    PageControl: TPageControl;

    // Onglets
    tabVentes: TTabSheet;
    tabProduits: TTabSheet;
    tabClients: TTabSheet;

    // KPI Cards
    pnlCAJour: TPanel;
    lblCAJour: TLabel;
    lblCAJourValeur: TLabel;

    pnlCAMois: TPanel;
    lblCAMois: TLabel;
    lblCAMoisValeur: TLabel;

    pnlNbCommandes: TPanel;
    lblNbCommandes: TLabel;
    lblNbCommandesValeur: TLabel;

    pnlNbClients: TPanel;
    lblNbClients: TLabel;
    lblNbClientsValeur: TLabel;

    // Charts - Ventes
    chartVentesMois: TChart;
    chartVentesCategories: TChart;
    chartEvolutionCA: TChart;

    // Charts - Produits
    chartTopProduits: TChart;
    chartStock: TChart;

    // Charts - Clients
    chartRepartitionClients: TChart;
    chartTopClients: TChart;

    // Boutons
    btnRefresh: TButton;
    btnExport: TButton;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure btnRefreshClick(Sender: TObject);
    procedure btnExportClick(Sender: TObject);
  private
    FCharts: TDashboardCharts;
    procedure LoadKPIs;
    procedure LoadAllCharts;
    procedure StyleKPIPanel(APanel: TPanel; AColor: TColor);
  public
    { D√©clarations publiques }
  end;

implementation

{$R *.dfm}

uses
  FireDAC.Comp.Client, Vcl.Graphics;

{ TFormDashboardComplete }

procedure TFormDashboardComplete.FormCreate(Sender: TObject);
begin
  FCharts := TDashboardCharts.Create(dmConnection.FDConnection);

  // Style des panneaux KPI
  StyleKPIPanel(pnlCAJour, $00FFD54F);      // Jaune
  StyleKPIPanel(pnlCAMois, $0081C784);      // Vert
  StyleKPIPanel(pnlNbCommandes, $0064B5F6); // Bleu
  StyleKPIPanel(pnlNbClients, $00BA68C8);   // Violet
end;

procedure TFormDashboardComplete.FormDestroy(Sender: TObject);
begin
  FCharts.Free;
end;

procedure TFormDashboardComplete.FormShow(Sender: TObject);
begin
  Screen.Cursor := crHourGlass;
  try
    LoadKPIs;
    LoadAllCharts;
  finally
    Screen.Cursor := crDefault;
  end;
end;

procedure TFormDashboardComplete.StyleKPIPanel(APanel: TPanel; AColor: TColor);
begin
  APanel.Color := AColor;
  APanel.BevelOuter := bvNone;
  APanel.BorderWidth := 0;
  APanel.Font.Size := 10;
  APanel.Font.Color := clWhite;
  APanel.Font.Style := [fsBold];
end;

procedure TFormDashboardComplete.LoadKPIs;
var
  Query: TFDQuery;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := dmConnection.FDConnection;

    // CA du jour
    Query.SQL.Text :=
      'SELECT COALESCE(SUM(montant_ttc), 0) AS total ' +
      'FROM COMMANDES ' +
      'WHERE DATE(date_commande) = CURDATE()';
    Query.Open;
    lblCAJourValeur.Caption := FormatFloat('#,##0.00 ‚Ç¨',
      Query.FieldByName('total').AsFloat);
    Query.Close;

    // CA du mois
    Query.SQL.Text :=
      'SELECT COALESCE(SUM(montant_ttc), 0) AS total ' +
      'FROM COMMANDES ' +
      'WHERE MONTH(date_commande) = MONTH(CURDATE()) ' +
      'AND YEAR(date_commande) = YEAR(CURDATE())';
    Query.Open;
    lblCAMoisValeur.Caption := FormatFloat('#,##0.00 ‚Ç¨',
      Query.FieldByName('total').AsFloat);
    Query.Close;

    // Nombre de commandes du jour
    Query.SQL.Text :=
      'SELECT COUNT(*) AS total ' +
      'FROM COMMANDES ' +
      'WHERE DATE(date_commande) = CURDATE()';
    Query.Open;
    lblNbCommandesValeur.Caption := Query.FieldByName('total').AsString;
    Query.Close;

    // Nombre total de clients actifs
    Query.SQL.Text :=
      'SELECT COUNT(*) AS total ' +
      'FROM CLIENTS ' +
      'WHERE actif = 1';
    Query.Open;
    lblNbClientsValeur.Caption := Query.FieldByName('total').AsString;

  finally
    Query.Free;
  end;
end;

procedure TFormDashboardComplete.LoadAllCharts;
begin
  // Graphiques de ventes
  FCharts.CreateVentesParMoisChart(chartVentesMois);
  FCharts.CreateVentesParCategorieChart(chartVentesCategories);
  FCharts.CreateEvolutionCAChart(chartEvolutionCA);

  // Graphiques de produits
  FCharts.CreateTopProduitsChart(chartTopProduits, 10);
  FCharts.CreateStockChart(chartStock);

  // Graphiques de clients
  FCharts.CreateRepartitionClientsChart(chartRepartitionClients);
  FCharts.CreateTopClientsChart(chartTopClients, 10);
end;

procedure TFormDashboardComplete.btnRefreshClick(Sender: TObject);
begin
  FormShow(Sender);
end;

procedure TFormDashboardComplete.btnExportClick(Sender: TObject);
var
  SaveDialog: TSaveDialog;
begin
  SaveDialog := TSaveDialog.Create(Self);
  try
    SaveDialog.Filter := 'Fichiers PDF (*.pdf)|*.pdf';
    SaveDialog.DefaultExt := 'pdf';
    SaveDialog.FileName := 'Dashboard_' + FormatDateTime('yyyymmdd', Now);

    if SaveDialog.Execute then
    begin
      // Exporter le tableau de bord en PDF
      // (n√©cessite une biblioth√®que d'export PDF)
      ShowMessage('Export du tableau de bord vers : ' + SaveDialog.FileName);
    end;
  finally
    SaveDialog.Free;
  end;
end;

end.
```

## Export de donn√©es

### 1. Export vers Excel avec automation

```pascal
unit uExcelExport;

interface

uses
  System.SysUtils, System.Classes, System.Variants, Vcl.Dialogs,
  ComObj, FireDAC.Comp.Client, Data.DB;

type
  TExcelExporter = class
  private
    FExcel: OleVariant;
    FWorkbook: OleVariant;
    FWorksheet: OleVariant;
  public
    constructor Create;
    destructor Destroy; override;

    procedure ExportQuery(AQuery: TFDQuery; const ASheetName: string);
    procedure SaveAs(const AFileName: string);
    procedure Show;
    procedure Close;
  end;

implementation

{ TExcelExporter }

constructor TExcelExporter.Create;
begin
  inherited Create;
  try
    FExcel := CreateOleObject('Excel.Application');
    FWorkbook := FExcel.Workbooks.Add;
  except
    on E: Exception do
      raise Exception.Create('Excel n''est pas install√© ou n''est pas accessible : ' + E.Message);
  end;
end;

destructor TExcelExporter.Destroy;
begin
  Close;
  inherited;
end;

procedure TExcelExporter.ExportQuery(AQuery: TFDQuery; const ASheetName: string);
var
  Row, Col: Integer;
  Field: TField;
begin
  if AQuery.IsEmpty then
    raise Exception.Create('Aucune donn√©e √† exporter');

  FWorksheet := FWorkbook.Worksheets.Add;
  FWorksheet.Name := ASheetName;

  // En-t√™tes
  Col := 1;
  for Field in AQuery.Fields do
  begin
    if Field.Visible then
    begin
      FWorksheet.Cells[1, Col] := Field.DisplayLabel;
      Inc(Col);
    end;
  end;

  // Style des en-t√™tes
  FWorksheet.Range[FWorksheet.Cells[1, 1], FWorksheet.Cells[1, Col - 1]].Font.Bold := True;
  FWorksheet.Range[FWorksheet.Cells[1, 1], FWorksheet.Cells[1, Col - 1]].Interior.Color := $00E0E0E0;

  // Donn√©es
  Row := 2;
  AQuery.First;
  while not AQuery.Eof do
  begin
    Col := 1;
    for Field in AQuery.Fields do
    begin
      if Field.Visible then
      begin
        FWorksheet.Cells[Row, Col] := Field.AsVariant;
        Inc(Col);
      end;
    end;
    Inc(Row);
    AQuery.Next;
  end;

  // Auto-ajuster les colonnes
  FWorksheet.Columns.AutoFit;
end;

procedure TExcelExporter.SaveAs(const AFileName: string);
begin
  FWorkbook.SaveAs(AFileName);
end;

procedure TExcelExporter.Show;
begin
  FExcel.Visible := True;
end;

procedure TExcelExporter.Close;
begin
  if not VarIsEmpty(FExcel) then
  begin
    FExcel.Quit;
    FExcel := Unassigned;
  end;
end;

end.
```

## Conclusion

La cr√©ation de rapports et de tableaux de bord professionnels n√©cessite :
- Une bonne compr√©hension des besoins utilisateurs
- Le choix des bons outils (composants natifs, FastReport, TeeChart)
- Une pr√©sentation claire et esth√©tique des donn√©es
- Des fonctionnalit√©s d'export vers diff√©rents formats
- Des graphiques pertinents et lisibles
- Des tableaux de bord interactifs et informatifs

Les rapports sont essentiels pour :
- La prise de d√©cision
- L'analyse des performances
- La communication avec les parties prenantes
- La conformit√© r√©glementaire

Un bon syst√®me de reporting am√©liore consid√©rablement la valeur d'une application de gestion.

‚è≠Ô∏è [Application multi-plateformes avec FMX](/19-projets-avances/02-application-multi-plateformes-avec-fmx.md)
