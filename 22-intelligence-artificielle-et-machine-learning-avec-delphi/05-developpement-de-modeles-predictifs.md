üîù Retour au [Sommaire](/SOMMAIRE.md)

# 22.5 D√©veloppement de mod√®les pr√©dictifs

## Qu'est-ce qu'un mod√®le pr√©dictif ?

### D√©finition simple

Un mod√®le pr√©dictif est un syst√®me d'intelligence artificielle qui utilise des donn√©es historiques pour faire des pr√©visions sur l'avenir ou sur des situations inconnues. C'est comme un oracle math√©matique qui apprend des patterns du pass√© pour anticiper ce qui va se produire.

**Analogie simple** : Imaginez un m√©decin exp√©riment√©. Apr√®s avoir vu des milliers de patients, il peut pr√©dire avec une bonne pr√©cision si un nouveau patient risque de d√©velopper une maladie en se basant sur ses sympt√¥mes et ant√©c√©dents. Un mod√®le pr√©dictif fait la m√™me chose, mais de mani√®re automatique et √† grande √©chelle.

### Diff√©rence avec l'IA descriptive

**IA descriptive** : "Que s'est-il pass√© ?" (analyse du pass√©)
- Statistiques de ventes du dernier trimestre
- Analyse de tendances historiques
- Rapports et tableaux de bord

**IA pr√©dictive** : "Que va-t-il se passer ?" (anticipation du futur)
- Pr√©vision des ventes du prochain trimestre
- Estimation de la probabilit√© de d√©sabonnement d'un client
- Pr√©diction de pannes d'√©quipement

### Pourquoi les mod√®les pr√©dictifs sont puissants

**Automatisation des d√©cisions** : Le syst√®me peut prendre ou sugg√©rer des d√©cisions en temps r√©el sans intervention humaine constante.

**D√©tection de patterns invisibles** : Les mod√®les peuvent identifier des corr√©lations complexes que l'≈ìil humain ne verrait jamais.

**Scalabilit√©** : Une fois entra√Æn√©, un mod√®le peut traiter des millions de pr√©dictions instantan√©ment.

**Am√©lioration continue** : Les mod√®les peuvent √™tre r√©entra√Æn√©s r√©guli√®rement avec de nouvelles donn√©es pour s'am√©liorer.

## Types de mod√®les pr√©dictifs

### 1. R√©gression (Pr√©diction de valeurs num√©riques)

**Qu'est-ce que c'est ?** : Pr√©dire une valeur num√©rique continue.

**Exemples** :
- Pr√©dire le prix d'une maison en fonction de sa surface, localisation, nombre de chambres
- Estimer les ventes du prochain mois
- Calculer la dur√©e de vie restante d'un √©quipement
- Pr√©voir la temp√©rature de demain

**Types de r√©gression** :

**R√©gression lin√©aire** :
Relation simple et directe entre variables.
```
Prix maison = (Surface √ó 2000‚Ç¨) + (Chambres √ó 15000‚Ç¨) + Constante
```

**R√©gression polynomiale** :
Relations plus complexes avec courbes.

**R√©gression avec r√©seaux de neurones** :
Pour relations tr√®s complexes et non lin√©aires.

**Cas d'usage Delphi** :
Application de gestion d'inventaire qui pr√©dit les quantit√©s √† commander en fonction des tendances de vente.

### 2. Classification (Pr√©diction de cat√©gories)

**Qu'est-ce que c'est ?** : Pr√©dire une cat√©gorie ou une classe parmi plusieurs possibilit√©s.

**Classification binaire** (2 cat√©gories) :
- Client va se d√©sabonner : OUI / NON
- Transaction frauduleuse : FRAUDE / L√âGITIME
- Email : SPAM / NON SPAM
- Patient : MALADE / SAIN

**Classification multi-classes** (3+ cat√©gories) :
- Priorit√© ticket support : BASSE / MOYENNE / HAUTE / URGENTE
- Cat√©gorie produit : √âLECTRONIQUE / V√äTEMENTS / ALIMENTATION / AUTRES
- Sentiment : POSITIF / NEUTRE / N√âGATIF

**Algorithmes populaires** :
- R√©gression logistique (malgr√© son nom, c'est de la classification)
- Arbres de d√©cision
- Random Forest
- Support Vector Machines (SVM)
- R√©seaux de neurones

**Cas d'usage Delphi** :
Application CRM qui classe automatiquement les leads en "Haute probabilit√© de conversion", "Moyenne", "Faible" pour prioriser le travail des commerciaux.

### 3. S√©ries temporelles

**Qu'est-ce que c'est ?** : Pr√©dire des valeurs futures en se basant sur des s√©quences chronologiques.

**Caract√©ristiques** :
- D√©pendance temporelle (l'ordre compte)
- Saisonnalit√© possible
- Tendances √† long terme

**Exemples** :
- Pr√©vision de la demande quotidienne
- Pr√©diction de charge serveur
- Anticipation de trafic r√©seau
- Pr√©vision m√©t√©orologique

**Techniques** :
- ARIMA (AutoRegressive Integrated Moving Average)
- Prophet (Facebook)
- LSTM (Long Short-Term Memory) - r√©seaux de neurones r√©currents

**Cas d'usage Delphi** :
Application de gestion √©nerg√©tique qui pr√©dit la consommation √©lectrique pour optimiser les achats d'√©nergie.

### 4. D√©tection d'anomalies

**Qu'est-ce que c'est ?** : Identifier des observations qui diff√®rent significativement de la normale.

**Applications** :
- D√©tection de fraudes bancaires
- Surveillance d'√©quipements industriels
- Cybers√©curit√© (d√©tection d'intrusions)
- Contr√¥le qualit√©

**Approches** :
- **Statistique** : Valeurs au-del√† de X √©carts-types
- **Machine Learning** : Isolation Forest, One-Class SVM
- **Deep Learning** : Autoencoders

**Cas d'usage Delphi** :
Syst√®me de surveillance qui d√©tecte des comportements anormaux dans les logs d'application.

### 5. Clustering (Regroupement)

**Qu'est-ce que c'est ?** : Regrouper automatiquement des donn√©es similaires sans cat√©gories pr√©d√©finies.

**Diff√©rence avec classification** :
- Classification : cat√©gories connues √† l'avance
- Clustering : d√©couvrir les groupes naturels

**Applications** :
- Segmentation de client√®le
- Organisation de produits similaires
- Analyse de comportements utilisateurs
- Compression de donn√©es

**Algorithmes** :
- K-Means (le plus populaire)
- DBSCAN
- Hierarchical Clustering

**Cas d'usage Delphi** :
Application marketing qui segmente automatiquement les clients en groupes homog√®nes pour des campagnes cibl√©es.

### 6. Syst√®mes de recommandation

**Qu'est-ce que c'est ?** : Sugg√©rer des items pertinents pour un utilisateur.

**Types** :

**Filtrage collaboratif** :
"Les utilisateurs similaires √† vous ont aussi aim√©..."

**Filtrage bas√© sur le contenu** :
"Vous avez aim√© X, vous aimerez probablement Y car similaire"

**Hybride** :
Combinaison des deux approches

**Applications** :
- Recommandation de produits e-commerce
- Suggestions de contenu
- Associations de services

**Cas d'usage Delphi** :
Application de vente qui sugg√®re automatiquement des produits compl√©mentaires lors de la saisie d'une commande.

## Le cycle de vie d'un mod√®le pr√©dictif

### Vue d'ensemble du processus

```
1. D√©finir le probl√®me
    ‚Üì
2. Collecter les donn√©es
    ‚Üì
3. Explorer et pr√©parer les donn√©es
    ‚Üì
4. Choisir l'algorithme
    ‚Üì
5. Entra√Æner le mod√®le
    ‚Üì
6. √âvaluer les performances
    ‚Üì
7. Optimiser (tuning)
    ‚Üì
8. D√©ployer en production
    ‚Üì
9. Monitorer et maintenir
    ‚Üì
(Retour √† l'√©tape 2 pour am√©lioration continue)
```

### 1. D√©finir le probl√®me

**Questions cl√©s** :
- Que voulez-vous pr√©dire exactement ?
- Est-ce un probl√®me de r√©gression ou de classification ?
- Quel niveau de pr√©cision est n√©cessaire ?
- Quelles sont les contraintes (temps, co√ªt, ressources) ?

**Exemple** :
"Nous voulons pr√©dire quels clients vont se d√©sabonner dans les 30 prochains jours avec au moins 80% de pr√©cision pour lancer des campagnes de r√©tention cibl√©es."

### 2. Collecter les donn√©es

**Sources de donn√©es** :
- Base de donn√©es d'application (FireDAC)
- Fichiers CSV/Excel
- API externes
- Logs et √©v√©nements
- Capteurs et IoT
- Saisies utilisateurs

**Volume n√©cessaire** :
- Minimum : quelques centaines d'exemples
- Id√©al : plusieurs milliers √† millions
- D√©pend de la complexit√© du probl√®me

**Qualit√© > Quantit√©** : Mieux vaut 1000 exemples de qualit√© que 100000 exemples bruit√©s.

### 3. Explorer et pr√©parer les donn√©es

**Exploration (EDA - Exploratory Data Analysis)** :
- Statistiques descriptives
- Visualisations (histogrammes, scatter plots)
- Recherche de corr√©lations
- D√©tection de valeurs manquantes ou aberrantes

**Nettoyage** :
```pascal
// Pseudo-code : Nettoyer des donn√©es
procedure NettoyerDonnees(var Dataset: TDataSet);
begin
  // Supprimer les doublons
  SupprimerDoublons(Dataset);

  // G√©rer les valeurs manquantes
  RemplirValeursMissing(Dataset, 'moyenne'); // ou 'm√©diane', 'mode'

  // Supprimer les outliers extr√™mes
  FiltrerOutliers(Dataset, 3.0); // 3 √©carts-types

  // Normaliser les formats
  NormaliserDates(Dataset);
  NormaliserTexte(Dataset); // majuscules, espaces
end;
```

**Transformation des features** :

**Normalisation** :
Mettre toutes les valeurs sur la m√™me √©chelle (0-1 ou -1 √† 1).
```
Valeur normalis√©e = (Valeur - Min) / (Max - Min)
```

**Encodage de cat√©gories** :
Convertir texte en nombres.
```
Couleur : "Rouge" ‚Üí [1, 0, 0]
          "Vert"  ‚Üí [0, 1, 0]
          "Bleu"  ‚Üí [0, 0, 1]
```

**Feature engineering** :
Cr√©er de nouvelles features √† partir des existantes.
```
Age + Genre + Historique achats ‚Üí "Segment client"
Date ‚Üí "Jour de la semaine", "Mois", "Est weekend", "Est f√©ri√©"
```

### 4. Choisir l'algorithme

**Pour d√©buter** :
- **R√©gression** : Commencer avec r√©gression lin√©aire
- **Classification** : Commencer avec arbre de d√©cision ou r√©gression logistique
- **S√©ries temporelles** : Prophet (simple) ou ARIMA

**Crit√®res de choix** :
- Complexit√© du probl√®me
- Volume de donn√©es
- Besoin d'interpr√©tabilit√©
- Contraintes de performance
- Ressources disponibles

**R√®gle empirique** :
"Commencez simple, complexifiez si n√©cessaire."

### 5. Entra√Æner le mod√®le

**Principe** : Le mod√®le "apprend" en ajustant ses param√®tres internes pour minimiser l'erreur sur les donn√©es d'entra√Ænement.

**Split des donn√©es** :
```
Toutes les donn√©es (100%)
    ‚Üì
‚îú‚îÄ Entra√Ænement (70-80%)  ‚Üí Pour apprendre
‚îú‚îÄ Validation (10-15%)     ‚Üí Pour optimiser
‚îî‚îÄ Test (10-15%)          ‚Üí Pour √©valuer en conditions r√©elles
```

**Important** : JAMAIS utiliser les donn√©es de test pendant l'entra√Ænement ou l'optimisation !

**Avec Python (via Python4Delphi)** :
```python
# Entra√Ænement d'un mod√®le simple
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split

# S√©parer donn√©es
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# Cr√©er et entra√Æner le mod√®le
model = LinearRegression()
model.fit(X_train, y_train)

# Sauvegarder pour utilisation dans Delphi
import pickle
pickle.dump(model, open('model.pkl', 'wb'))
```

### 6. √âvaluer les performances

**M√©triques pour r√©gression** :

**MAE (Mean Absolute Error)** :
Erreur moyenne absolue. Plus simple √† comprendre.
```
MAE = moyenne(|Pr√©diction - R√©alit√©|)
```

**RMSE (Root Mean Square Error)** :
P√©nalise davantage les grandes erreurs.

**R¬≤ (Coefficient de d√©termination)** :
Proportion de variance expliqu√©e (0 √† 1, plus proche de 1 = meilleur).

**M√©triques pour classification** :

**Accuracy (Pr√©cision globale)** :
Pourcentage de pr√©dictions correctes.
```
Accuracy = (Vrais Positifs + Vrais N√©gatifs) / Total
```

**Precision (Pr√©cision)** :
Parmi les pr√©dictions positives, combien √©taient correctes ?

**Recall (Rappel)** :
Parmi tous les cas positifs r√©els, combien ont √©t√© d√©tect√©s ?

**F1-Score** :
Moyenne harmonique de Precision et Recall.

**Matrice de confusion** :
```
                Pr√©diction
              Positif  N√©gatif
R√©alit√©  Pos     TP       FN
         Neg     FP       TN

TP = Vrais Positifs
TN = Vrais N√©gatifs
FP = Faux Positifs (Erreur type I)
FN = Faux N√©gatifs (Erreur type II)
```

### 7. Optimiser le mod√®le

**Hyperparam√®tres** :
R√©glages du mod√®le qu'on d√©finit AVANT l'entra√Ænement.

**Exemples** :
- Profondeur maximale d'un arbre de d√©cision
- Nombre de neurones dans un r√©seau
- Taux d'apprentissage

**Techniques d'optimisation** :

**Grid Search** :
Tester toutes les combinaisons possibles.
```
Taux d'apprentissage: [0.01, 0.1, 0.5]
Nombre de couches: [2, 3, 4]
‚Üí 3 √ó 3 = 9 combinaisons √† tester
```

**Random Search** :
Tester des combinaisons al√©atoires (plus efficace).

**Cross-validation** :
Validation crois√©e pour √©viter le surapprentissage.

### 8. D√©ployer en production

**Options pour Delphi** :

**Option 1 : Exporter vers ONNX**
```python
# Python : Convertir en ONNX
import sklearn
from skl2onnx import convert_sklearn
from skl2onnx.common.data_types import FloatTensorType

initial_type = [('float_input', FloatTensorType([None, 4]))]
onx = convert_sklearn(model, initial_types=initial_type)

with open("model.onnx", "wb") as f:
    f.write(onx.SerializeToString())
```

Puis utiliser ONNX Runtime depuis Delphi.

**Option 2 : Service REST Python**
```python
# Python : Flask API
from flask import Flask, request, jsonify
import pickle

app = Flask(__name__)
model = pickle.load(open('model.pkl', 'rb'))

@app.route('/predict', methods=['POST'])
def predict():
    data = request.json['features']
    prediction = model.predict([data])
    return jsonify({'prediction': prediction[0]})

if __name__ == '__main__':
    app.run(port=5000)
```

```pascal
// Delphi : Appeler l'API
function FairePrediction(const Features: TArray<Double>): Double;
var
  JSONObj: TJSONObject;
  JSONArray: TJSONArray;
  Feature: Double;
begin
  JSONArray := TJSONArray.Create;
  for Feature in Features do
    JSONArray.Add(Feature);

  JSONObj := TJSONObject.Create;
  try
    JSONObj.AddPair('features', JSONArray);

    RESTRequest.Body.Add(JSONObj.ToString);
    RESTRequest.Execute;

    Result := RESTResponse.JSONValue.GetValue<Double>('prediction');
  finally
    JSONObj.Free;
  end;
end;
```

**Option 3 : Python4Delphi**
Charger et utiliser directement le mod√®le Python.

### 9. Monitorer et maintenir

**Monitoring continu** :
- Tracker les performances en production
- D√©tecter la d√©rive du mod√®le (model drift)
- Alertes si pr√©cision chute

**Concept drift** :
Quand les patterns des donn√©es changent avec le temps, le mod√®le devient moins performant.

**Solutions** :
- R√©entra√Ænement r√©gulier (mensuel, trimestriel)
- Mise √† jour avec nouvelles donn√©es
- A/B testing de nouveaux mod√®les

## Int√©gration pratique dans Delphi

### Architecture recommand√©e

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Application Delphi (UI)         ‚îÇ
‚îÇ   - Collecte des features         ‚îÇ
‚îÇ   - Affichage des pr√©dictions     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Couche de pr√©diction Delphi     ‚îÇ
‚îÇ   - Pr√©paration des donn√©es       ‚îÇ
‚îÇ   - Cache des pr√©dictions         ‚îÇ
‚îÇ   - Gestion des erreurs           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Service de ML                   ‚îÇ
‚îÇ   - ONNX Runtime (local)          ‚îÇ
‚îÇ   - ou API REST Python            ‚îÇ
‚îÇ   - ou Python4Delphi              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Exemple : Pr√©diction de churn client

**Contexte** : Pr√©dire si un client va se d√©sabonner.

**Features utilis√©es** :
- Anciennet√© (mois)
- Nombre d'achats derniers 6 mois
- Montant moyen par commande
- Nombre de contacts support
- D√©lai depuis dernier achat
- Score de satisfaction

**Impl√©mentation Delphi** :

```pascal
type
  TClientFeatures = record
    Anciennete: Integer;
    NbAchats: Integer;
    MontantMoyen: Double;
    ContactsSupport: Integer;
    JoursDepuisDernierAchat: Integer;
    ScoreSatisfaction: Double;
  end;

  TPredictionChurn = record
    Probabilite: Double;
    Risque: string; // 'FAIBLE', 'MOYEN', '√âLEV√â'
    ActionsRecommandees: TArray<string>;
  end;

function PredireChurn(const ClientID: Integer): TPredictionChurn;
var
  Features: TClientFeatures;
  Proba: Double;
begin
  // 1. R√©cup√©rer les donn√©es du client
  Features := ChargerFeaturesClient(ClientID);

  // 2. Normaliser les features
  Features := NormaliserFeatures(Features);

  // 3. Faire la pr√©diction
  Proba := AppelerModeleChurn(Features);

  // 4. Interpr√©ter le r√©sultat
  Result.Probabilite := Proba;

  if Proba >= 0.7 then
  begin
    Result.Risque := '√âLEV√â';
    Result.ActionsRecommandees := [
      'Contacter imm√©diatement',
      'Offrir remise 20%',
      'Proposer support premium gratuit'
    ];
  end
  else if Proba >= 0.4 then
  begin
    Result.Risque := 'MOYEN';
    Result.ActionsRecommandees := [
      'Email personnalis√©',
      'Proposition de nouveaux produits'
    ];
  end
  else
  begin
    Result.Risque := 'FAIBLE';
    Result.ActionsRecommandees := ['Suivi standard'];
  end;
end;

// Utilisation dans l'interface
procedure TFormClient.BtnAnalyserClick(Sender: TObject);
var
  Prediction: TPredictionChurn;
begin
  Prediction := PredireChurn(ClientActuelID);

  LabelRisque.Caption := Prediction.Risque;
  GaugeRisque.Progress := Round(Prediction.Probabilite * 100);

  MemoActions.Lines.Clear;
  MemoActions.Lines.AddStrings(Prediction.ActionsRecommandees);

  // Changer la couleur selon le risque
  case Prediction.Risque of
    '√âLEV√â': PanelRisque.Color := clRed;
    'MOYEN': PanelRisque.Color := clYellow;
    'FAIBLE': PanelRisque.Color := clGreen;
  end;
end;
```

### Traitement par batch

Pour des pr√©dictions sur de nombreux enregistrements :

```pascal
procedure AnalyserTousClients;
var
  Query: TFDQuery;
  Prediction: TPredictionChurn;
  ClientID: Integer;
begin
  ProgressBar.Max := GetNombreClients;
  ProgressBar.Position := 0;

  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection;
    Query.SQL.Text := 'SELECT ClientID FROM Clients WHERE Actif = 1';
    Query.Open;

    while not Query.Eof do
    begin
      ClientID := Query.FieldByName('ClientID').AsInteger;

      // Pr√©diction
      Prediction := PredireChurn(ClientID);

      // Sauvegarder en base
      SauvegarderPrediction(ClientID, Prediction);

      Query.Next;
      ProgressBar.Position := ProgressBar.Position + 1;
      Application.ProcessMessages; // Garder l'UI r√©active
    end;
  finally
    Query.Free;
  end;

  ShowMessage('Analyse termin√©e !');
end;
```

### Gestion du cache

```pascal
type
  TCachePredictions = class
  private
    FCache: TDictionary<Integer, TPredictionChurn>;
    FExpiration: TDictionary<Integer, TDateTime>;
    FDureeValidite: Integer; // en heures
  public
    constructor Create(DureeValiditeHeures: Integer = 24);
    destructor Destroy; override;

    function ObtenirPrediction(ClientID: Integer): TPredictionChurn;
    procedure InvaliderCache(ClientID: Integer);
    procedure ViderCache;
  end;

function TCachePredictions.ObtenirPrediction(ClientID: Integer): TPredictionChurn;
var
  DateExpiration: TDateTime;
begin
  // V√©rifier si en cache et encore valide
  if FCache.ContainsKey(ClientID) and
     FExpiration.TryGetValue(ClientID, DateExpiration) then
  begin
    if Now < DateExpiration then
    begin
      // Cache valide
      Result := FCache[ClientID];
      Exit;
    end;
  end;

  // Pas en cache ou expir√©, calculer
  Result := PredireChurn(ClientID);

  // Mettre en cache
  FCache.AddOrSetValue(ClientID, Result);
  FExpiration.AddOrSetValue(ClientID, Now + (FDureeValidite / 24));
end;
```

## Cas pratiques avec Delphi

### 1. Pr√©vision de ventes

**Objectif** : Pr√©dire les ventes mensuelles pour optimiser les stocks.

**Features** :
- Historique des ventes (12-24 derniers mois)
- Saisonnalit√© (mois, jour de la semaine)
- Promotions planifi√©es
- √âv√©nements externes (vacances, m√©t√©o)
- Tendances du march√©

**Mod√®le** : S√©ries temporelles (Prophet ou ARIMA)

**Int√©gration** :
```pascal
function PrevoirVentesProchainMois: TArray<Double>;
var
  HistoriqueVentes: TArray<Double>;
  Previsions: TJSONArray;
  i: Integer;
begin
  // R√©cup√©rer l'historique
  HistoriqueVentes := ChargerHistoriqueVentes(24); // 24 mois

  // Appeler API Python
  RESTRequest.AddParameter('historique',
    TJSONArray.Create(HistoriqueVentes).ToString);
  RESTRequest.Execute;

  // Parser les pr√©visions
  Previsions := RESTResponse.JSONValue.GetValue<TJSONArray>('previsions');
  SetLength(Result, Previsions.Count);

  for i := 0 to Previsions.Count - 1 do
    Result[i] := Previsions.Items[i].AsType<Double>;
end;
```

**Affichage** : Graphique avec TeeChart montrant historique + pr√©visions.

### 2. Scoring de leads

**Objectif** : √âvaluer automatiquement la qualit√© des prospects pour prioriser les actions commerciales.

**Features** :
- Taille entreprise
- Secteur d'activit√©
- Source du lead
- Comportement sur le site (pages vues, temps pass√©)
- Interactions emails
- Budget estim√©

**Mod√®le** : Classification (Random Forest ou Gradient Boosting)

**Classes** :
- A (Excellent) : > 80% chance de conversion
- B (Bon) : 50-80%
- C (Moyen) : 20-50%
- D (Faible) : < 20%

**Interface Delphi** :
```pascal
procedure TFormLead.CalculerScore;
var
  Score: string;
  Probabilite: Double;
begin
  Probabilite := PredireConversionLead(LeadActuel);

  if Probabilite >= 0.8 then
    Score := 'A'
  else if Probabilite >= 0.5 then
    Score := 'B'
  else if Probabilite >= 0.2 then
    Score := 'C'
  else
    Score := 'D';

  LabelScore.Caption := Format('Score: %s (%d%%)',
    [Score, Round(Probabilite * 100)]);

  // Afficher actions recommand√©es
  AfficherActionsRecommandees(Score);
end;
```

### 3. Maintenance pr√©dictive

**Objectif** : Anticiper les pannes d'√©quipements industriels.

**Features** :
- √Çge de la machine
- Heures de fonctionnement
- Temp√©rature
- Vibrations
- Consommation √©lectrique
- Historique de maintenance

**Mod√®le** : R√©gression (pr√©dire jours avant panne) ou Classification (panne imminente oui/non)

**Alerte proactive** :
```pascal
procedure VerifierEtatEquipements;
var
  Query: TFDQuery;
  EquipementID: Integer;
  JoursAvantPanne: Double;
begin
  Query := TFDQuery.Create(nil);
  try
    Query.Connection := FDConnection;
    Query.SQL.Text := 'SELECT * FROM Equipements WHERE Actif = 1';
    Query.Open;

    while not Query.Eof do
    begin
      EquipementID := Query.FieldByName('ID').AsInteger;
      JoursAvantPanne := PredirePanneEquipement(EquipementID);

      if JoursAvantPanne <= 7 then
      begin
        // Alerte urgente
        CreerTicketMaintenance(EquipementID, 'URGENTE');
        EnvoyerNotification(
          Format('√âquipement %d : panne pr√©dite dans %.1f jours',
            [EquipementID, JoursAvantPanne])
        );
      end
      else if JoursAvantPanne <= 30 then
      begin
        // Alerte pr√©ventive
        PlanifierMaintenance(EquipementID, Now + JoursAvantPanne);
      end;

      Query.Next;
    end;
  finally
    Query.Free;
  end;
end;
```

### 4. D√©tection de fraudes

**Objectif** : Identifier les transactions suspectes en temps r√©el.

**Features** :
- Montant de la transaction
- Localisation (diff√©rente de l'habituelle ?)
- Heure (inhabituelle ?)
- Type de marchand
- Fr√©quence des transactions r√©centes
- Historique du client

**Mod√®le** : Classification (Isolation Forest ou r√©seau de neurones)

**Traitement temps r√©el** :
```pascal
function VerifierTransaction(const Transaction: TTransaction): TResultatVerification;
var
  ScoreFraude: Double;
begin
  // Calculer score de fraude
  ScoreFraude := DetecterFraude(Transaction);

  Result.Suspect := ScoreFraude > 0.7;
  Result.Score := ScoreFraude;

  if ScoreFraude > 0.9 then
  begin
    Result.Action := 'BLOQUER';
    Result.Raison := 'Tr√®s haute probabilit√© de fraude';
  end
  else if ScoreFraude > 0.7 then
  begin
    Result.Action := 'V√âRIFICATION_MANUELLE';
    Result.Raison := 'Transaction suspecte, validation requise';
  end
  else
  begin
    Result.Action := 'APPROUVER';
    Result.Raison := 'Transaction normale';
  end;

  // Logger pour audit
  LoggerTransaction(Transaction, Result);
end;
```

### 5. Optimisation de prix dynamique

**Objectif** : Sugg√©rer le prix optimal pour maximiser les ventes ou la marge.

**Features** :
- Co√ªt du produit
- Prix concurrents
- √âlasticit√©-prix historique
- Stock disponible
- Saison/p√©riode
- Segment client

**Mod√®le** : R√©gression ou optimisation (reinforcement learning avanc√©)

**Application** :
```pascal
function SuggererPrixOptimal(const ProduitID: Integer): TPrixOptimal;
var
  PrixMin, PrixMax, PrixSuggere: Double;
  VentesEstimees: Integer;
begin
  // Contraintes
  PrixMin := ObtenirCoutProduit(ProduitID) * 1.2; // Marge min 20%
  PrixMax := ObtenirPrixMarcheMax(ProduitID);

  // Pr√©diction
  PrixSuggere := PredirePrixOptimal(ProduitID);

  // S'assurer dans les contraintes
  if PrixSuggere < PrixMin then
    PrixSuggere := PrixMin;
  if PrixSuggere > PrixMax then
    PrixSuggere := PrixMax;

  Result.Prix := PrixSuggere;
  Result.VentesEstimees := PrevoirVentes(ProduitID, PrixSuggere);
  Result.MargeEstimee := CalculerMarge(ProduitID, PrixSuggere);

  Result.Confiance := ObtenirConfianceModele;
end;
```

## Outils et biblioth√®ques pour mod√®les pr√©dictifs

### Scikit-learn (Python)

**Le couteau suisse du ML** :
- Dizaines d'algorithmes impl√©ment√©s
- Interface coh√©rente et simple
- Excellent pour d√©buter
- Tr√®s bien document√©

**Usage avec Delphi** : Via Python4Delphi ou API REST

**Forces** :
- ML "classique" (non deep learning)
- Pr√©traitement de donn√©es
- Validation et m√©triques

### XGBoost / LightGBM

**Mod√®les d'ensemble tr√®s performants** :
- Souvent gagnants de comp√©titions Kaggle
- Excellents pour donn√©es tabulaires
- Tr√®s rapides

**Cas d'usage** : Scoring, pr√©dictions de s√©ries, classification complexe

### Prophet (Facebook)

**Sp√©cialis√© s√©ries temporelles** :
- Tr√®s simple d'utilisation
- G√®re automatiquement saisonnalit√©
- Robuste aux donn√©es manquantes
- Id√©al pour pr√©visions business

### TensorFlow / Keras

**Pour deep learning** :
- R√©seaux de neurones complexes
- Excellent pour grandes quantit√©s de donn√©es
- GPU requis pour performances

### H2O.ai

**Plateforme AutoML** :
- Automatise le choix et l'optimisation des mod√®les
- Interface REST native
- Parfait pour Delphi

**Avantage** : Pas besoin d'√™tre expert ML, H2O fait le travail.

## Pi√®ges et bonnes pratiques

### Pi√®ges courants

**1. Surapprentissage (Overfitting)**

**Sympt√¥me** : Mod√®le excellent sur donn√©es d'entra√Ænement, mauvais en production.

**Cause** : Le mod√®le a "m√©moris√©" plut√¥t qu'appris des patterns g√©n√©raux.

**Solutions** :
- Plus de donn√©es d'entra√Ænement
- R√©gularisation
- Validation crois√©e
- Simplifier le mod√®le

**2. Fuite de donn√©es (Data Leakage)**

**Erreur** : Inclure dans les features des informations qui ne seront pas disponibles au moment de la pr√©diction.

**Exemple** : Pr√©dire si un client va acheter en incluant "montant total achet√©" (qui n'existe que s'il a d√©j√† achet√©).

**3. Biais dans les donn√©es**

**Probl√®me** : Donn√©es d'entra√Ænement non repr√©sentatives de la r√©alit√©.

**Exemple** : Entra√Æner sur donn√©es de l'√©t√© pour pr√©dire toute l'ann√©e.

**Solution** : Donn√©es diversifi√©es et repr√©sentatives.

**4. Ignorer la d√©rive du mod√®le**

**Probl√®me** : Le monde change, les patterns aussi.

**Solution** : Monitoring continu et r√©entra√Ænement r√©gulier.

### Bonnes pratiques

**1. Commencer simple**
Testez d'abord un mod√®le simple (r√©gression lin√©aire, arbre de d√©cision). Complexifiez seulement si n√©cessaire.

**2. Feature engineering > Algorithme complexe**
De bonnes features avec un mod√®le simple battent souvent un mod√®le complexe avec features m√©diocres.

**3. Toujours avoir des donn√©es de test s√©par√©es**
JAMAIS toucher aux donn√©es de test avant l'√©valuation finale.

**4. Documenter vos choix**
Notez pourquoi vous avez choisi tel algorithme, tels hyperparam√®tres.

**5. Versionner vos mod√®les**
Comme le code, gardez l'historique de vos mod√®les.

```pascal
// Structure de versioning
type
  TVersionModele = record
    Version: string;        // '1.2.3'
    DateCreation: TDateTime;
    Algorithme: string;
    Features: TArray<string>;
    Performance: Double;    // Score sur test set
    CheminFichier: string;  // 'models/churn_v1.2.3.onnx'
  end;
```

**6. Expliquez les pr√©dictions**
Donnez du contexte √† l'utilisateur, pas juste un chiffre.

```pascal
// Mauvais
ShowMessage('Probabilit√©: 0.73');

// Bon
ShowMessage(
  'Risque de d√©sabonnement: √âLEV√â (73%)' + #13#10 +
  'Facteurs principaux:' + #13#10 +
  '- Pas d''achat depuis 90 jours' + #13#10 +
  '- 3 contacts support le mois dernier' + #13#10 +
  '- Score satisfaction en baisse'
);
```

**7. Mesurer l'impact business**
Un mod√®le pr√©cis mais inutilis√© ne sert √† rien.

**M√©triques business** :
- ROI de l'impl√©mentation
- Temps √©conomis√©
- Augmentation des ventes
- R√©duction des co√ªts

## Conclusion

Le d√©veloppement de mod√®les pr√©dictifs transforme vos applications Delphi en syst√®mes intelligents capables d'anticiper et d'optimiser les d√©cisions. Bien que le Machine Learning puisse sembler complexe, les outils modernes et les approches d'int√©gration avec Delphi rendent ces technologies accessibles.

**Points essentiels** :
- Les mod√®les pr√©dictifs apprennent des patterns du pass√© pour pr√©voir l'avenir
- R√©gression (valeurs) et Classification (cat√©gories) couvrent la majorit√© des cas d'usage
- Le cycle de vie : donn√©es ‚Üí entra√Ænement ‚Üí √©valuation ‚Üí d√©ploiement ‚Üí monitoring
- L'int√©gration avec Delphi se fait via ONNX, API REST, ou Python4Delphi
- La qualit√© des donn√©es et le feature engineering sont cruciaux
- Commencez simple et it√©rez

**Pour d√©marrer** :
1. Identifiez un cas d'usage concret dans votre application
2. Collectez et nettoyez les donn√©es historiques
3. Commencez avec un mod√®le simple via API ou Python
4. Int√©grez progressivement dans votre interface Delphi
5. Mesurez l'impact et am√©liorez

La prochaine section explorera l'int√©gration avec les services d'IA cloud comme Azure AI et Google AI, offrant des capacit√©s encore plus avanc√©es pour vos applications Delphi !

‚è≠Ô∏è [Int√©gration avec des services d'IA cloud (Azure AI, Google AI, etc.)](/22-intelligence-artificielle-et-machine-learning-avec-delphi/06-integration-avec-des-services-dia-cloud.md)
